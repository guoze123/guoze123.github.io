<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则</title>
      <link href="2022/09/05/%E6%AD%A3%E5%88%99/"/>
      <url>2022/09/05/%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="正则的认识"><a href="#正则的认识" class="headerlink" title="正则的认识"></a>正则的认识</h2><h3 id="什么是正则"><a href="#什么是正则" class="headerlink" title="什么是正则"></a>什么是正则</h3><blockquote><p>❝<br>regular expression:RegExp (处理字符串的一种规则)<br>❞</p></blockquote><ul><li>用来<strong>「处理字符串」</strong>的一种规则（只能处理字符串，不是字符串不能处理，但是可以使用<code>toString()</code>方法变为字符串，哈哈哈哈，有没有被绕蒙，下面举个栗子理解一下吧）</li><li>他是一个<strong>「规则」</strong>：可以验证字符串是否符合某个规则（test），也可以把字符串中符合规则的内容捕获到（exec/match…）</li></ul><a id="more"></a><h2 id="编写正则表达式"><a href="#编写正则表达式" class="headerlink" title="编写正则表达式"></a>编写正则表达式</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><h4 id="字面量创建方式"><a href="#字面量创建方式" class="headerlink" title="字面量创建方式"></a>字面量创建方式</h4><p>两个斜杆之间包起来的，都是用来描述规则的元字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/\d+/</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="构造函数模式创建"><a href="#构造函数模式创建" class="headerlink" title="构造函数模式创建"></a>构造函数模式创建</h4><p>使用正则对象 <code>new</code>的方式，写成字符串形式的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明，字符串中直接`\d`是输出的d,因此需要使用`\`转义一下，</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\d+&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>❝</p><p>不管使用以上哪种方式创建，得到的都是对象数据类型的。虽然 reg1 和 reg2 的规则一样，但是 <code>reg1!==reg2</code>，其实就是他们的堆内存地址不一样。（这个涉及到了 JS 中的数据类型的知识，不明白的小伙伴们可以去回顾一下哟！）</p><p>❞</p></blockquote><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><p>很重要，<strong>「背下来，背下来，背下来…」</strong> 这是正则的基础，如果连每个字符代表的含义都不明白，正则基本就废了</p><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ul><li>量词元字符：设置出现的次数</li></ul><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>零到多次</td></tr><tr><td>+</td><td>一到多次</td></tr><tr><td>？</td><td>零到一次</td></tr><tr><td>{n}</td><td>n 次</td></tr><tr><td>{n,}</td><td>n 到多次</td></tr><tr><td>{n,m}</td><td>n 到 m 次</td></tr></tbody></table><ul><li>特殊元字符：单个或者组合在一起代表特殊的含义</li></ul><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>转义字符</td></tr><tr><td>.</td><td>除\n（换行符）之外的任意字符</td></tr><tr><td>^</td><td>以哪一个元字符开头</td></tr><tr><td>$</td><td>以哪一个元字符结尾</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\d</td><td>0-9 之间的一个数字（包含 0 和 9）</td></tr><tr><td>\D</td><td>除 0-9 之间的一个数字</td></tr><tr><td>\w</td><td>数字、字母、下划线中的任意一个字符</td></tr><tr><td>\s</td><td>一个空白字符（包含空格、制表符、换页符）</td></tr><tr><td>\t</td><td>一个制表符（一个 TAB 键，四个空格）</td></tr><tr><td>\b</td><td>匹配一个单词的边界</td></tr><tr><td>x|y</td><td>x 或 y 中的一个字符</td></tr><tr><td>[xyz]</td><td>x 或 y 或 z 中的一个字符</td></tr><tr><td>[^xy]</td><td>除了 x 和 y 以外的任意一个字符</td></tr><tr><td>[a-z]</td><td>指定 a-z 这个范围的任意字符</td></tr><tr><td>[^a-z]</td><td>上一个的取反“非”</td></tr><tr><td>()</td><td>正则中的分组符号</td></tr><tr><td>(?:)</td><td>只匹配不捕获</td></tr><tr><td>(?=)</td><td>正向预查</td></tr><tr><td>(?!)</td><td>反向预查</td></tr></tbody></table><ul><li>普通元字符：代表本身含义的<ul><li><code>/name/</code>此正则就是去匹配字符串中的<code>&#39;name&#39;</code></li></ul></li></ul><h4 id="修饰符：放在正则表达式的外面-j-g"><a href="#修饰符：放在正则表达式的外面-j-g" class="headerlink" title="修饰符：放在正则表达式的外面 /j/g"></a>修饰符：放在正则表达式的外面 <code>/j/g</code></h4><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td>i(ignoreCase)</td><td>忽略大小写匹配</td></tr><tr><td>m(multiline)</td><td>可以进行多行匹配</td></tr><tr><td>g(global)</td><td>全局匹配</td></tr><tr><td>u(Unicode)</td><td>用来正确处理大于\uFFF 的 Unicode 字符</td></tr><tr><td>y(sticky)</td><td>粘连</td></tr><tr><td>s(dotAll)</td><td>让’.’能匹配任意字符，包含\n\r</td></tr></tbody></table><h3 id="常用元字符的详解"><a href="#常用元字符的详解" class="headerlink" title="常用元字符的详解"></a>常用元字符的详解</h3><h4 id><a href="#" class="headerlink" title="^ $"></a>^ $</h4><blockquote><p>❝</p><p>在我们写正则表达式的时候，为了更加严谨，一般都要加上这两个元字符，然后把我们的规则写在他们之间（如果不写^$ 的话，我们写的规则有时会出现意想不到的事情，哈哈，别着急，一步步来。下面介绍到{n，m}的时候会结合它一起说明）</p><p>❞</p></blockquote><ul><li>^ 以什么元字符开始</li><li>$ 以什么元字符结尾</li><li>^/$ 两个都不加匹配的是：字符串中包含符合规则的内容即可</li><li>^/$ 两个都加匹配的是：字符串只能是和规则一致的内容</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配的是：以数字开头的字符串</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;name&#x27;</span>));   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2020name&#x27;</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;name2020&#x27;</span>));   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配的是：以数字结尾的字符串</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2020name&#x27;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;name2020&#x27;</span>));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ^/$ 两个都不加匹配的是：字符串中包含符合规则的内容即可</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg1.test(<span class="string">&#x27;as2&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//^/$ 两个都加匹配的是：字符串只能是和规则一致的内容</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/^\d$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(<span class="string">&#x27;as2&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(<span class="string">&#x27;22&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(<span class="string">&#x27;2&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title="\"></a>\</h4><ul><li>转义字符，他可以把没有意义的转为有意义的，也可以把有意义的变为没有意义的（好像又成功的把你们说迷糊了吧，哈哈，举个栗子什么都明白了）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//‘.’ 是代表除换行符之外的任意字符，而不是小数点</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^2.3$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2.3&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2@3&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;23&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在我们把‘.’变为一个普通的小数点（使用到的就是\）</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^2\.3$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2.3&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2@3&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="x-y"><a href="#x-y" class="headerlink" title="x|y"></a>x|y</h4><ul><li>x 或 y：直接 x|y 会存在优先级问题，一般配合小括号进行分组使用，因为小括号改变处理的优先级 =&gt; 小括号：分组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配的是：以18开头或者以29结尾的都可以,以1开头以9结尾，8或2都可以，所以不加括号怎么理解都可以</span></span><br><span class="line"><span class="comment">//以下的匹配结果都为true</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^18|29$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;18&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;29&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;129&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;189&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;1829&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;182&#x27;</span>));</span><br><span class="line"><span class="comment">//以上不加括号我们可以有很多理解方式都是对的，但是我们加上括号，就不可能想上面那样理解了；</span></span><br><span class="line"><span class="comment">//匹配的是：18或者29中的一个，其余都是false</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^(18|29)$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;18&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;29&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;129&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;189&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h4><ul><li>中括号中出现的字符<strong>「一般」</strong>都代表它本身的含义（会消磁，把他本身的意义都消除掉了）</li><li>\d 在中括号里面的含义仍然是 0-9，这个没有消磁</li><li>[18]：代表的是 1 或者 8 中的任意一个</li><li>[10-29]：代表的是 1 或者 9 或者 0-2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的‘.’就是小数点的意思</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[.]+$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配的含义是：只能是@或者+的</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[@+]$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;@&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;+&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;@@&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;@+&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配的含义是：\d还是代表0-9</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[\d]$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;9&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;\\&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;d&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配的含义是：1或者8</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[18]$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;1&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;8&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;18&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配的含义是：1或者0-2或者9</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[10-29]$/</span>;</span><br><span class="line"><span class="comment">//匹配的含义是：1或者0-2或者9或&#x27;(&#x27;或&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[(10-29)]$/</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="n-m"><a href="#n-m" class="headerlink" title="{n,m}"></a>{n,m}</h4><ul><li><p>它是代表前面的元字符出现 n 到 m 次</p><blockquote><p>❝</p><p>下面的例子中，不加^$ 的超出范围的虽然返回的是 true，但是在使用 exec 捕获的时候，最多捕获 4 个（这个问题是我在学习的时候最大的一个纠结点，如果不知道加上开头结尾符的话，一直认为这个{n,m}在超出范围是不管用的，哈哈）</p><p>❞</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个正则匹配的是数字出现2到4次即可，明显第三个超出了，应该返回false，但是结果却是true，但是加上^$ 就不一样了</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d&#123;2,4&#125;/</span>;</span><br><span class="line">reg.test(<span class="string">&#x27;1&#x27;</span>);  <span class="comment">//false</span></span><br><span class="line">reg.test(<span class="string">&#x27;14&#x27;</span>); <span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">&#x27;123456&#x27;</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//加上^$ 之后的结果:这个就代表只能有2-4位数字，超过就多余，而上一个匹配的是只有字符串中出现2-4次即可，因此加上^$ 更加严谨</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d&#123;2,4&#125;$/</span>;</span><br><span class="line">reg.test(<span class="string">&#x27;1&#x27;</span>); <span class="comment">//false</span></span><br><span class="line">reg.test(<span class="string">&#x27;14&#x27;</span>); <span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">&#x27;123456&#x27;</span>); <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分组作用"><a href="#分组作用" class="headerlink" title="分组作用"></a>分组作用</h4><ul><li>1.就是改变默认的优先级；</li><li>2.分组捕获；</li><li>3.分组引用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个作用：提升优先级</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/^18|29$/</span>;</span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/^(18|29)$/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个作用：使用exec捕获的时候不仅可以得到整个大正则的结果，也会分别拿到每一个分组内的</span></span><br><span class="line"><span class="keyword">let</span> reg1 =<span class="regexp">/^([1-9]\d&#123;5&#125;)((19|20)\d&#123;2&#125;)(0[1-9]|10|11|12)(0[1-9]|[1-2]\d|30|31)\d&#123;3&#125;(\d|x)$/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个作用：第一位是a-z的字母，分组1,；第二位也是a-z的字母，分组2；第三位\2是和第二个分组出现一模一样的内容...</span></span><br><span class="line"><span class="keyword">let</span> reg1 =<span class="regexp">/^([a-z])([a-z]\2\1)$/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分组的具名化（给分组起名字）-lt-名字-gt"><a href="#分组的具名化（给分组起名字）-lt-名字-gt" class="headerlink" title="分组的具名化（给分组起名字）?&lt;名字&gt;"></a>分组的具名化（给分组起名字）?&lt;名字&gt;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;132123201203200000&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^(?&lt;A&gt;[1-9]\d&#123;5&#125;)(?&lt;B&gt;(19|20)\d&#123;2&#125;)(?&lt;C&gt;0[1-9]|10|11|12)(?&lt;D&gt;0[1-9]|[1-2]\d|30|31)\d&#123;3&#125;(\d|x)$/i</span>;</span><br><span class="line"><span class="keyword">let</span> res = reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="built_in">console</span>.log(res.groups.B);<span class="comment">//可以直接拿到B组的内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正则捕获"><a href="#正则捕获" class="headerlink" title="正则捕获"></a>正则捕获</h2><p>想要实现正则捕获，首先需要满足要和正则匹配（test方法为true，才可以捕获）</p><ul><li>正则 <code>RegExp.prototype</code> 上的方法（exec、test）</li><li>字符串 <code>String.prototype</code> 上支持正则表达式处理的方法（replace、match、splite…）</li></ul><h3 id="exec-正则原型上的方法"><a href="#exec-正则原型上的方法" class="headerlink" title="exec(正则原型上的方法)"></a>exec(正则原型上的方法)</h3><blockquote><p>❝</p><p>基于 <code>exec</code> 实现正则的捕获，它有两个性质:懒惰性和贪婪性。<br>因此就有一句话叫：做人不能太‘正则’哈哈哈</p><p>❞</p></blockquote><h4 id="懒惰性-默认只捕获一个"><a href="#懒惰性-默认只捕获一个" class="headerlink" title="懒惰性:默认只捕获一个"></a>懒惰性:默认只捕获一个</h4><ul><li><p>捕获到的结果是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p> 或一个 数组</p><ul><li>第一项：本次捕获到的内容</li><li>其余项：对应小分组本次单独循环的内容</li><li><code>index</code>：当前捕获内容在字符串中的起始索引</li><li><code>input</code>:原始字符串</li></ul></li><li><p>每执行一次 <code>exec</code>，只能捕获到一个符合正则规则的，但是默认情况下，我们执行一百次，获取的结果永远都是第一个匹配到的，其余的都捕获不到</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;name2020name2020name2020&#x27;</span>;</span><br><span class="line">    reg =<span class="regexp">/\d+/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));<span class="comment">//[&quot;2020&quot;, index: 4, input: &quot;name2020name2020name2020&quot;, groups: undefined]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="懒惰性的解决方法"><a href="#懒惰性的解决方法" class="headerlink" title="懒惰性的解决方法"></a>懒惰性的解决方法</h4><ul><li><code>reg.lastIndex</code>：当前正则下一次匹配的起始索引位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;name2020name2020name2020&#x27;</span>;</span><br><span class="line">    reg =<span class="regexp">/\d+/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「原因：」</strong> 默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远都是第一个。因此只要把lastIndex值改变，就可以解决这个问题<br> <strong>「解决方法：」</strong> 设置全局修饰符g</p><blockquote><p>❝</p><p>设置全局修饰符g后，第一次匹配完成，lastIndex的值会自己修改。<br>当全部捕获后，再次捕获的结果是null，但是lastIndex又回了初始值零,再一次捕获又从第一个开始了…<br>基于test匹配验证后，lastIndex也会被修改</p><p>❞</p></blockquote><h4 id="封装解决正则懒惰性的方法"><a href="#封装解决正则懒惰性的方法" class="headerlink" title="封装解决正则懒惰性的方法"></a>封装解决正则懒惰性的方法</h4><p>需求：编写一个方法execAll，执行一次可以把所有匹配的结果捕获到（前提正则一定要设置全局修饰符g）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">execAll</span>(<span class="params">str = <span class="string">&#x27;&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.global) <span class="keyword">return</span> <span class="built_in">this</span>.exec(str);</span><br><span class="line">    <span class="keyword">let</span> ary = [],</span><br><span class="line">        res = <span class="built_in">this</span>.exec(str);</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        ary.push(res[<span class="number">0</span>]);</span><br><span class="line">        res = <span class="built_in">this</span>.exec(str);        </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span>  ary.length ===<span class="number">0</span>?<span class="literal">null</span>:ary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">RegExp</span>.prototype.execAll = execAll;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/g</span>,</span><br><span class="line">    str = <span class="string">&#x27;name2020name2020&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.execAll(str));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="贪婪性"><a href="#贪婪性" class="headerlink" title="贪婪性"></a>贪婪性</h4><p>默认情况下正则捕获的时候，是按照当前正则所匹配的最长结果来获取的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;name2020&#x27;</span>,</span><br><span class="line">    reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(str.match(reg));   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解决正则的贪婪性问题"><a href="#解决正则的贪婪性问题" class="headerlink" title="解决正则的贪婪性问题"></a>解决正则的贪婪性问题</h4><p>在量词元字符后面设置?取消捕获时候的贪婪性（按照正则匹配的最短结果来获取）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;name2020&#x27;</span>,</span><br><span class="line">    reg = <span class="regexp">/\d+?/g</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(str.match(reg));   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="正则的分组捕获-字符串match方法"><a href="#正则的分组捕获-字符串match方法" class="headerlink" title="正则的分组捕获() | 字符串match方法"></a>正则的分组捕获() | 字符串match方法</h3><p>分析下面栗子的结果:</p><ul><li>第一项：大正则匹配的结果</li><li>其余项：每一个小分组单独匹配捕获的结果</li><li>如果设置了分组（改变优先级），但是捕获的时候不需要单独捕获，可以基于?:来处理,不捕获最后一项： <code>/^([1-9]\d&#123;5&#125;)((19|20)\d&#123;2&#125;)(0[1-9]|10|11|12)(0[1-9]|[1-2]\d|30|31)\d&#123;3&#125;(?:\d|x)$/i</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//身份证号</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;130222195202303210&#x27;</span>,</span><br><span class="line">    reg =<span class="regexp">/^([1-9]\d&#123;5&#125;)((19|20)\d&#123;2&#125;)(0[1-9]|10|11|12)(0[1-9]|[1-2]\d|30|31)\d&#123;3&#125;(\d|x)$/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"><span class="comment">//[&quot;130222195202303210&quot;, &quot;130222&quot;, &quot;1952&quot;, &quot;19&quot;, &quot;02&quot;, &quot;30&quot;, &quot;0&quot;, index: 0, input: &quot;130222195202303210&quot;, groups: undefined]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>================================================</p><ul><li>字符串中的<code>match</code>方法可以在执行一次的情况下，捕获到所有匹配的数据（前提正则也得设置g才可以）</li><li>加g之后，<code>match</code>不能获取到小分组内的东西</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name2020name2020&#x27;</span>.match(reg));<span class="comment">//[&quot;2020&quot;, &quot;2020&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既要捕获到&#123;0&#125;，也要捕获到0</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#123;0&#125;年&#123;1&#125;月&#x27;</span>;</span><br><span class="line">    reg = <span class="regexp">/\&#123;(\d)\&#125;/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));   </span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="replace-字符串原型上的方法"><a href="#replace-字符串原型上的方法" class="headerlink" title="replace(字符串原型上的方法)"></a>replace(字符串原型上的方法)</h3><p>本身是字符串替换的意思。在这里结合正则使用他有一下几个特点  <code>str = str.replace(reg,func)</code>;</p><ul><li>首先会拿reg和func去进行匹配，匹配捕获一次，就会把func函数执行一次</li><li>并且会把每一次捕获的结果（和exec捕获的结果一样）传递给func函数</li><li>在func函数中返回return什么，就相当于把原始字符中,大正则匹配的结果替换成啥</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把-替换成/(不使用正则的时候需要多次执行这个方法，但是正则可以一次替换,前提是加g)</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;2020-04-09&#x27;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#123;0&#125;年&#123;1&#125;月&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\&#123;\d\&#125;/g</span>;</span><br><span class="line">str = str.replace(reg,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);<span class="comment">//存储的是每次正则捕获的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&#x27;1年1月&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正则后向引用"><a href="#正则后向引用" class="headerlink" title="正则后向引用"></a>正则后向引用</h2><p>后向引用用于重复搜索前面某个分组匹配的文本 \1 代表分组1匹配的文本。</p><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><p>我们也可以自己指定子表达式的组名。要指定一个子表达式的组名，需要按照以下的语法：(?<word>[regExp])或者(?’word’[regExp])。这样这个regExp 的组名就被指定为 word 了。要反向引用这个分组 捕获 的内容，就可以使用 \k<word> 或者 \k’word’</word></word></p><p>后向引用的原理是：当捕获组（Expression）在匹配成功时，会将子表达式匹配到的内容保存在内存中以一个数字编号或者自己命名为key的组里，这样就可以通过后向引用的方式引用匹配到的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`/([a-zA-Z])\1/`</span></span><br><span class="line"> </span><br><span class="line">匹配连续出现的单词，比如： <span class="string">`abaasdassdd`</span>, 这样能够匹配 <span class="string">`aa`</span>，<span class="string">`ss`</span> 和 <span class="string">`dd`</span></span><br></pre></td></tr></table></figure><h2 id="问号在正则中的五大作用"><a href="#问号在正则中的五大作用" class="headerlink" title="问号在正则中的五大作用"></a>问号在正则中的五大作用</h2><ul><li>问号左边是非量词元字符：本身代表量词元字符，出现零到一次；</li><li>问号左边是量词元字符：取消捕获时候的贪婪性；</li><li>(?:)：只匹配不捕获；</li><li>(?=)：正向预查；</li><li>(?!): 负向预查</li></ul><h2 id="正则中捕获方法的应用"><a href="#正则中捕获方法的应用" class="headerlink" title="正则中捕获方法的应用"></a>正则中捕获方法的应用</h2><h3 id="时间格式字符串"><a href="#时间格式字符串" class="headerlink" title="时间格式字符串"></a>时间格式字符串</h3><ul><li>月日不足十位补零</li><li>换成年月日的格式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">let</span> time = <span class="string">&#x27;2020-4-9&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = time.match(<span class="regexp">/\d+/g</span>);<span class="comment">//拿到每一项</span></span><br><span class="line">arr = arr.map(<span class="function"><span class="params">item</span>=&gt;</span>item.length&lt;<span class="number">2</span>?<span class="string">&#x27;0&#x27;</span>+item:item);</span><br><span class="line">time = <span class="string">`<span class="subst">$&#123;arr[<span class="number">0</span>]&#125;</span>年<span class="subst">$&#123;arr[<span class="number">1</span>]&#125;</span>月<span class="subst">$&#123;arr[<span class="number">2</span>]&#125;</span>日`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">let</span> time = <span class="string">&#x27;2020-4-9&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = time.match(<span class="regexp">/\d+/g</span>);<span class="comment">//拿到每一项</span></span><br><span class="line">arr = arr.map(<span class="function"><span class="params">item</span>=&gt;</span>item.length&lt;<span class="number">2</span>?<span class="string">&#x27;0&#x27;</span>+item:item);</span><br><span class="line"><span class="keyword">let</span> template = <span class="string">&#x27;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&#x27;</span>;</span><br><span class="line">template = template.replace(<span class="regexp">/\&#123;(\d+)\&#125;/g</span>, <span class="function">(<span class="params">value, group</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[group]; <span class="comment">//=&gt;返回啥就是把TEMPLETE中大正则本次匹配的结果替换成啥</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(template); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="keyword">let</span> time = <span class="string">&#x27;2020-4-9&#x27;</span>;</span><br><span class="line"><span class="built_in">String</span>.prototype.formatTime = <span class="function"><span class="keyword">function</span> <span class="title">formatTime</span>(<span class="params">template</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">let</span> arr = <span class="built_in">this</span>.match(<span class="regexp">/\d+/g</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> item.length &lt; <span class="number">2</span> ? <span class="string">&#x27;0&#x27;</span> + item : item;</span><br><span class="line"> &#125;);</span><br><span class="line"> template = template || <span class="string">&#x27;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> template.replace(<span class="regexp">/\&#123;(\d+)\&#125;/g</span>, <span class="function">(<span class="params">_, group</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[group] || <span class="string">&quot;00&quot;</span>;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(time.formatTime());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串中出现最多次数的字符，多少次"><a href="#字符串中出现最多次数的字符，多少次" class="headerlink" title="字符串中出现最多次数的字符，多少次"></a>字符串中出现最多次数的字符，多少次</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;qwerttydsdsssfggg&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> ary = [...new <span class="built_in">Set</span>(str.split(<span class="string">&#x27;&#x27;</span>))];</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> code = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line"> <span class="comment">//创建正则匹配字符 </span></span><br><span class="line"> <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(ary[i], <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"> <span class="comment">//利用match找出对应字符在中字符串中出现的地方，取匹配的返回数组的长度，即是对应字符串出现的次数</span></span><br><span class="line"> <span class="keyword">let</span> val = str.match(reg).length;</span><br><span class="line"> <span class="comment">//更新出现次数最高的字符与次数</span></span><br><span class="line"> <span class="keyword">if</span> (val &gt; max) &#123;</span><br><span class="line">  max = val;</span><br><span class="line">  code = ary[i];</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val === max) &#123; <span class="comment">//处理不同字符出现次数相同的情况</span></span><br><span class="line">  code = <span class="string">`<span class="subst">$&#123;code&#125;</span>、<span class="subst">$&#123;ary[i]&#125;</span>`</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`出现次数最多的字符是：<span class="subst">$&#123;code&#125;</span>,次数为：<span class="subst">$&#123;max&#125;</span>`</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;sfsdfsgdsdgdfg&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// str.match(/[a-zA-Z]/g) &lt;==&gt; str.split(&#x27;&#x27;)</span></span><br><span class="line">str.match(<span class="regexp">/[a-zA-Z]/g</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 每一次存储之前，验证一下对象中是否已经包含这个字符，如果有，则代表之前存储过，我们此时让数量累加1即可</span></span><br><span class="line"> <span class="keyword">if</span> (obj[item] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  obj[item]++;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> obj[item] = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">0</span>,</span><br><span class="line"> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"> <span class="keyword">let</span> val = obj[key];</span><br><span class="line"> <span class="keyword">if</span> (val &gt; max) &#123;</span><br><span class="line">  max = val;</span><br><span class="line">  result = key;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val === max) &#123;</span><br><span class="line">  result += <span class="string">`|<span class="subst">$&#123;key&#125;</span>`</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max, result); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;sfsdfsdsfdgffd&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&#x27;&#x27;</span>).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 字符比较</span></span><br><span class="line"> <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">1</span>,</span><br><span class="line"> result = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> temp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">let</span> curr = arr[i],</span><br><span class="line">  next = arr[i + <span class="number">1</span>];</span><br><span class="line"> <span class="keyword">if</span> (curr === next) &#123;</span><br><span class="line">  temp++;</span><br><span class="line">  <span class="keyword">if</span> (temp &gt; max) &#123;</span><br><span class="line">   max = temp;</span><br><span class="line">   result = curr;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  temp = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max, result); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法四</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;sfsdsdgsdgsg&quot;</span>;</span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b)).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// console.log(str);//=&gt;&quot;aeefghhhiilnnoopsuuuxzz&quot;</span></span><br><span class="line"><span class="keyword">let</span> ary = str.match(<span class="regexp">/([a-zA-Z])\1+/g</span>).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.length - a.length);</span><br><span class="line"><span class="keyword">let</span> max = ary[<span class="number">0</span>].length,</span><br><span class="line"> res = [ary[<span class="number">0</span>].substr(<span class="number">0</span>, <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line"> <span class="keyword">let</span> item = ary[i];</span><br><span class="line"> <span class="keyword">if</span> (item.length &lt; max) &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> res.push(item.substr(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`出现次数最多的字符：<span class="subst">$&#123;res&#125;</span>，出现了<span class="subst">$&#123;max&#125;</span>次`</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法五</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;fdsgsgdfhi&quot;</span>,</span><br><span class="line"> max = <span class="number">0</span>,</span><br><span class="line"> res = [],</span><br><span class="line"> flag = <span class="literal">false</span>;</span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b)).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = str.length; i &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line"> <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;([a-zA-Z])\\1&#123;&quot;</span> + (i - <span class="number">1</span>) + <span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line"> str.replace(reg, <span class="function">(<span class="params">content, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  res.push($<span class="number">1</span>);</span><br><span class="line">  max = i;</span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`出现次数最多的字符：<span class="subst">$&#123;res&#125;</span>，出现了<span class="subst">$&#123;max&#125;</span>次`</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="获取URL中的传参信息（可能也包含HASH值）"><a href="#获取URL中的传参信息（可能也包含HASH值）" class="headerlink" title="获取URL中的传参信息（可能也包含HASH值）"></a>获取URL中的传参信息（可能也包含HASH值）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.queryURLParams = <span class="function"><span class="keyword">function</span> <span class="title">queryURLParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"> <span class="comment">// 哈希值值的处理</span></span><br><span class="line"> <span class="built_in">this</span>.replace(<span class="regexp">/#([^?=#&amp;]+)/g</span>, <span class="function">(<span class="params">_, group</span>) =&gt;</span> obj[<span class="string">&#x27;HASH&#x27;</span>] = group);</span><br><span class="line"> <span class="comment">// 问号传参信息的处理</span></span><br><span class="line"> <span class="built_in">this</span>.replace(<span class="regexp">/([^?#=&amp;]+)=([^?#=&amp;]+)/g</span>, <span class="function">(<span class="params">_, group1, group2</span>) =&gt;</span> &#123;</span><br><span class="line">  obj[group1] = group2;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;http://www.baidu.cn/?lx=1&amp;from=weixin&amp;name=xxx#video&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = str.queryURLParams();</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="millimeter：实现千分符处理"><a href="#millimeter：实现千分符处理" class="headerlink" title="millimeter：实现千分符处理"></a>millimeter：实现千分符处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.millimeter = <span class="function"><span class="keyword">function</span> <span class="title">millimeter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g</span>, <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2312345638&quot;</span>;</span><br><span class="line">str = str.millimeter();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//=&gt;&quot;2,312,345,638&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正则匹配-g-全局修饰符-lastIndex起作用"><a href="#正则匹配-g-全局修饰符-lastIndex起作用" class="headerlink" title="正则匹配 g 全局修饰符 lastIndex起作用"></a>正则匹配 g 全局修饰符 lastIndex起作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#规则如下</span><br><span class="line"><span class="number">1.</span>初始状态lastIndex为<span class="number">0</span></span><br><span class="line"><span class="number">2.</span>在进行匹配校验的过程中，若成功匹配，那么lastIndex就会等于符合规则的字符串的最后一个下标再+<span class="number">1</span></span><br><span class="line"><span class="number">3.</span>匹配失败，lastIndex会置为<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>如果继续用这个正则去匹配的话，就会从这个lastIndex开始</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 正则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端代码规范</title>
      <link href="2022/09/04/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>2022/09/04/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="一-命名规范"><a href="#一-命名规范" class="headerlink" title="(一)命名规范"></a>(一)命名规范</h3><h4 id="项目命名"><a href="#项目命名" class="headerlink" title="项目命名"></a>项目命名</h4><p>全部采用小写方式， 以中划线分隔。</p><p>正例：<code>mall-management-system</code></p><p>反例：<code>mall_management-system / mallManagementSystem</code></p><h4 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数</p><p>正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code></p><p>反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code></p><p>【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名</p><p>正例： <code>head-search / page-loading / authorized / notice-icon</code></p><p>反例： <code>HeadSearch / PageLoading</code></p><p>【特殊】VUE 的项目中的除 components 组件目录外的所有目录也使用 kebab-case 命名<br>正例： <code>page-one / shopping-car / user-management</code></p><p>反例： <code>ShoppingCar / UserManagement</code></p><a id="more"></a><h4 id="JS、CSS、SCSS、HTML、PNG-文件命名"><a href="#JS、CSS、SCSS、HTML、PNG-文件命名" class="headerlink" title="JS、CSS、SCSS、HTML、PNG 文件命名"></a>JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小驼峰</p><p>例子： <code>renderDom.js</code></p><h4 id="命名严谨性"><a href="#命名严谨性" class="headerlink" title="命名严谨性"></a>命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p><p>正例：<code>henan / luoyang / rmb 等国际通用的名称，可视同英文。</code></p><p>反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p><p><strong>杜绝完全不规范的缩写，避免望文不知义：</strong></p><p>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p><h3 id="二-HTML-规范-（Vue-Template-同样适用）"><a href="#二-HTML-规范-（Vue-Template-同样适用）" class="headerlink" title="(二)HTML 规范 （Vue Template 同样适用）"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><h4 id="HTML-类型"><a href="#HTML-类型" class="headerlink" title="HTML 类型"></a>HTML 类型</h4><p>推荐使用 HTML5 的文档类型申明： .<br>（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p><ul><li>规定字符编码</li><li>IE 兼容模式</li><li>规定字符编码</li><li>doctype 大写</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Page title&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;company-logo.png&quot; alt&#x3D;&quot;Company&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>缩进使用 2 个空格（一个 tab）</p><p>嵌套的节点应该缩进。</p><h4 id="分块注释"><a href="#分块注释" class="headerlink" title="分块注释"></a>分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 英文 中文 start &gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 英文 中文 end &gt;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- header 头部 start --&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">      &lt;a href=<span class="string">&quot;#&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 图片会把a标签给撑开，所以不用设置a标签的大小 --&gt;</span><br><span class="line">        &lt;img src=<span class="string">&quot;images/header.jpg&quot;</span> /&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;!-- header 头部 end --&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签</p><p>正例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;&lt;&#x2F;header&gt;</span><br><span class="line">&lt;footer&gt;&lt;&#x2F;footer&gt;</span><br></pre></td></tr></table></figure><p>反例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>使用双引号(“ “) 而不是单引号(’ ‘) 。</p><p>正例： ``</p><p>反例： ``</p><h3 id="三-CSS-规范"><a href="#三-CSS-规范" class="headerlink" title="(三) CSS 规范"></a>(三) CSS 规范</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul><li>类名使用小写字母，以中划线分隔</li><li>id 采用驼峰式命名</li><li>scss 中的变量、函数、混合、placeholder 采用驼峰式命名</li></ul><p>ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</p><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fw-800 &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.red &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.heavy &#123;</span><br><span class="line">  font-weight: 800;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.important &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>1)css 选择器中避免使用标签名<br>从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。</p><p>2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。</p><p>不推荐:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.content .title &#123;</span><br><span class="line">  font-size: 2rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.content &gt; .title &#123;</span><br><span class="line">  font-size: 2rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尽量使用缩写属性"><a href="#尽量使用缩写属性" class="headerlink" title="尽量使用缩写属性"></a>尽量使用缩写属性</h4><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border-top-style: none;</span><br><span class="line">font-family: palatino, georgia, serif;</span><br><span class="line">font-size: 100%;</span><br><span class="line">line-height: 1.6;</span><br><span class="line">padding-bottom: 2em;</span><br><span class="line">padding-left: 1em;</span><br><span class="line">padding-right: 1em;</span><br><span class="line">padding-top: 0;</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-top: 0;</span><br><span class="line">font: 100%&#x2F;1.6 palatino, georgia, serif;</span><br><span class="line">padding: 0 1em 2em;</span><br></pre></td></tr></table></figure><h4 id="每个选择器及属性独占一行"><a href="#每个选择器及属性独占一行" class="headerlink" title="每个选择器及属性独占一行"></a>每个选择器及属性独占一行</h4><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button&#123;</span><br><span class="line">  width:100px;height:50px;color:#fff;background:#00a0e9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button&#123;</span><br><span class="line">  width:100px;</span><br><span class="line">  height:50px;</span><br><span class="line">  color:#fff;</span><br><span class="line">  background:#00a0e9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="省略0后面的单位"><a href="#省略0后面的单位" class="headerlink" title="省略0后面的单位"></a>省略0后面的单位</h4><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  padding-bottom: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="避免使用ID选择器及全局标签选择器防止污染全局样式"><a href="#避免使用ID选择器及全局标签选择器防止污染全局样式" class="headerlink" title="避免使用ID选择器及全局标签选择器防止污染全局样式"></a>避免使用ID选择器及全局标签选择器防止污染全局样式</h4><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.header&#123;</span><br><span class="line">  padding-bottom: 0px;</span><br><span class="line">  margin: 0em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-LESS-规范"><a href="#四-LESS-规范" class="headerlink" title="(四) LESS 规范"></a>(四) LESS 规范</h3><h4 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h4><h5 id="1-将公共less文件放置在style-less-common文件夹"><a href="#1-将公共less文件放置在style-less-common文件夹" class="headerlink" title="1)将公共less文件放置在style/less/common文件夹"></a>1)将公共less文件放置在style/less/common文件夹</h5><p>例:// color.less,common.less</p><h5 id="2-按以下顺序组织"><a href="#2-按以下顺序组织" class="headerlink" title="2)按以下顺序组织"></a>2)按以下顺序组织</h5><p>1、@import;<br>2、变量声明;<br>3、样式声明;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;mixins&#x2F;size.less&quot;;</span><br><span class="line"></span><br><span class="line">@default-text-color: #333;</span><br><span class="line"></span><br><span class="line">.page &#123;</span><br><span class="line">  width: 960px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="避免嵌套层级过多"><a href="#避免嵌套层级过多" class="headerlink" title="避免嵌套层级过多"></a>避免嵌套层级过多</h4><p>将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估。这可以避免出现过于详实的CSS选择器。<br>避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现</p><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">  .title&#123;</span><br><span class="line">    .name&#123;</span><br><span class="line">       color:#fff</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.main-title&#123;</span><br><span class="line">   .name&#123;</span><br><span class="line">      color:#fff</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-Javascript-规范"><a href="#五-Javascript-规范" class="headerlink" title="(五) Javascript 规范"></a>(五) Javascript 规范</h3><h4 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h4><h5 id="1-采用小写驼峰命名-lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束"><a href="#1-采用小写驼峰命名-lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束" class="headerlink" title="1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束"></a>1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</h5><p>反例： <code>_name / name_ / name$</code></p><h5 id="2-方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式"><a href="#2-方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从驼峰形式" class="headerlink" title="2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式"></a>2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式</h5><p>正例： <code>localValue / getHttpMessage() / inputUserId</code></p><p><strong><strong>其中 method 方法命名必须是 动词 或者 动词+名词 形式\</strong></strong></p><p>正例：<code>saveShopCarData /openShopCarInfoDialog</code></p><p>反例：<code>save / open / show / go</code></p><p><strong><strong>特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）\</strong></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add &#x2F; update &#x2F; delete &#x2F; detail &#x2F; get</span><br></pre></td></tr></table></figure><p><strong>附： 函数方法常用的动词:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">get 获取&#x2F;set 设置,</span><br><span class="line">add 增加&#x2F;remove 删除</span><br><span class="line">create 创建&#x2F;destory 移除</span><br><span class="line">start 启动&#x2F;stop 停止</span><br><span class="line">open 打开&#x2F;close 关闭,</span><br><span class="line">read 读取&#x2F;write 写入</span><br><span class="line">load 载入&#x2F;save 保存,</span><br><span class="line">create 创建&#x2F;destroy 销毁</span><br><span class="line">begin 开始&#x2F;end 结束,</span><br><span class="line">backup 备份&#x2F;restore 恢复</span><br><span class="line">import 导入&#x2F;export 导出,</span><br><span class="line">split 分割&#x2F;merge 合并</span><br><span class="line">inject 注入&#x2F;extract 提取,</span><br><span class="line">attach 附着&#x2F;detach 脱离</span><br><span class="line">bind 绑定&#x2F;separate 分离,</span><br><span class="line">view 查看&#x2F;browse 浏览</span><br><span class="line">edit 编辑&#x2F;modify 修改,</span><br><span class="line">select 选取&#x2F;mark 标记</span><br><span class="line">copy 复制&#x2F;paste 粘贴,</span><br><span class="line">undo 撤销&#x2F;redo 重做</span><br><span class="line">insert 插入&#x2F;delete 移除,</span><br><span class="line">add 加入&#x2F;append 添加</span><br><span class="line">clean 清理&#x2F;clear 清除,</span><br><span class="line">index 索引&#x2F;sort 排序</span><br><span class="line">find 查找&#x2F;search 搜索,</span><br><span class="line">increase 增加&#x2F;decrease 减少</span><br><span class="line">play 播放&#x2F;pause 暂停,</span><br><span class="line">launch 启动&#x2F;run 运行</span><br><span class="line">compile 编译&#x2F;execute 执行,</span><br><span class="line">debug 调试&#x2F;trace 跟踪</span><br><span class="line">observe 观察&#x2F;listen 监听,</span><br><span class="line">build 构建&#x2F;publish 发布</span><br><span class="line">input 输入&#x2F;output 输出,</span><br><span class="line">encode 编码&#x2F;decode 解码</span><br><span class="line">encrypt 加密&#x2F;decrypt 解密,</span><br><span class="line">compress 压缩&#x2F;decompress 解压缩</span><br><span class="line">pack 打包&#x2F;unpack 解包,</span><br><span class="line">parse 解析&#x2F;emit 生成</span><br><span class="line">connect 连接&#x2F;disconnect 断开,</span><br><span class="line">send 发送&#x2F;receive 接收</span><br><span class="line">download 下载&#x2F;upload 上传,</span><br><span class="line">refresh 刷新&#x2F;synchronize 同步</span><br><span class="line">update 更新&#x2F;revert 复原,</span><br><span class="line">lock 锁定&#x2F;unlock 解锁</span><br><span class="line">check out 签出&#x2F;check in 签入,</span><br><span class="line">submit 提交&#x2F;commit 交付</span><br><span class="line">push 推&#x2F;pull 拉,</span><br><span class="line">expand 展开&#x2F;collapse 折叠</span><br><span class="line">begin 起始&#x2F;end 结束,</span><br><span class="line">start 开始&#x2F;finish 完成</span><br><span class="line">enter 进入&#x2F;exit 退出,</span><br><span class="line">abort 放弃&#x2F;quit 离开</span><br><span class="line">obsolete 废弃&#x2F;depreciate 废旧,</span><br><span class="line">collect 收集&#x2F;aggregate 聚集</span><br></pre></td></tr></table></figure><h5 id="3-常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长"><a href="#3-常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长" class="headerlink" title="3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长"></a>3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长</h5><p>正例： <code>MAX_STOCK_COUNT</code></p><p>反例： <code>MAX_COUNT</code></p><h4 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h4><h5 id="1-使用-2-个空格进行缩进"><a href="#1-使用-2-个空格进行缩进" class="headerlink" title="1) 使用 2 个空格进行缩进"></a>1) 使用 2 个空格进行缩进</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (x &lt; y) &#123;</span><br><span class="line">  x +&#x3D; 10;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  x +&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性"><a href="#2-不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性" class="headerlink" title="2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性"></a>2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性</h5><blockquote><p>说明：任何情形，没有必要插入多个空行进行隔开。</p></blockquote><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：</p><p>正例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;foo&#39;;</span><br><span class="line">let testDiv &#x3D; &#39;&lt;div id&#x3D;&quot;test&quot;&gt;&lt;&#x2F;div&gt;&#39;;</span><br></pre></td></tr></table></figure><p>反例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;foo&#39;;</span><br><span class="line">let testDiv &#x3D; &quot;&lt;div id&#x3D;&#39;test&#39;&gt;&lt;&#x2F;div&gt;&quot;;</span><br></pre></td></tr></table></figure><h4 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h4><h5 id="1-使用字面值创建对象"><a href="#1-使用字面值创建对象" class="headerlink" title="1)使用字面值创建对象"></a>1)使用字面值创建对象</h5><p>正例： <code>let user = &#123;&#125;;</code></p><p>反例： <code>let user = new Object();</code></p><h5 id="2-使用字面量来代替对象构造器"><a href="#2-使用字面量来代替对象构造器" class="headerlink" title="2) 使用字面量来代替对象构造器"></a>2) 使用字面量来代替对象构造器</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var user &#x3D; &#123;</span><br><span class="line">  age: 0,</span><br><span class="line">  name: 1,</span><br><span class="line">  city: 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var user &#x3D; new Object();</span><br><span class="line">user.age &#x3D; 0;</span><br><span class="line">user.name &#x3D; 0;</span><br><span class="line">user.city &#x3D; 0;</span><br></pre></td></tr></table></figure><h4 id="使用-ES6-7"><a href="#使用-ES6-7" class="headerlink" title="使用 ES6,7"></a>使用 ES6,7</h4><p>必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p><blockquote><p>必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async ， 解构， let ， for…of 等等</p></blockquote><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) doSomething();</span><br></pre></td></tr></table></figure><h4 id="undefined-判断"><a href="#undefined-判断" class="headerlink" title="undefined 判断"></a>undefined 判断</h4><p>永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof person &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (person &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件判断和循环最多三层"><a href="#条件判断和循环最多三层" class="headerlink" title="条件判断和循环最多三层"></a>条件判断和循环最多三层</h4><p>条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</p><h4 id="this-的转换命名"><a href="#this-的转换命名" class="headerlink" title="this 的转换命名"></a>this 的转换命名</h4><p>对上下文 this 的引用只能使用’self’来命名</p><h4 id="1-5-10-慎用-console-log"><a href="#1-5-10-慎用-console-log" class="headerlink" title="1.5.10 慎用 console.log"></a>1.5.10 慎用 console.log</h4><p>因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</p><h3 id="Vue-编码基础"><a href="#Vue-编码基础" class="headerlink" title="Vue 编码基础"></a>Vue 编码基础</h3><p>vue 项目规范以 Vue 官方规范 （<a href="https://cn.vuejs.org/v2/style-guide/">https://cn.vuejs.org/v2/style-guide/</a>） 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p><blockquote><p>请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</p></blockquote><h4 id="组件规范"><a href="#组件规范" class="headerlink" title="组件规范"></a>组件规范</h4><h5 id="1-组件名为多个单词"><a href="#1-组件名为多个单词" class="headerlink" title="1) 组件名为多个单词"></a>1) 组件名为多个单词</h5><p>组件名应该始终是多个单词组成（大于等于 2），且命名规范为<code>KebabCase</code>格式。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &#39;TodoItem&#39;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Todo&#39;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;todo-item&#39;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-组件文件名为-pascal-case-格式"><a href="#2-组件文件名为-pascal-case-格式" class="headerlink" title="2) 组件文件名为 pascal-case 格式"></a>2) 组件文件名为 pascal-case 格式</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">|- my-component.vue</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">|- myComponent.vue</span><br><span class="line">|- MyComponent.vue</span><br></pre></td></tr></table></figure><h5 id="3-基础组件文件名为-base-开头，使用完整单词而不是缩写"><a href="#3-基础组件文件名为-base-开头，使用完整单词而不是缩写" class="headerlink" title="3) 基础组件文件名为 base 开头，使用完整单词而不是缩写"></a>3) 基础组件文件名为 base 开头，使用完整单词而不是缩写</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">|- base-button.vue</span><br><span class="line">|- base-table.vue</span><br><span class="line">|- base-icon.vue</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">|- MyButton.vue</span><br><span class="line">|- VueTable.vue</span><br><span class="line">|- Icon.vue</span><br></pre></td></tr></table></figure><h5 id="4-和父组件紧密耦合的子组件应该以父组件名作为前缀命名"><a href="#4-和父组件紧密耦合的子组件应该以父组件名作为前缀命名" class="headerlink" title="4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名"></a>4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">|- todo-list.vue</span><br><span class="line">|- todo-list-item.vue</span><br><span class="line">|- todo-list-item-button.vue</span><br><span class="line">|- user-profile-options.vue （完整单词）</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoItem.vue</span><br><span class="line">|- TodoButton.vue</span><br><span class="line">|- UProfOpts.vue （使用了缩写）</span><br></pre></td></tr></table></figure><h5 id="5-在-Template-模版中使用组件，应使用-PascalCase-模式，并且使用自闭合组件"><a href="#5-在-Template-模版中使用组件，应使用-PascalCase-模式，并且使用自闭合组件" class="headerlink" title="5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件"></a>5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span><br><span class="line">&lt;MyComponent &#x2F;&gt;</span><br><span class="line">&lt;Row&gt;&lt;table :column&#x3D;&quot;data&quot;&#x2F;&gt;&lt;&#x2F;Row&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component &#x2F;&gt; &lt;row&gt;&lt;table :column&#x3D;&quot;data&quot;&#x2F;&gt;&lt;&#x2F;row&gt;</span><br></pre></td></tr></table></figure><h5 id="6-组件的-data-必须是一个函数"><a href="#6-组件的-data-必须是一个函数" class="headerlink" title="6) 组件的 data 必须是一个函数"></a>6) 组件的 data 必须是一个函数</h5><p>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;jack&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &#39;jack&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-Prop-定义应该尽量详细"><a href="#7-Prop-定义应该尽量详细" class="headerlink" title="7) Prop 定义应该尽量详细"></a>7) Prop 定义应该尽量详细</h5><ul><li>必须使用 camelCase 驼峰命名</li><li>必须指定类型</li><li>必须加上注释，表明其含义</li><li>必须加上 required 或者 default，两者二选其一</li><li>如果有业务需要，必须加上 validator 验证</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> props: &#123;</span><br><span class="line">  &#x2F;&#x2F; 组件状态，用于控制组件的颜色</span><br><span class="line">   status: &#123;</span><br><span class="line">     type: String,</span><br><span class="line">     required: true,</span><br><span class="line">     validator: function (value) &#123;</span><br><span class="line">       return [</span><br><span class="line">         &#39;succ&#39;,</span><br><span class="line">         &#39;info&#39;,</span><br><span class="line">         &#39;error&#39;</span><br><span class="line">       ].indexOf(value) !&#x3D;&#x3D; -1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">    &#x2F;&#x2F; 用户级别，用于显示皇冠个数</span><br><span class="line">   userLevel：&#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-为组件样式设置作用域"><a href="#8-为组件样式设置作用域" class="headerlink" title="8) 为组件样式设置作用域"></a>8) 为组件样式设置作用域</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class&#x3D;&quot;btn btn-close&quot;&gt;X&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 &#96;scoped&#96; 特性 --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class&#x3D;&quot;btn btn-close&quot;&gt;X&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;!-- 没有使用 &#96;scoped&#96; 特性 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h5 id="9-如果特性元素较多，应该主动换行"><a href="#9-如果特性元素较多，应该主动换行" class="headerlink" title="9) 如果特性元素较多，应该主动换行"></a>9) 如果特性元素较多，应该主动换行</h5><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent foo&#x3D;&quot;a&quot; bar&#x3D;&quot;b&quot; baz&#x3D;&quot;c&quot;</span><br><span class="line">    foo&#x3D;&quot;a&quot; bar&#x3D;&quot;b&quot; baz&#x3D;&quot;c&quot;</span><br><span class="line">    foo&#x3D;&quot;a&quot; bar&#x3D;&quot;b&quot; baz&#x3D;&quot;c&quot;</span><br><span class="line"> &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent foo&#x3D;&quot;a&quot; bar&#x3D;&quot;b&quot; baz&#x3D;&quot;c&quot; foo&#x3D;&quot;a&quot; bar&#x3D;&quot;b&quot; baz&#x3D;&quot;c&quot; foo&#x3D;&quot;a&quot; bar&#x3D;&quot;b&quot; baz&#x3D;&quot;c&quot; foo&#x3D;&quot;a&quot; bar&#x3D;&quot;b&quot; baz&#x3D;&quot;c&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="模板中使用简单的表达式"><a href="#模板中使用简单的表达式" class="headerlink" title="模板中使用简单的表达式"></a>模板中使用简单的表达式</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 复杂表达式已经移入一个计算属性</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedFullName: function () &#123;</span><br><span class="line">    return this.fullName.split(&#39; &#39;).map(function (word) &#123;</span><br><span class="line">      return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">    &#125;).join(&#39; &#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">       &#123;&#123;</span><br><span class="line">          fullName.split(&#39; &#39;).map(function (word) &#123;</span><br><span class="line">             return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">           &#125;).join(&#39; &#39;)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h4 id="指令都使用缩写形式"><a href="#指令都使用缩写形式" class="headerlink" title="指令都使用缩写形式"></a>指令都使用缩写形式</h4><p>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  @input&#x3D;&quot;onInput&quot;</span><br><span class="line">  @focus&#x3D;&quot;onFocus&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-on:input&#x3D;&quot;onInput&quot;</span><br><span class="line">  @focus&#x3D;&quot;onFocus&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="标签顺序保持一致"><a href="#标签顺序保持一致" class="headerlink" title="标签顺序保持一致"></a>标签顺序保持一致</h4><p>单文件组件应该总是让标签顺序保持为 `</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;...&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style&gt;...&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;&#x2F;template&gt;</span><br><span class="line">&lt;style&gt;...&lt;&#x2F;style&gt;</span><br><span class="line">&lt;script&gt;...&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="必须为-v-for-设置键值-key"><a href="#必须为-v-for-设置键值-key" class="headerlink" title="必须为 v-for 设置键值 key"></a>必须为 v-for 设置键值 key</h4><h4 id="v-show-与-v-if-选择"><a href="#v-show-与-v-if-选择" class="headerlink" title="v-show 与 v-if 选择"></a>v-show 与 v-if 选择</h4><p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p><h4 id="script-标签内部结构顺序"><a href="#script-标签内部结构顺序" class="headerlink" title="script 标签内部结构顺序"></a>script 标签内部结构顺序</h4><p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p><h4 id="Vue-Router-规范"><a href="#Vue-Router-规范" class="headerlink" title="Vue Router 规范"></a>Vue Router 规范</h4><h5 id="1-页面跳转数据传递使用路由参数"><a href="#1-页面跳转数据传递使用路由参数" class="headerlink" title="1) 页面跳转数据传递使用路由参数"></a>1) 页面跳转数据传递使用路由参数</h5><p>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let id &#x3D; &#39; 123&#39;;</span><br><span class="line">this.$router.push(&#123; name: &#39;userCenter&#39;, query: &#123; id: id &#125; &#125;);</span><br></pre></td></tr></table></figure><h5 id="2-使用路由懒加载（延迟加载）机制"><a href="#2-使用路由懒加载（延迟加载）机制" class="headerlink" title="2) 使用路由懒加载（延迟加载）机制"></a>2) 使用路由懒加载（延迟加载）机制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#39;&#x2F;uploadAttachment&#39;,</span><br><span class="line">    name: &#39;uploadAttachment&#39;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#39;上传附件&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () &#x3D;&gt; import(&#39;@&#x2F;view&#x2F;components&#x2F;uploadAttachment&#x2F;index.vue&#39;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h5 id="3-router-中的命名规范"><a href="#3-router-中的命名规范" class="headerlink" title="3) router 中的命名规范"></a>3) router 中的命名规范</h5><p>path、childrenPoints 命名规范采用<code>kebab-case</code>命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是<code>kebab-case</code>，这样很方便找到对应的文件）</p><p>name 命名规范采用<code>KebabCase</code>命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态加载</span><br><span class="line">export const reload &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;reload&#39;,</span><br><span class="line">    name: &#39;reload&#39;,</span><br><span class="line">    component: Main,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#39;动态加载&#39;,</span><br><span class="line">      icon: &#39;icon iconfont&#39;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#39;&#x2F;reload&#x2F;smart-reload-list&#39;,</span><br><span class="line">        name: &#39;SmartReloadList&#39;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &#39;SmartReload&#39;,</span><br><span class="line">          childrenPoints: [</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#39;查询&#39;,</span><br><span class="line">              name: &#39;smart-reload-search&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#39;执行reload&#39;,</span><br><span class="line">              name: &#39;smart-reload-update&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: &#39;查看执行结果&#39;,</span><br><span class="line">              name: &#39;smart-reload-result&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: () &#x3D;&gt;</span><br><span class="line">          import(&#39;@&#x2F;views&#x2F;reload&#x2F;smart-reload&#x2F;smart-reload-list.vue&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h5 id="4-router-中的-path-命名规范"><a href="#4-router-中的-path-命名规范" class="headerlink" title="4) router 中的 path 命名规范"></a>4) router 中的 path 命名规范</h5><p>path除了采用<code>kebab-case</code>命名规范以外，必须以 / 开头，即使是children里的path也要以 / 开头。如下示例</p><p>-</p><p>目的：</p><p>经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件<br>*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#39;&#x2F;file&#39;,</span><br><span class="line">    name: &#39;File&#39;,</span><br><span class="line">    component: Main,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#39;文件服务&#39;,</span><br><span class="line">      icon: &#39;ios-cloud-upload&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#39;&#x2F;file&#x2F;file-list&#39;,</span><br><span class="line">        name: &#39;FileList&#39;,</span><br><span class="line">        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;file&#x2F;file-list.vue&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#39;&#x2F;file&#x2F;file-add&#39;,</span><br><span class="line">        name: &#39;FileAdd&#39;,</span><br><span class="line">        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;file&#x2F;file-add.vue&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#39;&#x2F;file&#x2F;file-update&#39;,</span><br><span class="line">        name: &#39;FileUpdate&#39;,</span><br><span class="line">        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;file&#x2F;file-update.vue&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="二-Vue-项目目录规范"><a href="#二-Vue-项目目录规范" class="headerlink" title="(二) Vue 项目目录规范"></a>(二) Vue 项目目录规范</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>vue 项目中的所有命名一定要与后端命名统一。</p><p>比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</p><h4 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h4><p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">src                               源码目录</span><br><span class="line">|-- api                              所有api接口</span><br><span class="line">|-- assets                           静态资源，images, icons, styles等</span><br><span class="line">|-- components                       公用组件</span><br><span class="line">|-- config                           配置信息</span><br><span class="line">|-- constants                        常量信息，项目所有Enum, 全局常量等</span><br><span class="line">|-- directives                       自定义指令</span><br><span class="line">|-- filters                          过滤器，全局工具</span><br><span class="line">|-- datas                            模拟数据，临时存放</span><br><span class="line">|-- lib                              外部引用的插件存放及修改文件</span><br><span class="line">|-- mock                             模拟接口，临时存放</span><br><span class="line">|-- plugins                          插件，全局使用</span><br><span class="line">|-- router                           路由，统一管理</span><br><span class="line">|-- store                            vuex, 统一管理</span><br><span class="line">|-- themes                           自定义样式主题</span><br><span class="line">|-- views                            视图目录</span><br><span class="line">|   |-- role                             role模块名</span><br><span class="line">|   |-- |-- RoleList.vue                    role列表页面</span><br><span class="line">|   |-- |-- RoleAdd.vue                     role新建页面</span><br><span class="line">|   |-- |-- RoleUpdate.vue                  role更新页面</span><br><span class="line">|   |-- |-- index.less                      role模块样式</span><br><span class="line">|   |-- |-- components                      role模块通用组件文件夹</span><br><span class="line">|   |-- employee                         employee模块</span><br></pre></td></tr></table></figure><h4 id="注释说明"><a href="#注释说明" class="headerlink" title="注释说明"></a>注释说明</h4><p>整理必须加注释的地方</p><ul><li>公共组件使用说明</li><li>api 目录的接口 js 文件必须加注释</li><li>store 中的 state, mutation, action 等必须加注释</li><li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li><li>vue 文件的 methods，每个 method 必须添加注释</li><li>vue 文件的 data, 非常见单词要加注释</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="1-尽量不要手动操作-DOM"><a href="#1-尽量不要手动操作-DOM" class="headerlink" title="1) 尽量不要手动操作 DOM"></a>1) 尽量不要手动操作 DOM</h5><p>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</p><h5 id="2-删除无用代码"><a href="#2-删除无用代码" class="headerlink" title="2) 删除无用代码"></a>2) 删除无用代码</h5><p>因使用了 git/svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web worker</title>
      <link href="2022/08/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/worker/"/>
      <url>2022/08/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/worker/</url>
      
        <content type="html"><![CDATA[<h2 id="web-worker分类两类"><a href="#web-worker分类两类" class="headerlink" title="web worker分类两类"></a>web worker分类两类</h2><ul><li>专用worker（Dedicated Worker）<br>默认创建的就是专用worker，专用worker是只能和构造的进行通信，worker中的全局作用域为DedicatedWorkerGlobalScope</li><li>共享worker（Shared Worker）<br>创建共享worker，共享worker可以为不同的浏览器上下文提供服务，可以是不同的窗口、iframe或者是worker，各个创建者共享worker的实例，全局作用域为SharedWorkerGlobalScope</li><li>Service Worker<br>service worker是用来充当浏览器和网络之间的代理，提供更好的离线体验</li></ul><p><a href="https://lavas-project.github.io/pwa-book/chapter01.html">PWA-Progressive Web Apps</a></p><a id="more"></a><h2 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h2><p><img src="/2022/08/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/worker/service_worker.png" alt="service worker"></p><p><a href="https://blog.csdn.net/Donspeng/article/details/83684874">前端中的Web Worker详解</a><br><a href="https://zhuanlan.zhihu.com/p/79484282">Web Worker</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web worker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js设计模式</title>
      <link href="2022/08/02/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2022/08/02/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="五大设计原则-S-O-L-I-D"><a href="#五大设计原则-S-O-L-I-D" class="headerlink" title="五大设计原则 S O L I D"></a>五大设计原则 S O L I D</h2><ul><li><code>S 单一职责原则</code></li><li><code>O 开放封闭原则</code></li><li>L 里氏置换原则</li><li><code>I 接口独立原则</code></li><li>D 依赖倒置原则<a id="more"></a><blockquote class="pullquote mindmap mindmap-lg"><ul><li>设计模式<ul><li>创建型<ul><li>工厂模式（工厂方法 抽象工厂 建造者模式）</li><li>单例模式</li><li>原型模式</li></ul></li><li>结构型<ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul></li><li>行为型<ul><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代器模式</li><li>职责链模式</li><li>命令模式</li><li>备忘录</li><li>中介者</li><li>状态模式</li><li>解释器模式</li><li>访问者模式</li></ul></li></ul></li></ul></blockquote></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> js设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git提交规范</title>
      <link href="2022/08/02/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
      <url>2022/08/02/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><table><thead><tr><th align="center">类型</th><th align="center">emji</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">feat</td><td align="center">✨</td><td align="center">引入新功能</td></tr><tr><td align="center">fix</td><td align="center">🐛</td><td align="center">修复 bug</td></tr><tr><td align="center">style</td><td align="center">💄</td><td align="center">更新 UI 样式文按键</td></tr><tr><td align="center">format</td><td align="center">🥚</td><td align="center">格式化代码</td></tr><tr><td align="center">docs</td><td align="center">📝</td><td align="center">添加/更新文档</td></tr><tr><td align="center">perf</td><td align="center">👌</td><td align="center">提高性能/优化</td></tr><tr><td align="center">init</td><td align="center">🎉</td><td align="center">初次提交/初始化项目</td></tr><tr><td align="center">test</td><td align="center">✅</td><td align="center">增加测试代码</td></tr><tr><td align="center">refactor</td><td align="center">🎨</td><td align="center">改进代码结构/代码格式</td></tr><tr><td align="center">patch</td><td align="center">🚑</td><td align="center">添加重要补丁</td></tr><tr><td align="center">file</td><td align="center">📦</td><td align="center">添加新文件</td></tr><tr><td align="center">publish</td><td align="center">🚀</td><td align="center">发布新版本</td></tr><tr><td align="center">tag</td><td align="center">📌</td><td align="center">发布新版本</td></tr><tr><td align="center">config</td><td align="center">🔧</td><td align="center">修改配置文件</td></tr><tr><td align="center">git</td><td align="center">🙈</td><td align="center">添加或修改.gitignore 文件</td></tr></tbody></table><h2 id="git-commit-lint-vscode"><a href="#git-commit-lint-vscode" class="headerlink" title="git-commit-lint-vscode"></a>git-commit-lint-vscode</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> git提交规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git提交规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode快捷键</title>
      <link href="2022/07/27/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2022/07/27/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑器与窗口管理"><a href="#编辑器与窗口管理" class="headerlink" title="编辑器与窗口管理"></a>编辑器与窗口管理</h2><ul><li>Ctrl+N： 新建文件</li><li>Ctrl+Shift+N：打开一个新的VSCode编辑器</li><li>Ctrl+O：打开文件</li><li>Ctrl+Shift+O：打开文件夹</li><li>Ctrl+W：关闭当前文件</li><li>Ctrl+Shift+W 或 Alt+F4：关闭当前VSCode编辑器</li><li>Ctrl+\：新建窗口显示代码（相当于复制当前代码到一个新的窗口；同一引用，修改一个文件，其他相同文件会一起改变）</li><li>Ctrl+Alt+→：移动当前文件到右窗口，若没有右窗口，则创建一个新窗口</li><li>Ctrl+Alt+←：移动当前文件到左窗口</li><li>Ctrl+Tab：切换文件窗口</li><li>Ctrl+B：显示/隐藏侧边栏</li><li>Ctrl+`：显示/隐藏控制面板（Terminal）（反引号位置：英文输入法状态下，键盘ESC按键下面的按键）</li><li>Ctrl +/- ：放大/缩小编辑器窗口</li><li>F11：全屏显示</li><li>Ctrl+Shift+E：文件资源管理器（Explorer）</li><li>Ctrl+Shift+G：git管理窗口（Source Control）</li><li>Ctrl+Shift+X：扩展（插件）管理窗口（Extentions）</li></ul><a id="more"></a><h2 id="代码查找替换与格式调整"><a href="#代码查找替换与格式调整" class="headerlink" title="代码查找替换与格式调整"></a>代码查找替换与格式调整</h2><ul><li>Ctrl+F：查找</li><li>Ctrl+H：查找替换</li><li>Ctrl+Shift+F：全局查找</li><li>Ctrl+Shift+H：全局查找替换</li><li>Ctrl+D：选中下一个匹配项</li><li>Ctrl+Shift+L：选中所有匹配项（秀儿）</li><li>Ctrl+[ ：向左缩进</li><li>Ctrl+] ：向右缩进</li><li>Alt+Up：向上移动当前行</li><li>Alt+Down：向下移动当前行</li><li>Shift+Alt+Up：向上复制当前行</li><li>Shift+Alt+Down：向下复制当前行</li><li>Ctrl+Enter：在当前行下方插入空行（光标位置可以不在行尾）</li><li>Ctrl+Shift+Enter：在当前行上方插入空行（光标位置可以不在行尾）</li><li>Alt+Z：切换内容是否自动换行（底部显示/隐藏滚动条</li></ul><h2 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h2><ul><li>Home：光标移动到行首</li><li>End：光标移动到行尾</li><li>Ctrl+Home：光标移动到文件开头（左上）</li><li>Ctrl+End：光标移动到文件结尾（右下）</li><li>Shift+Home：选择从光标到行首的内容</li><li>Shift+End：选择从光标到行尾的内容</li><li>Shift+Alt+Right：扩大选中范围</li><li>Shift+Alt+Left：缩小选中范围</li><li>Alt+Shift+鼠标左键：同时选中编辑多行多列代码（秀儿）</li><li>Ctrl+Alt+Up：向上复制光标</li><li>Ctrl+Alt+Down：向下复制光标</li><li>Ctrl+U：回退到上一个光标处</li><li>F12：转到定义处</li><li>Alt+F12：查看定义处缩略图</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> vscode快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思想</title>
      <link href="2022/07/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>2022/07/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li><p>二分</p></li><li><p>双指针 （快慢指针 头尾指针） 1.链表 数组</p></li><li><p>递归 回溯 （画递归树）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backTrack</span>(<span class="params">数据， 路径缓存</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (下一个值)</span><br><span class="line"> 标记</span><br><span class="line"> backTrack</span><br><span class="line"> 取消标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态规划 找最优解</p></li><li><p>贪心</p></li><li><p>bfs(宽度优先) dfs(回溯 广度优先)</p></li></ul><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>链表</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">遍历;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">  head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">// 哨兵节点-中间节点</span></span><br><span class="line"><span class="keyword">let</span> dummny = &#123;</span><br><span class="line">  next: head,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummny.next;</span><br></pre></td></tr></table></figure><ul><li>数组</li><li>树结构</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(二叉树)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">treeNode</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"> 终止条件 treeNode</span><br><span class="line"> walk(treeNode.left);</span><br><span class="line"> walk(treeNode.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> walk(treeNode.left);</span><br><span class="line"> 终止条件 treeNode</span><br><span class="line"> walk(treeNode.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> walk(treeNode.left);</span><br><span class="line"> walk(treeNode.right)</span><br><span class="line"> 终止条件 treeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>栈是一个线性结构，在计算机中是一个相当常见的数据结构。</p><p>栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.getCount() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getCount() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>选取了 <a href="https://leetcode.com/problems/valid-parentheses/submissions/1">LeetCode 上序号为 20 的题目</a></p><p>题意是匹配括号，可以通过栈的特性来完成这道题目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">&#x27;(&#x27;</span>: -<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;)&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;[&#x27;</span>: -<span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;]&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span>: -<span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.pop()</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637cba2a6155793?w=640&h=419&f=png&s=15737"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>这里会讲解两种实现队列的方式，分别是单链队列和循环队列。</p><h4 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enQueue</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">deQueue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHeader</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getLength() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="built_in">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="built_in">this</span>.last = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当前队列大小</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enQueue</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断队尾 + 1 是否为队头</span></span><br><span class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></span><br><span class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.first === (<span class="built_in">this</span>.last + <span class="number">1</span>) % <span class="built_in">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getLength() * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.queue[<span class="built_in">this</span>.last] = item</span><br><span class="line">    <span class="built_in">this</span>.size++</span><br><span class="line">    <span class="built_in">this</span>.last = (<span class="built_in">this</span>.last + <span class="number">1</span>) % <span class="built_in">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">deQueue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="built_in">this</span>.queue[<span class="built_in">this</span>.first]</span><br><span class="line">    <span class="built_in">this</span>.queue[<span class="built_in">this</span>.first] = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.first = (<span class="built_in">this</span>.first + <span class="number">1</span>) % <span class="built_in">this</span>.queue.length</span><br><span class="line">    <span class="built_in">this</span>.size--</span><br><span class="line">    <span class="comment">// 判断当前队列大小是否过小</span></span><br><span class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></span><br><span class="line">    <span class="comment">// 且不为 2 时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.size === <span class="built_in">this</span>.getLength() / <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.getLength() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getLength() / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHeader</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;Queue is empty&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue[<span class="built_in">this</span>.first]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLength</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.length - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.first === <span class="built_in">this</span>.last</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">resize</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="built_in">this</span>.queue[(i + <span class="built_in">this</span>.first) % <span class="built_in">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.queue = q</span><br><span class="line">    <span class="built_in">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.last = <span class="built_in">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/16388487759b1152?w=1060&h=178&f=png&s=20820"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><strong>单向链表</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">v, next</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = v</span><br><span class="line">    <span class="built_in">this</span>.next = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="built_in">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">header, index, currentIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addNode</span>(<span class="params">v, index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkIndex(index)</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空</span></span><br><span class="line">    <span class="comment">// 其他情况时，因为要插入节点，所以插入的节点</span></span><br><span class="line">    <span class="comment">// 的 next 应该是 prev.next</span></span><br><span class="line">    <span class="comment">// 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">this</span>.find(<span class="built_in">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next)</span><br><span class="line">    <span class="built_in">this</span>.size++</span><br><span class="line">    <span class="keyword">return</span> prev.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insertNode</span>(<span class="params">v, index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.addNode(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addToFirst</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.addNode(v, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addToLast</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.addNode(v, <span class="built_in">this</span>.size)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeNode</span>(<span class="params">index, isLast</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkIndex(index)</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">this</span>.find(<span class="built_in">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> node = prev.next</span><br><span class="line">    prev.next = node.next</span><br><span class="line">    node.next = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.size--</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeFirstNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeNode(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeLastNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeNode(<span class="built_in">this</span>.size, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">checkIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;Index error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getNode</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkIndex(index)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.find(<span class="built_in">this</span>.dummyNode, index, <span class="number">0</span>).next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p><p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d?w=320&h=267&f=png&s=11622"></p><h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</p><p>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208?w=596&h=485&f=png&s=36796"></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addNode</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>._addChild(<span class="built_in">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  <span class="function"><span class="title">_addChild</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="built_in">this</span>.size++</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p><p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line"><span class="function"><span class="title">preTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._pre(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_pre</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="built_in">this</span>._pre(node.left)</span><br><span class="line">    <span class="built_in">this</span>._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于 BST 来说，中序遍历可以实现一次遍历就</span></span><br><span class="line"><span class="comment">// 得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line"><span class="function"><span class="title">midTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._mid(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_mid</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">this</span>._mid(node.left)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="built_in">this</span>._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点</span></span><br><span class="line"><span class="comment">// 再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line"><span class="function"><span class="title">backTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>._back(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_back</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">this</span>._back(node.left)</span><br><span class="line">    <span class="built_in">this</span>._back(node.right)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">breadthTraversal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.enQueue(<span class="built_in">this</span>.root)</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></span><br><span class="line">  <span class="comment">// 代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.deQueue()</span><br><span class="line">    <span class="built_in">console</span>.log(n.value)</span><br><span class="line">    <span class="keyword">if</span> (n.left) q.enQueue(n.left)</span><br><span class="line">    <span class="keyword">if</span> (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getMin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMin(<span class="built_in">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_getMin</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getMax</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMax(<span class="built_in">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_getMax</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>向上取整和向下取整</strong>，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">floor</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>._floor(<span class="built_in">this</span>.root, v)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_floor</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (node.value === v) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="built_in">this</span>._floor(node.right, v)</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="keyword">return</span> right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排名</strong>，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 <code>size</code> 属性。该属性表示该节点下有多少子节点（包含自身）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line"><span class="function"><span class="title">_getSize</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_addChild</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.left = <span class="built_in">this</span>._addChild(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.right = <span class="built_in">this</span>._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">select</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>._select(<span class="built_in">this</span>.root, k)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_select</span>(<span class="params">node, k</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.left ? node.left.size : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 判断 size 是否大于 k</span></span><br><span class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="built_in">this</span>._select(node.left, k)</span><br><span class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="built_in">this</span>._select(node.right, k - size - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p><ul><li>需要删除的节点没有子树</li><li>需要删除的节点只有一条子树</li><li>需要删除的节点有左右两条树</li></ul><p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delectMin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.root = <span class="built_in">this</span>._delectMin(<span class="built_in">this</span>.root)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_delectMin</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp; !node.left) <span class="keyword">return</span> node.right</span><br><span class="line">  node.left = <span class="built_in">this</span>._delectMin(node.left)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.size = <span class="built_in">this</span>._getSize(node.left) + <span class="built_in">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。</p><p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p><p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delect</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.root = <span class="built_in">this</span>._delect(<span class="built_in">this</span>.root, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">_delect</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    node.right = <span class="built_in">this</span>._delect(node.right, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.left = <span class="built_in">this</span>._delect(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node.right</span><br><span class="line">    <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">this</span>._getMin(node.right)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.right = <span class="built_in">this</span>._delectMin(node.right)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.left = node.left</span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.size = <span class="built_in">this</span>._getSize(node.left) + <span class="built_in">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。</p><p>AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>因为 AVL 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。</p><p>对于 AVL 树来说，添加节点会有四种情况</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642cc145a0cfb26?w=800&h=566&f=png&s=73573"></p><p>对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。</p><p>旋转之前：new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A，右旋之后节点 3 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。</p><p>对于右右情况来说，相反于左左情况，所以不再赘述。</p><p>对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来达到目的。</p><p>首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addNode</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="built_in">this</span>._addChild(<span class="built_in">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_addChild</span>(<span class="params">node, v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v</span><br><span class="line">    &#125;</span><br><span class="line">    node.height =</span><br><span class="line">      <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(node.left), <span class="built_in">this</span>._getHeight(node.right))</span><br><span class="line">    <span class="keyword">let</span> factor = <span class="built_in">this</span>._getBalanceFactor(node)</span><br><span class="line">    <span class="comment">// 当需要右旋时，根节点的左树一定比右树高度高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当需要左旋时，根节点的左树一定比右树高度矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; -<span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.left = <span class="built_in">this</span>._leftRotate(node.left)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; -<span class="number">1</span> &amp;&amp; <span class="built_in">this</span>._getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.right = <span class="built_in">this</span>._rightRotate(node.right)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_getHeight</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> node.height</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_getBalanceFactor</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._getHeight(node.left) - <span class="built_in">this</span>._getHeight(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点右旋</span></span><br><span class="line">  <span class="comment">//           5                    2</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       1      5</span></span><br><span class="line">  <span class="comment">//       /  \               /       /  \</span></span><br><span class="line">  <span class="comment">//      1    3             new     3    6</span></span><br><span class="line">  <span class="comment">//     /</span></span><br><span class="line">  <span class="comment">//    new</span></span><br><span class="line">  <span class="function"><span class="title">_rightRotate</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.left</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.right</span><br><span class="line">    <span class="comment">// 节点 2 的右节点改为节点 5</span></span><br><span class="line">    newRoot.right = node</span><br><span class="line">    <span class="comment">// 节点 5 左节点改为节点 3</span></span><br><span class="line">    node.left = moveNode</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height =</span><br><span class="line">      <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(node.left), <span class="built_in">this</span>._getHeight(node.right))</span><br><span class="line">    newRoot.height =</span><br><span class="line">      <span class="number">1</span> +</span><br><span class="line">      <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(newRoot.left), <span class="built_in">this</span>._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点左旋</span></span><br><span class="line">  <span class="comment">//           4                    6</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       4      7</span></span><br><span class="line">  <span class="comment">//             /  \         /   \      \</span></span><br><span class="line">  <span class="comment">//            5     7      2     5      new</span></span><br><span class="line">  <span class="comment">//                   \</span></span><br><span class="line">  <span class="comment">//                    new</span></span><br><span class="line">  <span class="function"><span class="title">_leftRotate</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.right</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.left</span><br><span class="line">    <span class="comment">// 节点 6 的左节点改为节点 4</span></span><br><span class="line">    newRoot.left = node</span><br><span class="line">    <span class="comment">// 节点 4 右节点改为节点 5</span></span><br><span class="line">    node.right = moveNode</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height =</span><br><span class="line">      <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(node.left), <span class="built_in">this</span>._getHeight(node.right))</span><br><span class="line">    newRoot.height =</span><br><span class="line">      <span class="number">1</span> +</span><br><span class="line">      <span class="built_in">Math</span>.max(<span class="built_in">this</span>._getHeight(newRoot.left), <span class="built_in">this</span>._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>在计算机科学，<strong>trie</strong>，又称<strong>前缀树</strong>或<strong>字典树</strong>，是一种有序树，用于保存关联数组，其中的键通常是字符串。</p><p>简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点</p><ul><li>根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条） 条链接，每条链接代表一个字符</li><li>节点不存储字符，只有路径才存储，这点和其他的树结构不同</li><li>从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/9/163e1d2f6cec3348?w=640&h=600&f=png&s=48344">、</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>总得来说 Trie 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 代表每个字符经过节点的次数</span></span><br><span class="line">    <span class="built_in">this</span>.path = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 代表到该节点的字符串有几个</span></span><br><span class="line">    <span class="built_in">this</span>.end = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根节点，代表空字符</span></span><br><span class="line">    <span class="built_in">this</span>.root = <span class="keyword">new</span> TrieNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入字符串</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 获得字符先对应的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">&#x27;a&#x27;</span>.charCodeAt()</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，就创建</span></span><br><span class="line">      <span class="keyword">if</span> (!node.next[index]) &#123;</span><br><span class="line">        node.next[index] = <span class="keyword">new</span> TrieNode()</span><br><span class="line">      &#125;</span><br><span class="line">      node.path += <span class="number">1</span></span><br><span class="line">      node = node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索字符串出现的次数</span></span><br><span class="line">  <span class="function"><span class="title">search</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">&#x27;a&#x27;</span>.charCodeAt()</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，代表没有需要搜素的字符串</span></span><br><span class="line">      <span class="keyword">if</span> (!node.next[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.end</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除字符串</span></span><br><span class="line">  <span class="function"><span class="title">delete</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.search(str)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">&#x27;a&#x27;</span>.charCodeAt()</span><br><span class="line">      <span class="comment">// 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串</span></span><br><span class="line">      <span class="comment">// 已经一个，直接删除即可</span></span><br><span class="line">      <span class="keyword">if</span> (--node.next[index].path == <span class="number">0</span>) &#123;</span><br><span class="line">        node.next[index] = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end -= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。</p><p>这个结构中有两个重要的操作，分别是：</p><ul><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/9/163e45b56fd25172?w=421&h=209&f=png&s=26545"></p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSet</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化样本</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化时，每个节点的父节点都是自己</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="built_in">Array</span>(count)</span><br><span class="line">    <span class="comment">// 用于记录树的深度，优化搜索复杂度</span></span><br><span class="line">    <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="built_in">Array</span>(count)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      <span class="built_in">this</span>.parent[i] = i</span><br><span class="line">      <span class="built_in">this</span>.rank[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">p</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找当前节点的父节点是否为自己，不是的话表示还没找到</span></span><br><span class="line">    <span class="comment">// 开始进行路径压缩优化</span></span><br><span class="line">    <span class="comment">// 假设当前节点父节点为 A</span></span><br><span class="line">    <span class="comment">// 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="built_in">this</span>.parent[p]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.parent[p] = <span class="built_in">this</span>.parent[<span class="built_in">this</span>.parent[p]]</span><br><span class="line">      p = <span class="built_in">this</span>.parent[p]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isConnected</span>(<span class="params">p, q</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.find(p) === <span class="built_in">this</span>.find(q)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并</span></span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">p, q</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到两个数字的父节点</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">this</span>.find(p)</span><br><span class="line">    <span class="keyword">let</span> j = <span class="built_in">this</span>.find(q)</span><br><span class="line">    <span class="keyword">if</span> (i === j) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 判断两棵树的深度，深度小的加到深度大的树下面</span></span><br><span class="line">    <span class="comment">// 如果两棵树深度相等，那就无所谓怎么加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rank[i] &lt; <span class="built_in">this</span>.rank[j]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.parent[i] = j</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.rank[i] &gt; <span class="built_in">this</span>.rank[j]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.parent[j] = i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.parent[i] = j</span><br><span class="line">      <span class="built_in">this</span>.rank[j] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>堆通常是一个可以被看做一棵树的数组对象。</p><p>堆的实现通过构造<strong>二叉堆</strong>，实为二叉树的一种。这种数据结构具有以下性质。</p><ul><li>任意节点小于（或大于）它的所有子节点</li><li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。</li></ul><p>将根节点最大的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点最小的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。</p><p>优先队列也完全可以用堆来实现，操作是一模一样的。</p><h3 id="实现大根堆"><a href="#实现大根堆" class="headerlink" title="实现大根堆"></a>实现大根堆</h3><p>堆的每个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code>。</p><p>堆有两个核心的操作，分别是 <code>shiftUp</code> 和 <code>shiftDown</code> 。前者用于添加元素，后者用于删除根节点。</p><p><code>shiftUp</code> 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。</p><p><code>shiftDown</code> 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/15/164009e58a5a21f8?w=537&h=394&f=png&s=77222"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heap = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.heap.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">empty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size() == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heap.push(item)</span><br><span class="line">    <span class="built_in">this</span>._shiftUp(<span class="built_in">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeMax</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._shiftDown(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getParentIndex</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((k - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLeftIndex</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> k * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_shiftUp</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.heap[k] &gt; <span class="built_in">this</span>.heap[<span class="built_in">this</span>.getParentIndex(k)]) &#123;</span><br><span class="line">      <span class="built_in">this</span>._swap(k, <span class="built_in">this</span>.getParentIndex(k))</span><br><span class="line">      <span class="comment">// 将索引变成父节点</span></span><br><span class="line">      k = <span class="built_in">this</span>.getParentIndex(k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_shiftDown</span>(<span class="params">k</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 交换首位并删除末尾</span></span><br><span class="line">    <span class="built_in">this</span>._swap(k, <span class="built_in">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">this</span>.heap.splice(<span class="built_in">this</span>.size() - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.getLeftIndex(k) &lt; <span class="built_in">this</span>.size()) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = <span class="built_in">this</span>.getLeftIndex(k)</span><br><span class="line">      <span class="comment">// 判断是否有右孩子，并且右孩子是否大于左孩子</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; <span class="built_in">this</span>.size() &amp;&amp; <span class="built_in">this</span>.heap[j + <span class="number">1</span>] &gt; <span class="built_in">this</span>.heap[j]) j++</span><br><span class="line">      <span class="comment">// 判断父节点是否已经比子节点都大</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.heap[k] &gt;= <span class="built_in">this</span>.heap[j]) <span class="keyword">break</span></span><br><span class="line">      <span class="built_in">this</span>._swap(k, j)</span><br><span class="line">      k = j</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_swap</span>(<span class="params">left, right</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rightValue = <span class="built_in">this</span>.heap[right]</span><br><span class="line">    <span class="built_in">this</span>.heap[right] = <span class="built_in">this</span>.heap[left]</span><br><span class="line">    <span class="built_in">this</span>.heap[left] = rightValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p><a href="https://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96">尾调用</a><br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p><blockquote class="pullquote mindmap mindmap-lg"><ul><li>数据结构<ul><li>树与二叉树<ul><li>二叉树<ul><li>完全二叉树</li><li>满二叉树</li><li>二叉搜索树</li><li>平衡二叉搜索树<ul><li>红黑树</li></ul></li><li>特点<ul><li>遍历方式<ul><li>广度优先</li><li>深度优先<ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li></ul></li><li>顺序和链式</li></ul></li></ul></li><li>哈夫曼叔</li><li>字典树</li></ul></li><li>排序<ul><li>O(n^2)<ul><li>冒泡</li><li>插入</li><li>选择</li></ul></li><li>O(nlog(n))<ul><li>快速排序</li><li>归并排序</li></ul></li><li>O(n)<ul><li>桶排序</li><li>基数排序</li><li>计数排序</li></ul></li></ul></li><li>受限线性表<ul><li>栈<ul><li>顺序和链式都可以实现 先进后出</li><li>实际应用<ul><li>浏览器的前进和后退</li><li>括号匹配</li><li>表达式计算</li></ul></li></ul></li><li>堆<ul><li>大顶堆</li><li>小顶堆</li></ul></li><li>队列<ul><li>普通队列 顺序和链式都可以实现 先进后出</li><li>双边队列 入口和出口都可以进队和出队</li><li>优先级队列 根据优先级来出队</li><li>实际应用 LRU cache</li></ul></li></ul></li><li>非受限线性表<ul><li>顺序结构<ul><li>数组<ul><li>支持 O(1) 的随机访问</li><li>平均为 O(n) 的插入和删除</li><li>警惕越界错误，导致 Stack Over Flow</li></ul></li></ul></li><li>链式结构<ul><li>单链表<ul><li>不支持随机访问，需要遍历去访问结点</li><li>插入和删除只需要移动指针，时间复杂度</li><li>每个结点需要额外的空间存储指针，需要的内存比数组大 为 O(1)</li></ul></li><li>双链表<ul><li>在单链表的基础上，除头结点外，每个结点多了一个存放前驱结点内存地址的指针</li></ul></li><li>循环链表<ul><li>尾节点指针指向头结点</li></ul></li><li>静态链表<ul><li>借助数组，伴随指向后继结点的指针</li></ul></li></ul></li></ul></li></ul></li></ul></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 算法思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码中注意问题</title>
      <link href="2022/07/10/%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/"/>
      <url>2022/07/10/%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-keys-的顺序问题"><a href="#Object-keys-的顺序问题" class="headerlink" title="Object.keys()的顺序问题"></a>Object.keys()的顺序问题</h2><ul><li><p>将所有「合法的数组索引」按升序排序</p></li><li><p>将所有「字符串类型索引」按属性创建时间以升序排序</p></li><li><p>将所有 「Symbol 类型索引」按属性创建时间以升序排序</p></li><li><p>「<code>合法数组索引指的是正整数，负数或者浮点数一律当做字符串处理。严格来说对象属性没有数字类型的，无论是数字还是字符串，都会被当做字符串来处理。</code>」</p></li></ul><p><a href="https://blog.csdn.net/qq846294282/article/details/118719889">Object.keys</a><br><a href="https://mp.weixin.qq.com/s/2_yFU6iS9ALOXgM--LyaEA">Object.keys</a></p><h2 id="JSON-stringify-使用数据丢失问题"><a href="#JSON-stringify-使用数据丢失问题" class="headerlink" title="JSON.stringify 使用数据丢失问题"></a>JSON.stringify 使用数据丢失问题</h2><p><a href="https://mp.weixin.qq.com/s/rTuiUtpTB6iOqCNb7yv0zQ">JSON.stringify</a></p><h2 id="if-else-语句里不能用函数声明定义函数"><a href="#if-else-语句里不能用函数声明定义函数" class="headerlink" title="if else 语句里不能用函数声明定义函数"></a>if else 语句里不能用函数声明定义函数</h2><h2 id="js-toFixed四舍五入出现的精度问题"><a href="#js-toFixed四舍五入出现的精度问题" class="headerlink" title="js toFixed四舍五入出现的精度问题"></a>js toFixed四舍五入出现的精度问题</h2><p><a href="https://blog.csdn.net/qq_38128179/article/details/89181805?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-89181805-blog-123878883.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-89181805-blog-123878883.pc_relevant_aa&utm_relevant_index=2">解决JS浮点数运算结果不精确的Bug</a><br> 解决办法的类库 <a href="https://mathjs.org/">Math.js</a> <a href="http://mikemcl.github.io/big.js/">big.js</a> <a href="http://mikemcl.github.io/decimal.js/">decimal.js</a></p><h2 id="forEach中不出现异步代码"><a href="#forEach中不出现异步代码" class="headerlink" title="forEach中不出现异步代码"></a>forEach中不出现异步代码</h2><a id="more"></a><h2 id="箭头函数不是万能的-4中情况禁止使用"><a href="#箭头函数不是万能的-4中情况禁止使用" class="headerlink" title="箭头函数不是万能的,4中情况禁止使用"></a>箭头函数不是万能的,4中情况禁止使用</h2><ul><li>请不要在构造函数中使用箭头函数</li><li>请不要在点击事件中操作this</li><li>请不要在对象的方法中使用箭头函数</li><li>请不要在原型链中使用箭头函数</li></ul><h2 id="vue-组件methods的防抖函数-不能多少次调用该组件，否则要将防抖函数绑定在data-属性上"><a href="#vue-组件methods的防抖函数-不能多少次调用该组件，否则要将防抖函数绑定在data-属性上" class="headerlink" title="vue 组件methods的防抖函数, 不能多少次调用该组件，否则要将防抖函数绑定在data 属性上"></a>vue 组件methods的防抖函数, 不能多少次调用该组件，否则要将防抖函数绑定在data 属性上</h2><h2 id="JavaScript-异步代码的几个推荐做法"><a href="#JavaScript-异步代码的几个推荐做法" class="headerlink" title="JavaScript 异步代码的几个推荐做法"></a>JavaScript 异步代码的几个推荐做法</h2><p> [异步代码的几个推荐做法] <a href="https://mp.weixin.qq.com/s/1Py2vPwjjqw17rn-uBfJ7g">https://mp.weixin.qq.com/s/1Py2vPwjjqw17rn-uBfJ7g</a></p><h2 id="async、await-捕获错误-await-to-js"><a href="#async、await-捕获错误-await-to-js" class="headerlink" title="async、await 捕获错误 (await-to-js)"></a>async、await 捕获错误 (await-to-js)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> to <span class="keyword">from</span> <span class="string">&#x27;await-to-js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> [err, user] = <span class="keyword">await</span> to(UserModel.findById(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;User not found&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/scopsy/await-to-js">await-to-js</a></p><h2 id="代码闭包漏洞问题"><a href="#代码闭包漏洞问题" class="headerlink" title="代码闭包漏洞问题"></a>代码闭包漏洞问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在不修改下面代码的情况下，修改obj的内容</span></span><br><span class="line"><span class="keyword">var</span> o = (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a:<span class="number">1</span>,</span><br><span class="line">        b:<span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get :<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj[n]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>闭包模式。屏蔽掉obj本身。只能访问闭包返回的数据而不能去修改数据源本身，但是他的数据源是一个对象，这就会出现一个漏洞！！！！，而上面的代码就会出现一个致命的漏洞</p><ul><li><p>那我能不能去访问到原型valueOf，暂时说想通过valueOf（）来获取这个对象本身。<br>JavaScript 中的 valueOf() 方法用于返回指定对象的原始值，若对象没有原始值，则将返回对象本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(o.get(<span class="string">&quot;valueOf&quot;</span>));</span><br><span class="line"><span class="comment">//[Function: valueOf]</span></span><br><span class="line"><span class="keyword">let</span> obj2 = o.get(<span class="string">&quot;valueOf&quot;</span>)()</span><br><span class="line"><span class="comment">//TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure><p>可以看的出来，报错，这是因为valueOf函数的this指向发生了错误</p></li><li><p>虽然提供了一个函数进入传参，但是传入的权限很大，就会有很大的问题。<br>有没有一种方法，直接访问对象的属性的时候通过一个函数来获取，这时候就是构造器属性。<br>给对象的原型设置一个访问器属性</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype,<span class="string">&quot;abc&quot;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(o.get(<span class="string">&quot;abc&quot;</span>));<span class="comment">//&#123; a: 1, b: 2 &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = o.get(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">obj.a=<span class="string">&#x27;hjkasd&#x27;</span></span><br><span class="line">obj.b=<span class="string">&#x27;12345&#x27;</span></span><br><span class="line">obj.c=<span class="string">&#x27;勇敢牛牛，不怕困难&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; a: &#x27;hjkasd&#x27;, b: &#x27;12345&#x27;, c: &#x27;勇敢牛牛，不怕困难&#x27; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li><p>判断访问的属性是否来自对象本身。从而返回不同的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">      a:<span class="number">1</span>,</span><br><span class="line">      b:<span class="number">2</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      get :<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="function"><span class="title">if</span>(<span class="params">!obj.hasOwnProperty(n)</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;n&#125;</span>在此对象本身不存在`</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> obj[n]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>直接设置这个对象的原型为null，没有原型链，那我上面的逻辑就行不通，自然就保护了数据的隐私性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;</span><br><span class="line">      a:<span class="number">1</span>,</span><br><span class="line">      b:<span class="number">2</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj,<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      get :<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> obj[n]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="flex-布局均匀分布注意"><a href="#flex-布局均匀分布注意" class="headerlink" title="flex 布局均匀分布注意"></a>flex 布局均匀分布注意</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  .item&#123;</span><br><span class="line">    <span class="selector-tag">flex-grow</span>: 1;</span><br><span class="line">    // flex-basis: 0;不设置该属性时 当元素内有内容会造成不均匀分布</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-Depcheck-去除项目没有用到的依赖"><a href="#用-Depcheck-去除项目没有用到的依赖" class="headerlink" title="用 Depcheck 去除项目没有用到的依赖"></a>用 Depcheck 去除项目没有用到的依赖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g depcheck</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_39111622/article/details/122072187">depcheck</a></p><h2 id="正则匹配-g-全局修饰符-lastIndex起作用"><a href="#正则匹配-g-全局修饰符-lastIndex起作用" class="headerlink" title="正则匹配 g 全局修饰符 lastIndex起作用"></a>正则匹配 g 全局修饰符 lastIndex起作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#规则如下</span><br><span class="line"><span class="number">1.</span>初始状态lastIndex为<span class="number">0</span></span><br><span class="line"><span class="number">2.</span>在进行匹配校验的过程中，若成功匹配，那么lastIndex就会等于符合规则的字符串的最后一个下标再+<span class="number">1</span></span><br><span class="line"><span class="number">3.</span>匹配失败，lastIndex会置为<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>如果继续用这个正则去匹配的话，就会从这个lastIndex开始</span><br></pre></td></tr></table></figure><h2 id="git-大小写问题"><a href="#git-大小写问题" class="headerlink" title="git 大小写问题"></a>git 大小写问题</h2><p>默认情况下，git是会忽略文件名大小写的;<br>执行git config –global core.ignorecase false，全局设置 大小写敏感;<br> <code>多人合作一个文件 通知统一处理</code></p><h2 id="vue2-大数据展示性的-使用Object-freeze-冻结对象达到优化目的"><a href="#vue2-大数据展示性的-使用Object-freeze-冻结对象达到优化目的" class="headerlink" title="vue2 大数据展示性的 使用Object.freeze() 冻结对象达到优化目的"></a>vue2 大数据展示性的 使用Object.freeze() 冻结对象达到优化目的</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 代码中注意问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码中注意问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buffer</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Buffer/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Buffer/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Buffer"><a href="#什么是Buffer" class="headerlink" title="什么是Buffer"></a>什么是Buffer</h2><ul><li>缓冲区Buffer是暂时存放输入输出数据的一段内存。</li><li>JS语言没有二进制数据类型，而在处理TCP和文件流的时候，必须要处理二进制数据。</li><li>NodeJS提供了一个Buffer对象来提供对二进制数据的操作</li><li>是一个表示固定内存分配的全局对象，也就是说要放到缓存区中的字节数需要提前确定</li><li>Buffer好比由一个8位字节元素组成的数组，可以有效的在JavasScript中表示二进制数据</li></ul><h2 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h2><ul><li>字节(Byte)是计算机存储时的一种计量单位，一个字节等于8位二进制数</li><li>一个位就代表一个0或1，每8个位（bit）组成一个字节（Byte）</li><li>字节是通过网络传输信息的基本单位</li><li>一个字节最大值十进制数是255(2**8-1)</li></ul><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul><li><p>0b 2进制</p></li><li><p>0x 16进制</p></li><li><p>0o 8进制</p></li><li><p>将任意进制字符串转换为十进制</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;11&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;77&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;e7&quot;</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure></li><li><p>将10进制转换为其它进制字符串</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>).toString(<span class="number">2</span>)</span><br><span class="line">(<span class="number">17</span>).toString(<span class="number">16</span>)</span><br><span class="line">(<span class="number">33</span>).toString(<span class="number">32</span>)</span><br></pre></td></tr></table></figure><h2 id="定义buffer的三种方式"><a href="#定义buffer的三种方式" class="headerlink" title="定义buffer的三种方式"></a>定义buffer的三种方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.alloc(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.alloc(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf3 = Buffer.allocUnsafe(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf4 = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>正常情况下为0-255之间;</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf5 = Buffer.from(<span class="string">&#x27;珠峰培训&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="buffer常用方法"><a href="#buffer常用方法" class="headerlink" title="buffer常用方法"></a>buffer常用方法</h2><p><code>buf.fill(value[, offset[, end]][, encoding])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.fill(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>buf.write(string[, offset[, length]][, encoding])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.allocUnsafe(<span class="number">6</span>);</span><br><span class="line">buffer.write(<span class="string">&#x27;珠&#x27;</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">buffer.write(<span class="string">&#x27;峰&#x27;</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;utf8&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>通过指定的 <code>offset</code> 将 <code>value</code> 写入到当前 Buffer 中。</li><li>这个 value 应当是一个有效的有符号的8位整数</li></ul><p><code>buf.writeInt8(value, offset[, noAssert])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">4</span>);</span><br><span class="line">buf.writeInt8()</span><br><span class="line">buf.writeInt8(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">buf.writeInt8(<span class="number">16</span>,<span class="number">1</span>);</span><br><span class="line">buf.writeInt8(<span class="number">32</span>,<span class="number">2</span>);</span><br><span class="line">buf.writeInt8(<span class="number">48</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序。</p><ul><li>Big-endian：将高序字节存储在起始地址（高位编址）</li><li>Little-endian：将低序字节存储在起始地址（低位编址）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.alloc(<span class="number">4</span>);</span><br><span class="line">buffer.writeInt16BE(<span class="number">2</span>**<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.readInt16BE(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">buffer.writeInt16LE(<span class="number">2</span>**<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.readInt16LE(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><code>buf.toString([encoding[, start[, end]]])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰架构&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.toString(<span class="string">&#x27;utf8&#x27;</span>,<span class="number">3</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p><code>buf.slice([start[, end]])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰架构&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> subBuffer = buffer.slice(<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subBuffer.toString());</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;StringDecoder&#125;  = <span class="built_in">require</span>(<span class="string">&#x27;string_decoder&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sd = <span class="keyword">new</span> StringDecoder();</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sd.write(buffer.slice(<span class="number">0</span>,<span class="number">4</span>)));</span><br><span class="line"><span class="built_in">console</span>.log(sd.write(buffer.slice(<span class="number">4</span>)));</span><br></pre></td></tr></table></figure><ul><li>复制Buffer 把多个buffer拷贝到一个大buffer上</li></ul><p><code>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰架构&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> subBuffer = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subBuffer.toString());</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Buffer.prototype.copy = <span class="function"><span class="keyword">function</span>(<span class="params">targetBuffer,targetStart,sourceStart,sourceEnd</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=sourceStart;ithis[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> subBuffer = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subBuffer.toString());</span><br></pre></td></tr></table></figure><p><code>Buffer.concat(list[, totalLength])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">&#x27;珠&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">&#x27;峰&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.concat([buffer1,buffer2]);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.toString());</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat = <span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> totalLength = list.reduce(<span class="function">(<span class="params">len, item</span>) =&gt;</span> len + item.length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (list.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> newBuffer = Buffer.alloc(totalLength);</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> buffer <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> byte <span class="keyword">of</span> buffer) &#123;</span><br><span class="line">            newBuffer[pos++] = byte;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newBuffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">&#x27;珠&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">&#x27;峰&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.concat([buffer1, buffer2]);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.toString());</span><br></pre></td></tr></table></figure><ul><li>判断是否是buffer</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.isBuffer();</span><br></pre></td></tr></table></figure><ul><li>获取字节长度(显示是字符串所代表buffer的长度)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;珠峰&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(str);</span><br><span class="line"><span class="built_in">console</span>.log(Buffer.byteLength(buffer));</span><br></pre></td></tr></table></figure><h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><ul><li>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一</li><li>Base64就是一种基于64个可打印字符来表示二进制数据的方法</li><li>Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3 _8 = 4_6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CHARTS = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> buf = Buffer.from(str);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> b <span class="keyword">of</span> buf</span>)</span>&#123;</span><br><span class="line">      result += b.toString(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.match(<span class="regexp">/(\d&#123;6&#125;)/g</span>).map(<span class="function"><span class="params">val</span>=&gt;</span><span class="built_in">parseInt</span>(val,<span class="number">2</span>)).map(<span class="function"><span class="params">val</span>=&gt;</span>CHARTS[val]).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = transfer(<span class="string">&#x27;珠&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encoding</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Encoding/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Encoding/</url>
      
        <content type="html"><![CDATA[<h2 id="字符发展历史"><a href="#字符发展历史" class="headerlink" title="字符发展历史 #"></a>字符发展历史 <a href="#t01-%E5%AD%97%E7%AC%A6%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">#</a></h2><h3 id="字节"><a href="#字节" class="headerlink" title="字节 #"></a>字节 <a href="#t111-%E5%AD%97%E8%8A%82">#</a></h3><ul><li>计算机内部，所有信息最终都是一个二进制值</li><li>每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)<br><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Encoding/bits.jpg"></li></ul><h3 id="单位"><a href="#单位" class="headerlink" title="单位 #"></a>单位 <a href="#t212-%E5%8D%95%E4%BD%8D">#</a></h3><ul><li>8位 = 1字节</li><li>1024字节 = 1K</li><li>1024K = 1M</li><li>1024M = 1G</li><li>1024G = 1T<a id="more"></a><h3 id="JavaScript中的进制"><a href="#JavaScript中的进制" class="headerlink" title="JavaScript中的进制 #"></a>JavaScript中的进制 <a href="#t313-javascript%E4%B8%AD%E7%9A%84%E8%BF%9B%E5%88%B6">#</a></h3></li></ul><h4 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示 #"></a>进制表示 <a href="#t4131-%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA">#</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0b10100</span>;<span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0o24</span>;<span class="comment">//八进制</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">20</span>;<span class="comment">//十进制</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">0x14</span>;<span class="comment">//十六进制</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b);</span><br><span class="line"><span class="built_in">console</span>.log(b == c);</span><br><span class="line"><span class="built_in">console</span>.log(c == d);</span><br></pre></td></tr></table></figure><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换 #"></a>进制转换 <a href="#t5132-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">#</a></h4><ul><li>10进制转任意进制 10进制数.toString(目标进制)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(c.toString(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><ul><li>任意进制转十进制 parseInt(‘任意进制字符串’, 原始进制);</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;10100&#x27;</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII #"></a>ASCII <a href="#t614-ascii">#</a></h3><p>最开始计算机只在美国用，八位的字节可以组合出256种不同状态。0-32种状态规定了特殊用途,一旦终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作，如：</p><ul><li>遇上0×10, 终端就换行；</li><li>遇上0×07, 终端就向人们嘟嘟叫；</li></ul><p>又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第 127 号，这样计算机就可以用不同字节来存储英语的文字了</p><p>这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0</p><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Encoding/ascii.jpg"></p><p>这个方案叫做 ASCII 编码</p><blockquote><p>American Standard Code for Information Interchange：美国信息互换标准代码</p></blockquote><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312 #"></a>GB2312 <a href="#t715-gb2312">#</a></h3><p>后来西欧一些国家用的不是英文，它们的字母在ASCII里没有为了可以保存他们的文字，他们使用127号这后的空位来保存新的字母，一直编到了最后一位255。比如法语中的é的编码为130。当然了不同国家表示的符号也不一样，比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)。</p><blockquote><p>从128 到 255 这一页的字符集被称为扩展字符集。</p></blockquote><p>中国为了表示汉字，把127号之后的符号取消了，规定</p><ul><li>一个小于127的字符的意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字；</li><li>前面的一个字节（他称之为高字节）从 <code>0xA1</code>用到 <code>0xF7</code>，后面一个字节（低字节）从 <code>0xA1</code> 到 <code>0xFE</code>；</li><li>这样我们就可以组合出大约7000多个(247-161)*(254-161)=(7998)简体汉字了。</li><li>还把数学符号、日文假名和ASCII里原来就有的数字、标点和字母都重新编成两个字长的编码。这就是全角字符，127以下那些就叫半角字符。</li><li>把这种汉字方案叫做 GB2312。GB2312 是对 ASCII 的中文扩展</li></ul><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK #"></a>GBK <a href="#t816-gbk">#</a></h3><p>后来还是不够用，于是干脆不再要求低字节一定是 127 号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始,又增加了近 20000 个新的汉字（包括繁体字）和符号。</p><h3 id="GB18030-DBCS"><a href="#GB18030-DBCS" class="headerlink" title="GB18030 / DBCS #"></a>GB18030 / DBCS <a href="#t917-gb18030--dbcs">#</a></h3><p>又加了几千个新的少数民族的字， <code>GBK</code>扩成了 <code>GB18030</code> 通称他们叫做 DBCS</p><blockquote><p>Double Byte Character Set：双字节字符集。</p></blockquote><p>在 DBCS 系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里</p><p>各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode #"></a>Unicode <a href="#t1018-unicode">#</a></h3><p>ISO 的国际组织废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符 的编码！ Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。</p><ul><li>International Organization for Standardization：国际标准化组织。</li><li>Universal Multiple-Octet Coded Character Set，简称 UCS，俗称 Unicode</li></ul><p>ISO 就直接规定必须用两个字节，也就是 16 位来统一表示所有的字符，对于 ASCII 里的那些 半角字符，Unicode 保持其原编码不变，只是将其长度由原来的 8 位扩展为16 位，而其他文化和语言的字符则全部重新统一编码。</p><p>从 Unicode 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的一个字符！同时，也都是统一的 两个字节</p><ul><li>字节是一个8位的物理存贮单元，</li><li>而字符则是一个文化相关的符号。</li></ul><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8 #"></a>UTF-8 <a href="#t1119-utf-8">#</a></h3><p>Unicode 在很长一段时间内无法推广，直到互联网的出现，为解决 Unicode 如何在网络上传输的问题，于是面向传输的众多 UTF 标准出现了，</p><blockquote><p>Universal Character Set（UCS）Transfer Format：UTF编码</p></blockquote><ul><li>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</li><li>UTF-8就是每次以8个位为单位传输数据</li><li>而UTF-16就是每次 16 个位</li><li>UTF-8 最大的一个特点，就是它是一种变长的编码方式</li><li>Unicode 一个中文字符占 2 个字节，而 UTF-8 一个中文字符占 3 个字节</li><li>UTF-8 是 Unicode 的实现方式之一</li></ul><h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则 #"></a>编码规则 <a href="#t12110-%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99">#</a></h3><p> 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。<br> 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n+ 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围     |        UTF-<span class="number">8</span>编码方式</span><br><span class="line">(十六进制)        |              （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line"><span class="number">0</span>000 <span class="number">0</span>000-<span class="number">0</span>000 <span class="number">0</span>07F | <span class="number">0</span>xxxxxxx</span><br><span class="line"><span class="number">0</span>000 <span class="number">0</span>080-<span class="number">0</span>000 <span class="number">0</span>7FF | <span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0</span>000 <span class="number">0</span>800-<span class="number">0</span>000 FFFF | <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0</span>001 <span class="number">0</span>000-<span class="number">0</span>010 FFFF | <span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br></pre></td></tr></table></figure><ul><li><a href="http://www.chi2ko.com/tool/CJK.htm">Unicode编码</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ary = [<span class="string">&#x27;1110&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> binary = num.toString(<span class="number">2</span>);</span><br><span class="line">  ary[<span class="number">2</span>] = ary[<span class="number">2</span>]+binary.slice(binary.length-<span class="number">6</span>);</span><br><span class="line">  ary[<span class="number">1</span>] = ary[<span class="number">1</span>]+binary.slice(binary.length-<span class="number">12</span>,binary.length-<span class="number">6</span>);</span><br><span class="line">  ary[<span class="number">0</span>] = ary[<span class="number">0</span>]+binary.slice(<span class="number">0</span>,binary.length-<span class="number">12</span>).padStart(<span class="number">4</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> result =  ary.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(result,<span class="number">2</span>).toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&amp;#x4E07;</span></span><br><span class="line"><span class="keyword">let</span> result = transfer(<span class="number">0x4E07</span>);<span class="comment">//E4B887</span></span><br></pre></td></tr></table></figure><h3 id="联通不如移动"><a href="#联通不如移动" class="headerlink" title="联通不如移动 #"></a>联通不如移动 <a href="#t13111-%E8%81%94%E9%80%9A%E4%B8%8D%E5%A6%82%E7%A7%BB%E5%8A%A8">#</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C1 1100 0001</span><br><span class="line">AA 1010 1010</span><br><span class="line">CD 1100 1101</span><br><span class="line">A8 1010 1000</span><br><span class="line"></span><br><span class="line">0000000001101010-&gt;006A(106)-&gt;j</span><br><span class="line">0000001101101000-&gt;0368(872)-&gt;?</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><a href="http://tools.jb5net/table/gb2312">GB2312</a></li><li><a href="http://blog.csdn.net/hherima/article/details/9045765">unicode编码表1</a></li><li><a href="http://blog.csdn.net/hherima/article/details/9045861">unicode编码表2</a></li></ul><h3 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码 #"></a>文本编码 <a href="#t14112-%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81">#</a></h3><p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。</p><h4 id="BOM的移除"><a href="#BOM的移除" class="headerlink" title="BOM的移除 #"></a>BOM的移除 <a href="#t151121-bom%E7%9A%84%E7%A7%BB%E9%99%A4">#</a></h4><p>BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Bytes      Encoding</span><br><span class="line">----------------------------</span><br><span class="line"> FE FF       UTF16BE</span><br><span class="line"> FF FE       UTF16LE</span><br><span class="line"> EF BB BF    UTF8</span><br></pre></td></tr></table></figure><p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line">    <span class="keyword">if</span> (bin[<span class="number">0</span>] === <span class="number">0xEF</span> &amp;&amp; bin[<span class="number">1</span>] === <span class="number">0xBB</span> &amp;&amp; bin[<span class="number">2</span>] === <span class="number">0xBF</span>) &#123;</span><br><span class="line">        bin = bin.slice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bin.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GBK转UTF8"><a href="#GBK转UTF8" class="headerlink" title="GBK转UTF8 #"></a>GBK转UTF8 <a href="#t161122-gbk%E8%BD%ACutf8">#</a></h4><p>NodeJS支持在读取文本文件时，或者在Buffer转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助iconv-lite这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">&#x27;iconv-lite&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readGBKText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line">    <span class="keyword">return</span> iconv.decode(bin, <span class="string">&#x27;gbk&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读 #"></a>扩展阅读 <a href="#t17112-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">#</a></h2><ul><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-html">utf-8</a></li><li><a href="https://tianziyao.github.io/2017/07/03/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E6%95%85%E4%BA%8B/">字符编码的故事</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Encoding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-能够解决什么问题"><a href="#Node-能够解决什么问题" class="headerlink" title="Node 能够解决什么问题? #"></a>Node 能够解决什么问题? <a href="#t01-node%E8%83%BD%E5%A4%9F%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">#</a></h2><ul><li>Node 的首要目标是提供一种简单的，用于创建高性能服务器的开发工具</li><li>Web 服务器的瓶颈在于并发的用户量，对比 Java 和 Php 的实现方式</li></ul><h2 id="Node-是什么"><a href="#Node-是什么" class="headerlink" title="Node 是什么? #"></a>Node 是什么? <a href="#t12-node%E6%98%AF%E4%BB%80%E4%B9%88">#</a></h2><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境,让 JavaScript 的执行效率与低端的 C 语言的相近的执行效率。。</li><li>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li></ul><h2 id="Node-特点"><a href="#Node-特点" class="headerlink" title="Node 特点 #"></a>Node 特点 <a href="#t23-node%E7%89%B9%E7%82%B9">#</a></h2><a id="more"></a><h3 id="为什么-JavaScript-是单线程？"><a href="#为什么-JavaScript-是单线程？" class="headerlink" title="为什么 JavaScript 是单线程？ #"></a>为什么 JavaScript 是单线程？ <a href="#t331-%E4%B8%BA%E4%BB%80%E4%B9%88javascript%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B">#</a></h3><ul><li>这是由 Javascript 这门脚本语言的用途决定的。</li><li>Web Worker 并没有改变 JavaScript 单线程的本质。</li></ul><h3 id="浏览器模型"><a href="#浏览器模型" class="headerlink" title="浏览器模型 #"></a>浏览器模型 <a href="#t432-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B">#</a></h3><ul><li>用户界面-包括地址栏、前进/后退按钮、书签菜单等</li><li>浏览器引擎-在用户界面和呈现引擎之间传送指令</li><li>呈现引擎-又称渲染引擎，也被称为浏览器内核，在线程方面又称为 UI 线程</li><li>网络-用于网络调用，比如 HTTP 请求</li><li>用户界面后端-用于绘制基本的窗口小部件,UI 线程和 JS 共用一个线程</li><li>JavaScript 解释器-用于解析和执行 JavaScript 代码</li><li>数据存储-这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie</li></ul><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/browser.jpg"></p><h3 id="除-JS-线程和-UI-线程之外的其它线程"><a href="#除-JS-线程和-UI-线程之外的其它线程" class="headerlink" title="除 JS 线程和 UI 线程之外的其它线程 #"></a>除 JS 线程和 UI 线程之外的其它线程 <a href="#t533-%E9%99%A4js%E7%BA%BF%E7%A8%8B%E5%92%8Cui%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A4%96%E7%9A%84%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B">#</a></h3><ul><li>浏览器事件触发线程</li><li>定时触发器线程</li><li>异步 HTTP 请求线程</li></ul><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列 #"></a>任务队列 <a href="#t634-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97">#</a></h3><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有 <strong>同步任务</strong>执行完毕，系统就会读取 <strong>任务队列</strong>，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop #"></a>Event Loop <a href="#t735-event-loop">#</a></h3><p>主线程从 <strong>任务队列</strong>中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop(事件循环)</p><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/eventloop.png"></p><h3 id="Node-js-的-Event-Loop"><a href="#Node-js-的-Event-Loop" class="headerlink" title="Node.js 的 Event Loop #"></a>Node.js 的 Event Loop <a href="#t836-nodejs%E7%9A%84event-loop">#</a></h3><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/nodesystem.png"></p><h2 id="node-js-的主要依赖⼦模块有以下内容"><a href="#node-js-的主要依赖⼦模块有以下内容" class="headerlink" title="node.js 的主要依赖⼦模块有以下内容"></a>node.js 的主要依赖⼦模块有以下内容</h2><ul><li>V8 引擎：主要是 JS 语法的解析，有了它才能识别 JS语法</li><li>libuv: c 语⾔实现的⼀个⾼性能异步⾮阻塞 IO 库，⽤来实现 node.js 的事件循环</li><li>http-parser/llhttp: 底层处理 http 请求，处理报⽂，解析请求包等内容</li><li>openssl: 处理加密算法，各种框架运⽤⼴泛</li><li>zlib: 处理压缩等内容</li></ul><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步 #"></a>同步与异步 <a href="#t937-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5">#</a></h3><p>同步和异步关注的是消息通知机制</p><ul><li>同步就是发出调用后，没有得到结果之前，该调用不返回，一旦调用返回，就得到返回值了。 简而言之就是调用者主动等待这个调用的结果</li><li>而异步则相反，调用者在发出调用后这个调用就直接返回了，所以没有返回结果。换句话说当一个异步过程调用发出后，调用者不会立刻得到结果，而是调用发出后，被调用者通过状态、通知或回调函数处理这个调用。</li></ul><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞 #"></a>阻塞与非阻塞 <a href="#t1038-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E">#</a></h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p><ul><li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li><li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合 #"></a>组合 <a href="#t1139-%E7%BB%84%E5%90%88">#</a></h3><p>同步异步取决于被调用者，阻塞非阻塞取决于调用者</p><ul><li>同步阻塞</li><li>异步阻塞</li><li>同步非阻塞</li><li>异步非阻塞</li></ul><h2 id="什么场合下应该考虑使用-Node-框架"><a href="#什么场合下应该考虑使用-Node-框架" class="headerlink" title="什么场合下应该考虑使用 Node 框架 #"></a>什么场合下应该考虑使用 Node 框架 <a href="#t124%E4%BB%80%E4%B9%88%E5%9C%BA%E5%90%88%E4%B8%8B%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8node%E6%A1%86%E6%9E%B6">#</a></h2><p>当应用程序需要处理大量并发的输入输出，而在向客户端响应之前，应用程序并不需要进行非常复杂的处理。</p><ul><li>聊天服务器</li><li>电子商务网站</li></ul><h2 id="node-部署"><a href="#node-部署" class="headerlink" title="node 部署"></a>node 部署</h2><h3 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h3><ul><li>forever则可以在cmd或ssh连接断开时,让项目一直运行,而且可以在项目崩溃时自动重启</li><li>安装 npm install -g forever</li><li>forever的帮助手册 forever –help</li><li>使用forever启动项目 forever start app.js</li><li>使用forever停止项目 forever stop app.js</li><li>列出所有通过forever管理的项目 forever list</li><li>监视项目中的文件,当文件有变动时重启项目 forever -w start app.js</li></ul><h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>PM2 是具有内置负载均衡器的 Node.js 应用程序的生产流程管理器。它允许您使应用程序永远保持活动状态，在不停机的情况下重新加载它们，并促进常见的系统管理任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装</span><br><span class="line">&gt; npm install pm2 -g</span><br><span class="line"># pm2启动项目</span><br><span class="line">&gt; pm2 start index.js</span><br><span class="line"># pm2停止项目</span><br><span class="line">&gt; pm2 stop index.js</span><br><span class="line"># 列出pm2管理的所有项目 </span><br><span class="line">&gt; pm2 list</span><br><span class="line"># 追踪资源运行情况</span><br><span class="line">&gt; pm2 monit</span><br><span class="line"># 查看日志</span><br><span class="line">&gt; pm2 logs</span><br><span class="line"># pm2重启项目</span><br><span class="line">&gt; pm2 restart id/name</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="node-版本管理工具-fnm"><a href="#node-版本管理工具-fnm" class="headerlink" title="node 版本管理工具 fnm"></a>node 版本管理工具 fnm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 管理员模式打开终端，安装后只能使用管理员模式打开使用</span><br><span class="line"></span><br><span class="line">choco install fnm</span><br><span class="line"></span><br><span class="line"># 安装完成还需要手动设置环境变量</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 命令帮助</span><br><span class="line">fnm --help</span><br><span class="line"></span><br><span class="line"># node 已安装列表</span><br><span class="line">fnm list</span><br><span class="line"></span><br><span class="line"># node 安装</span><br><span class="line">fnm install 版本号(支持模糊&#x2F;lts)</span><br><span class="line"></span><br><span class="line">fnm install v10.22.1  --node-dist-mirror&#x3D;&quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;dist&quot;</span><br><span class="line"># 速度慢的时候，可以切换到国内源</span><br><span class="line">fnm install 16 --node-dist-mirror&#x3D;https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;node</span><br><span class="line"></span><br><span class="line"># node 卸载</span><br><span class="line">fnm uninstall 版本号</span><br><span class="line"></span><br><span class="line"># node 切换</span><br><span class="line">fnm use 版本号</span><br><span class="line"></span><br><span class="line"># node 设置默认</span><br><span class="line">fnm default 版本号</span><br><span class="line"></span><br><span class="line">use 是切换当前 shell 环境，临时的</span><br><span class="line">default 是切换全局，永久的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\System32\WindowsPowerShell\v1.0</span><br><span class="line">添加配置文件 profile.ps1</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;zhishichong.com&#x2F;article&#x2F;47322</span><br><span class="line"></span><br><span class="line">fnm env --use-on-cd | Out-String | Invoke-Expression</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module&amp;NPM</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/module&amp;NPM/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/module&amp;NPM/</url>
      
        <content type="html"><![CDATA[<h2 id="JS模块化方面的不足"><a href="#JS模块化方面的不足" class="headerlink" title="JS模块化方面的不足 #"></a>JS模块化方面的不足 <a href="#t01-js%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B8%8D%E8%B6%B3">#</a></h2><ul><li>JS没有模块系统，不支持封闭的作用域和依赖管理</li><li>没有标准库，没有文件系统和IO流API</li><li>也没有包管理系统</li></ul><h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范 #"></a>CommonJS规范 <a href="#t12-commonjs%E8%A7%84%E8%8C%83">#</a></h2><ul><li>封装功能</li><li>封闭作用域</li><li>可能解决依赖问题</li><li>工作效率更高，重构方便</li></ul><h2 id="Node中的CommonJS"><a href="#Node中的CommonJS" class="headerlink" title="Node中的CommonJS #"></a>Node中的CommonJS <a href="#t23-node%E4%B8%AD%E7%9A%84commonjs">#</a></h2><ul><li>在node.js 里，模块划分所有的功能，每个JS都是一个模块</li><li>实现require方法,NPM实现了模块的自动加载和安装依赖<a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>,<span class="built_in">require</span>,<span class="built_in">module</span>,__filename,__dirname</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">exports</span> = <span class="built_in">module</span>.exports=&#123;&#125;</span><br><span class="line">  <span class="built_in">exports</span>.name = <span class="string">&#x27;zfpx&#x27;</span>;</span><br><span class="line">  <span class="built_in">exports</span> = &#123;<span class="attr">name</span>:<span class="string">&#x27;zfpx&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类 #"></a>模块分类 <a href="#t34-%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB">#</a></h2><h3 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块 #"></a>原生模块 <a href="#t441-%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97">#</a></h3><p><code>http</code> <code>path</code> <code>fs</code> <code>util</code> <code>events</code> 编译成二进制,加载速度最快，原来模块通过名称来加载</p><h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块 #"></a>文件模块 <a href="#t542-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97">#</a></h3><p>在硬盘的某个位置，加载速度非常慢，文件模块通过名称或路径来加载 文件模块的后缀有三种</p><ul><li>后缀名为.js的JavaScript脚本文件,需要先读入内存再运行</li><li>后缀名为.json的JSON文件,fs 读入内存 转化成JSON对象</li><li>后缀名为.node的经过编译后的二进制C/C++扩展模块文件,可以直接使用</li></ul><blockquote><p>一般自己写的通过路径来加载,别人写的通过名称去当前目录或全局的node_modules下面去找</p></blockquote><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块 #"></a>第三方模块 <a href="#t643-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97">#</a></h3><ul><li>如果require函数只指定名称则视为从node_modules下面加载文件，这样的话你可以移动模块而不需要修改引用的模块路径</li><li>第三方模块的查询路径包括module.paths和全局目录</li></ul><h4 id="全局目录"><a href="#全局目录" class="headerlink" title=". 全局目录 #"></a>. 全局目录 <a href="#t7431--%E5%85%A8%E5%B1%80%E7%9B%AE%E5%BD%95">#</a></h4><p>window如果在环境变量中设置了 <code>NODE_PATH</code>变量，并将变量设置为一个有效的磁盘目录，require在本地找不到此模块时向在此目录下找这个模块。 UNIX操作系统中会从 $HOME/.node_modules $HOME/.node_libraries目录下寻找</p><h3 id="模块的加载策略"><a href="#模块的加载策略" class="headerlink" title="模块的加载策略 #"></a>模块的加载策略 <a href="#t844-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5">#</a></h3><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/module&NPM/lookmodule.png"></p><h3 id="文件模块查找规则"><a href="#文件模块查找规则" class="headerlink" title="文件模块查找规则 #"></a>文件模块查找规则 <a href="#t945-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99">#</a></h3><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/module&NPM/lookfile.png"></p><h2 id="从模块外部访问模块内的成员"><a href="#从模块外部访问模块内的成员" class="headerlink" title="从模块外部访问模块内的成员 #"></a>从模块外部访问模块内的成员 <a href="#t105-%E4%BB%8E%E6%A8%A1%E5%9D%97%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84%E6%88%90%E5%91%98">#</a></h2><ul><li>使用exports对象</li><li>使用module.exports导出引用类型</li></ul><h2 id="模块对象的属性"><a href="#模块对象的属性" class="headerlink" title="模块对象的属性 #"></a>模块对象的属性 <a href="#t116-%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">#</a></h2><ul><li>module.id</li><li>module.filename</li><li>module.loaded</li><li>module.parent</li><li>module.children</li><li>module.paths</li></ul><h2 id="包"><a href="#包" class="headerlink" title="包 #"></a>包 <a href="#t127-%E5%8C%85">#</a></h2><p>在Node.js中，可以通过包来对一组具有相互依赖关系的模块进行统一管理，通过包可以把某个独立功能封装起来 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境</p><p>项目 描述 name 项目名称 version 版本号 description 项目描述 keywords: {Array} 关键词，便于用户搜索到我们的项目 homepage 项目url主页 bugs 项目问题反馈的Url或email配置 license 项目许可证 author,contributors 作者和贡献者 main 主文件 bin 项目用到的可执行文件配置 repository 项目代码存放地方 scripts 声明一系列npm脚本指令 dependencies 项目在生产环境中依赖的包 devDependencies 项目在生产环境中依赖的包 peerDependencies 应用运行依赖的宿主包</p><p><a href="https://docs.npmjs.com/files/package.json">package.json</a> <a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html">packagejson</a></p><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM #"></a>NPM <a href="#t138-npm">#</a></h2><ul><li>安装完node之后只能使用Node语言特性及核心函数，我们还需要一个系统来下载、安装和管理第三方模块</li><li>在Node里这个系统被称为Node包管理器(Node Package Manager,NPM)</li></ul><h3 id="npm提供的功能"><a href="#npm提供的功能" class="headerlink" title="npm提供的功能 #"></a>npm提供的功能 <a href="#t1481-npm%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD">#</a></h3><ul><li>公共注册服务，用户可以把自己写的包上传到服务器上</li><li>命令行下载工具，用户可以通过npm命令把别人写的包下载到自己电脑上，还可以管理自己模块依赖的其它模块</li></ul><p>搜索第三方包的地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.npmjs.com/search</span></span><br></pre></td></tr></table></figure><h3 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令 #"></a>npm命令 <a href="#t1582-npm%E5%91%BD%E4%BB%A4">#</a></h3><h4 id="npm-install-安装包"><a href="#npm-install-安装包" class="headerlink" title="(npm install)安装包 #"></a>(npm install)安装包 <a href="#t16821-npm-install%E5%AE%89%E8%A3%85%E5%8C%85">#</a></h4><ul><li>打开命令行或终端，进入要安装包的目录,然后执行以下命令安装依赖的模块</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package-name&gt;</span><br><span class="line">npm i mime</span><br><span class="line">&lt;/package-name&gt;</span><br></pre></td></tr></table></figure><p>此命令会从服务器上下载此模块到当前目录下的node_modules目录下，如果node_modules目录不存在则会创建一个</p><ul><li>也可以安装特定的版本</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package name&gt;@&lt;version spec&gt;</span><br><span class="line">npm i mime@<span class="number">2.1</span></span><br><span class="line">&lt;<span class="regexp">/version&gt;&lt;/</span>package&gt;</span><br></pre></td></tr></table></figure><ul><li>还可以使用一个版本号范围来替换点位符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mime@<span class="number">2.</span>x</span><br></pre></td></tr></table></figure><h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包 #"></a>卸载包 <a href="#t17822-%E5%8D%B8%E8%BD%BD%E5%8C%85">#</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall &lt;package name&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure><h4 id="更新包"><a href="#更新包" class="headerlink" title="更新包 #"></a>更新包 <a href="#t18823-%E6%9B%B4%E6%96%B0%E5%8C%85">#</a></h4><p>我们还可以通过以下指令更新已经安装的包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm update &lt;package name&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure><h3 id="包的安装模式"><a href="#包的安装模式" class="headerlink" title="包的安装模式 #"></a>包的安装模式 <a href="#t1983-%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E6%A8%A1%E5%BC%8F">#</a></h3><h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装 #"></a>本地安装 <a href="#t20831-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85">#</a></h4><ul><li>默认情况下安装命令会把对应的包安装到当前目录下，这叫本地安装，如果包里有可执行的文件NPM会把可执行文件安装到 <code>./node_modules/.bin</code>目录下</li><li>本地安装的模块只能在当前目录和当前目录的子目录里面使用</li></ul><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装 #"></a>全局安装 <a href="#t21832-%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85">#</a></h4><ul><li>如果希望安装的包能够在计算机机的所有目录下面都能使用就需要全局安装</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install  -g</span><br><span class="line">npm install mime -g</span><br><span class="line">C:\Users\zhufeng\AppData\Roaming\npm\node_modules\mime</span><br></pre></td></tr></table></figure><ul><li>在全局安装的模式下，npm会把包安装到全局目录，通过此命令可以查看当前全局目录的位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm root -g</span><br><span class="line">C:\Users\Administrator\AppData\Roaming\npm\node_modules</span><br></pre></td></tr></table></figure><ul><li>如果包里有可执行文件，会把可执行文件安装到此node_modules的上一级目录中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\npm</span><br></pre></td></tr></table></figure><ul><li>全局安装的一般是需要在任意目录下面执行的命令，比如 <code>babel</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-cli -g</span><br></pre></td></tr></table></figure><ul><li>如果全局安装的命令不能用则可能是没有正确配置用户变量 <code>PATH</code>,需要在系统变量中为 <code>PATH</code>变量添加全局安装目录</li></ul><h3 id="注册、登录和发布模块"><a href="#注册、登录和发布模块" class="headerlink" title="注册、登录和发布模块 #"></a>注册、登录和发布模块 <a href="#t2283-%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E5%92%8C%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97">#</a></h3><ol><li><p>注册npm账号 <a href="https://www.npmjs.com/">npmjs</a></p><p>登录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><p>发布</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></li></ol><h3 id="npx"><a href="#npx" class="headerlink" title="npx #"></a>npx <a href="#t2384-npx">#</a></h3><ul><li>npm 从5.2版开始，增加了 npx 命令</li></ul><h4 id="调用项目安装的模块"><a href="#调用项目安装的模块" class="headerlink" title="调用项目安装的模块 #"></a>调用项目安装的模块 <a href="#t24841-%E8%B0%83%E7%94%A8%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%E7%9A%84%E6%A8%A1%E5%9D%97">#</a></h4><ul><li>npx 想要解决的主要问题，就是调用项目内部安装的模块</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D mocha</span><br></pre></td></tr></table></figure><p> 一般来说，调用mocha只能在 <code>package.json</code>的scripts字段里面使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;mocha -version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx mocha --version</span><br></pre></td></tr></table></figure><ul><li>npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在</li></ul><h4 id="避免全局安装模块"><a href="#避免全局安装模块" class="headerlink" title="避免全局安装模块 #"></a>避免全局安装模块 <a href="#t25842-%E9%81%BF%E5%85%8D%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97">#</a></h4><ul><li>除了调用项目内部模块，npx 还能避免全局安装的模块。比如， <code>create-react-app</code>这个模块是全局安装,npx 可以运行它,而且不进行全局安装</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-react-app</span><br></pre></td></tr></table></figure><ul><li>上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除</li></ul><h4 id="–no-install-参数和–ignore-existing-参数"><a href="#–no-install-参数和–ignore-existing-参数" class="headerlink" title="–no-install 参数和–ignore-existing 参数 #"></a>–no-install 参数和–ignore-existing 参数 <a href="#t26843---no-install-%E5%8F%82%E6%95%B0%E5%92%8C--ignore-existing-%E5%8F%82%E6%95%B0">#</a></h4><ul><li>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用 <code>--no-install</code>参数。如果本地不存在该模块，就会报错</li><li>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用 <code>--ignore-existing</code>参数</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> module&amp;NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodeCore</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/nodeCore/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/nodeCore/</url>
      
        <content type="html"><![CDATA[<h2 id="控制台"><a href="#控制台" class="headerlink" title=". 控制台"></a>. 控制台</h2><p>在 Node.js 中，使用 <code>console</code>对象代表控制台(在操作系统中表现为一个操作系统指定的字符界面，比如 Window 中的命令提示窗口)。</p><ul><li>console.log</li><li>console.info</li><li>console.error 重定向到文件</li><li>console.warn</li><li>console.dir</li><li>console.time</li><li>console.timeEnd</li><li>console.trace</li><li>console.assert</li></ul><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title=". 全局作用域"></a>. 全局作用域</h2><ul><li>全局作用域(global)可以定义一些不需要通过任何模块的加载即可使用的变量、函数或类</li><li>定义全局变量时变量会成为 global 的属性。</li><li>永远不要不使用 var 关键字定义变量，以免污染全局作用域</li><li>setTimeout clearTimeout</li><li>setInterval clearInterval</li><li>unref 和 ref</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;callback&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(test, <span class="number">1000</span>);</span><br><span class="line">timer.unref();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  timer.ref();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title=". 函数"></a>. 函数</h2><ul><li>require</li><li>模块加载过程</li><li>require.resolve</li><li>模板缓存(require.cache)</li><li>require.main</li><li>模块导出</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports, <span class="built_in">require</span>, <span class="built_in">module</span>, filename, dirname;</span><br></pre></td></tr></table></figure><h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>在 node.js 里，process 对象代表 node.js 应用程序，可以获取应用程序的用户，运行环境等各种信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">process.argv.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(<span class="string">&quot;exit&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">&quot;uncaughtException&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line">process.chdir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">err</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&amp;#x62A5;&amp;#x9519;&amp;#x4E86;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">err();</span><br></pre></td></tr></table></figure><ul><li>process.nextTick()方法将 callback 添加到”next tick 队列”。 一旦当前事件轮询队列的任务全部完成，在 next tick 队列中的所有 callbacks 会被依次调用。</li><li>setImmediate 预定立即执行的 callback，它是在 I/O 事件的回调之后被触发</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;next&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title=". EventEmitter"></a>. EventEmitter</h2><p>在 Node.js 的用于实现各种事件处理的 event 模块中，定义了 EventEmitter 类，所以可能触发事件的对象都是一个继承自 EventEmitter 类的子类实例对象。</p><table><thead><tr><th>方法名和参数</th><th align="left">描述</th></tr></thead><tbody><tr><td>addListener(event,listener)</td><td align="left">对指定事件绑定事件处理函数</td></tr><tr><td>on(event,listener)</td><td align="left">对指定事件绑定事件处理函数</td></tr><tr><td>once(event,listener)</td><td align="left">对指定事件指定只执行一次的事件处理函数</td></tr><tr><td>removeListener(event,listener)</td><td align="left">对指定事件解除事件处理函数</td></tr><tr><td>removeAllListeners([event])</td><td align="left">对指定事件解除所有的事件处理函数</td></tr><tr><td>setMaxListeners(n)</td><td align="left">指定事件处理函数的最大数量.n为整数值，代表最大的可指定事件处理函数的数量</td></tr><tr><td>listeners(event)</td><td align="left">获取指定事件的所有事件处理函数</td></tr><tr><td>emit(event,[arg1],[arg2],[…])</td><td align="left">手工触发指定事件</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;./events&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line">util.inherits(Bell,EventEmitter);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bell</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bell = <span class="keyword">new</span> Bell();</span><br><span class="line">bell.on(<span class="string">&#x27;newListener&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`对 <span class="subst">$&#123;type&#125;</span>  事件增加<span class="subst">$&#123;listener&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">bell.on(<span class="string">&#x27;removeListener&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`对<span class="subst">$&#123;type&#125;</span> 事件删除<span class="subst">$&#123;listener&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">teacherIn</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`老师带<span class="subst">$&#123;thing&#125;</span>进教室`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">studentIn</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`学生带<span class="subst">$&#123;thing&#125;</span>进教室`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">masterIn</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`校长带<span class="subst">$&#123;thing&#125;</span>进教室`</span>);</span><br><span class="line">&#125;</span><br><span class="line">bell.on(<span class="string">&#x27;响&#x27;</span>,teacherIn);</span><br><span class="line">bell.on(<span class="string">&#x27;响&#x27;</span>,studentIn);</span><br><span class="line">bell.once(<span class="string">&#x27;响&#x27;</span>,masterIn);</span><br><span class="line">bell.emit(<span class="string">&#x27;响&#x27;</span>,<span class="string">&#x27;书&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span>);</span><br><span class="line">bell.emit(<span class="string">&#x27;响&#x27;</span>,<span class="string">&#x27;书&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span>);</span><br><span class="line">bell.removeAllListeners(<span class="string">&#x27;响&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span>);</span><br><span class="line">bell.emit(<span class="string">&#x27;响&#x27;</span>,<span class="string">&#x27;书&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.events = &#123;&#125;;<span class="comment">//会把所有的事件监听函数放在这个对象里保存</span></span><br><span class="line">  <span class="comment">//指定给一个事件类型增加的监听函数数量最多有多少个</span></span><br><span class="line">  <span class="built_in">this</span>._maxListeners = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span>(<span class="params">maxListeners</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._maxListeners = maxListeners;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.listeners = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.events[event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给指定的事件绑定事件处理函数，1参数是事件类型 2参数是事件监听函数</span></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.events[type]</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type].push(listener);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>._maxListeners!=<span class="number">0</span>&amp;&amp;<span class="built_in">this</span>.events[type].length&gt;<span class="built_in">this</span>._maxListeners</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`MaxListenersExceededWarning: Possible EventEmitter memory leak detected. <span class="subst">$&#123;<span class="built_in">this</span>.events[type].length&#125;</span> <span class="subst">$&#123;type&#125;</span> listeners added. Use emitter.setMaxListeners() to increase limit`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果以前没有添加到此事件的监听函数，则赋一个数组</span></span><br><span class="line">    <span class="built_in">this</span>.events[type] = [listener];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//用完即焚</span></span><br><span class="line"> <span class="keyword">let</span>  wrapper = <span class="function">(<span class="params">...rest</span>)=&gt;</span>&#123;</span><br><span class="line">   listener.apply(<span class="built_in">this</span>);<span class="comment">//先让原始的监听函数执行</span></span><br><span class="line">   <span class="built_in">this</span>.removeListener(type,wrapper);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">this</span>.on(type,wrapper);</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.events[type]</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type] = <span class="built_in">this</span>.events[type].filter(<span class="function"><span class="params">l</span>=&gt;</span>l!=listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除某个事件的所有监听函数</span></span><br><span class="line">EventEmitter.prototype.removeAllListeners = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">this</span>.events[type];</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type,...rest</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.events[type]&amp;&amp;<span class="built_in">this</span>.events[type].forEach(<span class="function"><span class="params">listener</span>=&gt;</span>listener.apply(<span class="built_in">this</span>,rest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br></pre></td></tr></table></figure><h2 id="util"><a href="#util" class="headerlink" title="util"></a>util</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//util.inherit();</span></span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(&#123;<span class="attr">name</span>:<span class="string">&#x27;zfpx&#x27;</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(util.isArray([]));</span><br><span class="line"><span class="built_in">console</span>.log(util.isRegExp(<span class="regexp">/\d/</span>));</span><br><span class="line"><span class="built_in">console</span>.log(util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(util.isError(<span class="keyword">new</span> <span class="built_in">Error</span>));</span><br></pre></td></tr></table></figure><h2 id="node-断点调试"><a href="#node-断点调试" class="headerlink" title=". node 断点调试"></a>. node 断点调试</h2><p>V8 提供了一个强大的调试器，可以通过 TCP 协议从外部访问。Nodejs 提供了一个内建调试器来帮助开发者调试应用程序。想要开启调试器我们需要在代码中加入 debugger 标签，当 Nodejs 执行到 debugger 标签时会自动暂停（debugger 标签相当于在代码中开启一个断点）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> all = a + <span class="string">&#x27; &#x27;</span> + b;</span><br><span class="line"><span class="built_in">console</span>.log(all);</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th align="left">用途</th></tr></thead><tbody><tr><td>c</td><td align="left">继续执行到下一个断点处</td></tr><tr><td>next,n</td><td align="left">单步执行</td></tr><tr><td>step,s</td><td align="left">单步进入函数</td></tr><tr><td>out,o</td><td align="left">退出当前函数</td></tr><tr><td>setBreakpoint(10),sb(10)</td><td align="left">在第10行设置断点</td></tr><tr><td>repl</td><td align="left">打开求值环境，ctrl_c退回debug模式</td></tr><tr><td>watch(exp)</td><td align="left">把表达式添加监视列表</td></tr><tr><td>watchers</td><td align="left">显示所有表达式的值</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/packageJson/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/packageJson/</url>
      
        <content type="html"><![CDATA[<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><h3 id="package-json简介"><a href="#package-json简介" class="headerlink" title="package.json简介"></a>package.json简介</h3><p>在nodejs项目中，package.json是管理其依赖的配置文件，通常我们在初始化一个nodejs项目的时候会通过：npm init -y<br>然后在你的目录下会生成3个目录/文件， node_modules, package.json和 package.lock.json。其中package.json的内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Your project name&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Your project description&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;app.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Author name&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;dependency1&quot;</span>: <span class="string">&quot;^1.4.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;dependency2&quot;</span>: <span class="string">&quot;^1.5.2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json中包含了项目本身的元数据,以及项目的子依赖信息(比如dependicies等)。</p><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p>我们发现在npm init的时候，不仅生成了package.json文件，还生成了package-lock.json文件。那么为什么存在package.json的清空下，还需要生成package-lock.json文件呢。</p><p>本质上package-lock.json文件是为了锁版本，在package.json中指定的子npm包比如：react: “^16.0.0”，在实际安装中，只要高于react的版本都满足package.json的要求。这样就使得根据同一个package.json文件，两次安装的子依赖版本不能保证一致。</p><p>而package-lock文件如下所示，子依赖dependency1就详细的指定了其版本。起到lock版本的作用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Your project name&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lockfileVersion&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;requires&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;dependency1&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.4.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;resolved&quot;</span>: </span><br><span class="line"><span class="string">&quot;https://registry.npmjs.org/dependency1/-/dependency1-1.4.0.tgz&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;integrity&quot;</span>: </span><br><span class="line"><span class="string">&quot;sha512-a+UqTh4kgZg/SlGvfbzDHpgRu7AAQOmmqRHJnxhRZICKFUT91brVhNNt58CMWU9PsBbv3PDCZUHbVxuDiH2mtA==&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;dependency2&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.5.2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;resolved&quot;</span>: </span><br><span class="line"><span class="string">&quot;https://registry.npmjs.org/dependency2/-/dependency2-1.5.2.tgz&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;integrity&quot;</span>: </span><br><span class="line"><span class="string">&quot;sha512-WOn21V8AhyE1QqVfPIVxe3tupJacq1xGkPTB4iagT6o+P2cAgEOOwIxMftr4+ZCTI6d551ij9j61DFr0nsP2uQ==&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="package-json常用属性"><a href="#package-json常用属性" class="headerlink" title="package.json常用属性"></a>package.json常用属性</h2><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>在npm中使用script标签来定义脚本，每当制定npm run的时候，就会自动创建一个shell脚本，这里需要注意的是，npm run新建的这个 Shell，会将本地目录的node_modules/.bin子目录加入PATH变量。</p><p>这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 esbuild，只要直接写esbuild xxx 就可以了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;esbuild index.js&quot;</span>,</span><br><span class="line"> <span class="comment">// &quot;build&quot;: &quot;./node_modules/.bin/esbuild index.js&quot;  上面两种写法是等价的。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>bin属性用来将可执行文件加载到全局环境中，指定了bin字段的npm包，一旦在全局安装，就会被加载到全局环境中，可以通过别名来执行该文件。<br>比如@bytepack/cli的npm包：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;bytepack&quot;: &quot;./bin/index.js&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>一旦在全局安装了@bytepack/cli，就可以直接通过bytepack来执行相应的命令，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytepack -v</span><br><span class="line"><span class="comment">//显示1.11.0</span></span><br></pre></td></tr></table></figure><p>如果非全局安装，那么会自动连接到项目的node_module/.bin目录中。与前面介绍的script标签中所说的一致，可以直接用别名来使用。</p><h3 id="workspaces"><a href="#workspaces" class="headerlink" title="workspaces"></a>workspaces</h3><p>在项目过大的时候，最近越来越流行monorepo。提到monorepo就绕不看workspaces，早期我们会用yarn workspaces，现在npm官方也支持了workspaces.<br>workspaces解决了本地文件系统中如何在一个顶层root package下管理多个子packages的问题，在workspaces声明目录下的package会软链到最上层root package的node_modules中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;workspaces&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;packages/a&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个npm包名为my-project的npm包中，存在workspaces配置的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">+-- package.json</span><br><span class="line">+-- index.js</span><br><span class="line">&#96;-- packages</span><br><span class="line">   +-- a</span><br><span class="line">   |  &#96;-- package.json</span><br></pre></td></tr></table></figure><p>并且该最上层的名为my-project的root包，有packages/a子包。此时，我们如果npm install,那么在root package中node_modules中安装的npm包a，指向的是本地的package/a.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">+-- node_modules</span><br><span class="line">|  `-- packages/a -&gt; ../packages/a</span><br><span class="line">+-- package-lock.json</span><br><span class="line">+-- package.json</span><br><span class="line">`-- packages</span><br><span class="line">   +-- a</span><br><span class="line">   |   `-- package.json</span><br></pre></td></tr></table></figure><p><code>-- packages/a -&gt; ../packages/a</code>指的就是从node_modules中a链接到本地npm包的软链</p><p>###</p><h2 id="package-json环境相关属性"><a href="#package-json环境相关属性" class="headerlink" title="package.json环境相关属性"></a>package.json环境相关属性</h2><p>常见的环境，基本上分为浏览器browser和node环境两大类，接下来我们来看看package.json中，跟环境相关的配置属性。环境的定义可以简单理解如下：</p><ul><li>browser环境：比如存在一些只有在浏览器中才会存在的全局变量等，比如window，Document等</li><li>node环境: npm包的源文件中存在只有在node环境中才会有的一些变量和内置包，内置函数等。</li></ul><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>js的模块化规范包含了commonjs、CMD、UMD、AMD和ES module等，最早先在node中支持的仅仅是commonjs字段，但是从node13.2.0开始后，node正式支持了ES module规范，在package.json中可以通过type字段来声明npm包遵循的模块化规范。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   name: &quot;some package&quot;,</span><br><span class="line">   type: &quot;module&quot;||&quot;commonjs&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不指定type的时候，type的默认值是commonjs，不过建议npm包都指定一下type</li><li>当type字段指定值为module则采用ESModule规范</li><li>当type字段指定时，目录下的所有.js后缀结尾的文件，都遵循type所指定的模块化规范</li><li>除了type可以指定模块化规范外，通过文件的后缀来指定文件所遵循的模块化规范，以.mjs结尾的文件就是使用的ESModule规范，以.cjs结尾的遵循的是commonjs规范</li></ul><h3 id="main-amp-module-amp-browser"><a href="#main-amp-module-amp-browser" class="headerlink" title="main &amp; module &amp; browser"></a>main &amp; module &amp; browser</h3><p>除了type外，package.json中还有main,module和browser 3个字段来定义npm包的入口文件。</p><ul><li>main : 定义了 npm 包的入口文件，browser 环境和 node 环境均可使用</li><li>module : 定义 npm 包的 ESM 规范的入口文件，browser 环境和 node - 环境均可使用</li><li>browser : 定义 npm 包在 browser 环境下的入口文件<br>我们来看一下这3个字段的使用场景，以及同时存在这3个字段时的优先级。我们假设有一个npm包为demo1</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----- dist</span><br><span class="line">   |-- index.browser.js</span><br><span class="line">   |-- index.browser.mjs</span><br><span class="line">   |-- index.js</span><br><span class="line">   |-- index.mjs</span><br></pre></td></tr></table></figure><p>其package.json中同时指定了main,module和browser这3个字段，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;dist/index.js&quot;,  // main </span><br><span class="line">  &quot;module&quot;: &quot;dist/index.mjs&quot;, // module</span><br><span class="line"></span><br><span class="line">  <span class="comment">// browser 可定义成和 main/module 字段一一对应的映射对象，也可以直接定义为字符串</span></span><br><span class="line">  &quot;browser&quot;: &#123;</span><br><span class="line">    &quot;./dist/index.js&quot;: &quot;./dist/index.browser.js&quot;, // browser+cjs</span><br><span class="line">    &quot;./dist/index.mjs&quot;: &quot;./dist/index.browser.mjs&quot;  // browser+mjs</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &quot;browser&quot;: &quot;./dist/index.browser.js&quot; // browser</span></span><br></pre></td></tr></table></figure><p>默认构建和使用，比如我们在项目中引用这个npm包 <code>import demo from &#39;demo&#39;</code><br>通过构建工具构建上述代码后，模块的加载循序为：</p><p><code>browser+mjs &gt; module &gt; browser+cjs &gt; main</code></p><p>这个加载顺序是大部分构建工具默认的加载顺序，比如webapck、esbuild等等。可以通过相应的配置修改这个加载顺序，不过大部分场景，我们还是会遵循默认的加载顺序。</p><h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p>如果在package.json中定义了exports字段，那么这个字段所定义的内容就是该npm包的真实和全部的导出，优先级会高于main和file等字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;pkg&quot;,</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;.&quot;: &quot;.&#x2F;main.mjs&quot;,</span><br><span class="line">    &quot;.&#x2F;foo&quot;: &quot;.&#x2F;foo.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import &#123; something &#125; from &quot;pkg&quot;; &#x2F;&#x2F; from &quot;pkg&#x2F;main.mjs&quot;</span><br><span class="line">const &#123; something &#125; &#x3D; require(&quot;pkg&#x2F;foo&quot;); &#x2F;&#x2F; require(&quot;pkg&#x2F;foo.js&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上述的例子来看，exports可以定义不同path的导出。如果存在exports后，以前正常生效的file目录到处会失效，比如require(‘pkg/package.json’)，因为在exports中没有指定，就会报错。</p><p>exports还有一个最大的特点，就是条件引用，比如我们可以根据不同的引用方式或者模块化类型，来指定npm包引用不同的入口文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &quot;name&quot;:&quot;pkg&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;.&#x2F;main-require.cjs&quot;,</span><br><span class="line">  &quot;exports&quot;: &#123;</span><br><span class="line">    &quot;import&quot;: &quot;.&#x2F;main-module.js&quot;,</span><br><span class="line">    &quot;require&quot;: &quot;.&#x2F;main-require.cjs&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;type&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的例子中，如果我们通过</p><p><code>const p = require(&#39;pkg&#39;)</code><br>引用的就是”./main-require.cjs”。</p><p>如果通过：<br><code>import p from &#39;pkg&#39;</code><br>引用的就是”./main-module.js”<br>最后需要注意的是 ：<code>如果存在exports属性，exports属性不仅优先级高于main，同时也高于module和browser字段</code>。</p><h2 id="package-json依赖相关属性"><a href="#package-json依赖相关属性" class="headerlink" title="package.json依赖相关属性"></a>package.json依赖相关属性</h2><p>package.json中跟依赖相关的配置属性包含了dependencies、devDependencies、peerDependencies和peerDependenciesMeta等。</p><p>dependencies是项目的依赖，而devDependencies是开发所需要的模块，所以我们可以在开发过程中需要的安装上去，来提高我们的开发效率。这里需要注意的时，在自己的项目中尽量的规范使用，形如webpack、babel等是开发依赖，而不是项目本身的依赖，不要放在dependencies中。<br>dependencies除了dependencies和devDependencies，重点peerDependencies和peerDependenciesMeta。</p><h3 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h3><p>peerDependencies是package.json中的依赖项,可以解决核心库被下载多次，以及统一核心库版本的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;package&#x2F;pkg</span><br><span class="line">----- node_modules</span><br><span class="line">   |-- npm-a -&gt; 依赖了react,react-dom</span><br><span class="line">   |-- npm-b -&gt; 依赖了react,react-dom</span><br><span class="line">   |-- index.js</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>比如上述的例子中如果子npm包a,b都依赖了react和react-dom,此时如果我们在子npm包a,b的package.json中声明了PeerDependicies后，相应的依赖就不会重新安装。</p><p>需要注意的有两点：</p><ul><li>对于子npm包a,在npm7中，如果单独安装子npm a,其peerDependicies中的包，会被安装下来。但是npm7之前是不会的。</li><li>请规范和详细的指定PeerDependicies的配置，笔者在看到有些react组件库，不在PeerDependicies中指定react和react-dom，或者将react和- react-dom放到了dependicies中，这两种不规范的指定都会存在一些问题。</li><li>其二，正确的指定PeerDependicies中npm包的版本，<a href="mailto:&#x72;&#101;&#x61;&#x63;&#116;&#x2d;&#x66;&#x6f;&#x63;&#117;&#115;&#45;&#x6c;&#x6f;&#99;&#107;&#64;&#50;&#46;&#x38;&#x2e;&#49;">&#x72;&#101;&#x61;&#x63;&#116;&#x2d;&#x66;&#x6f;&#x63;&#117;&#115;&#45;&#x6c;&#x6f;&#99;&#107;&#64;&#50;&#46;&#x38;&#x2e;&#49;</a>,peerDependicies指定的是：”react”: “^16.8.0 || ^17.0.0 || ^18.0.0”，但实际上，这个react-focus-lock并不支持18.x的react</li></ul><h3 id="peerDependenciesMeta"><a href="#peerDependenciesMeta" class="headerlink" title="peerDependenciesMeta"></a>peerDependenciesMeta</h3><p>看到“Meta”就有元数据的意思，这里的peerDependenciesMeta就是详细修饰了peerDependicies，比如在react-redux这个npm包中的package.json中有这么一段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;peerDependencies&quot;: &#123;</span><br><span class="line">   &quot;react&quot;: &quot;^16.8.3 || ^17 || ^18&quot;</span><br><span class="line"> &#125;,</span><br><span class="line">&quot;peerDependenciesMeta&quot;: &#123;</span><br><span class="line">   &quot;react-dom&quot;: &#123;</span><br><span class="line">     &quot;optional&quot;: true</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;react-native&quot;: &#123;</span><br><span class="line">     &quot;optional&quot;: true</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里指定了”react-dom”,”react-native”在peerDependenciesMeta中，且为可选项，因此如果项目中检测没有安装”react-dom”和”react-native”都不会报错。</p><p>值得注意的是，通过peerDependenciesMeta我们确实是取消了限制，但是这里经常存在非A即B的场景，比如上述例子中，我们需要的是“react-dom”和”react-native”需要安装一个，但是实际上通过上述的声明，我们实现不了这种提示。</p><h2 id="依赖包的版本管理"><a href="#依赖包的版本管理" class="headerlink" title="依赖包的版本管理"></a>依赖包的版本管理</h2><p>^2.0.3或~2.0.3，这是什么意思呢</p><h3 id="npm的包通常需要遵从semver版本规范"><a href="#npm的包通常需要遵从semver版本规范" class="headerlink" title="npm的包通常需要遵从semver版本规范"></a>npm的包通常需要遵从semver版本规范</h3><ul><li>semver：<a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></li><li>npm semver：<a href="https://docs.npmjs.com/misc/semver">https://docs.npmjs.com/misc/semver</a></li></ul><h3 id="semver版本规范是X-Y-Z"><a href="#semver版本规范是X-Y-Z" class="headerlink" title="semver版本规范是X.Y.Z"></a>semver版本规范是X.Y.Z</h3><ul><li>X主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）；</li><li>Y次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；</li><li>Z修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；</li></ul><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="^ * 和~的区别"></a>^ * 和~的区别</h3><ul><li>x.y.z：表示一个明确的版本号；</li><li>^x.y.z：表示x是保持不变的，y和z永远安装最新的版本；</li><li>~x.y.z：表示x和y保持不变的，z永远安装最新的版本；</li><li>*x.y.x: 一般是最后一次正式发布版本</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> package.json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包管理器</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>npm、yarn、cnpm、npx、pnpm</p><p><a href="./%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.pdf">包管理工具</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/promise/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/promise/</url>
      
        <content type="html"><![CDATA[<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，就是常说的回调地狱<br>如果几个异步操作之间并没有前后顺序之分,但需要等多个异步操作都完成后才能执行后续的任务，无法实现并行节约时间</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 本意是承诺，在程序中的意思就是承诺我 <strong>过一段时间后</strong>会给你一个结果。 什么时候会用到 <strong>过一段时间</strong>？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等</p><a id="more"></a><h2 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a>Promise 的三种状态</h2><ul><li>Pending Promise 对象实例创建时候的初始状态</li><li>Fulfilled 可以理解为成功的状态</li><li>Rejected 可以理解为失败的状态</li></ul><blockquote><p>then 方法就是用来指定 Promise 对象的状态改变时确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject 时执行第二个函数（onRejected）</p></blockquote><h2 id="构造一个-Promise"><a href="#构造一个-Promise" class="headerlink" title="构造一个 Promise"></a>构造一个 Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) resolve(<span class="string">&quot;This is resolve!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> reject(<span class="string">&quot;This is reject!&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(Fulfilled, Rejected);</span><br></pre></td></tr></table></figure><ul><li>构造一个 Promise 实例需要给 Promise 构造函数传入一个函数。</li><li>传入的函数需要有两个形参，两个形参都是 function 类型的参数。<ul><li>第一个形参运行后会让 Promise 实例处于 resolve 状态，所以我们一般给第一个形参命名为 resolve,使 Promise 对象的状态改变成成功，同时传递一个参数用于后续成功后的操作</li><li>第一个形参运行后会让 Promise 实例处于 reject 状态，所以我们一般给第一个形参命名为 reject,将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(</span><br><span class="line">    (data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">this</span>.success(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="built_in">this</span>.error();</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.success(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.error(error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">success, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.success = success;</span><br><span class="line">  <span class="built_in">this</span>.error = error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    fn(</span><br><span class="line">      (data) =&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.success(data);</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.error();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.success(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">reject</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">success, error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.success = success;</span><br><span class="line">    <span class="built_in">this</span>.error = error;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="promise-做为函数的返回值"><a href="#promise-做为函数的返回值" class="headerlink" title="promise 做为函数的返回值"></a>promise 做为函数的返回值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxPromise</span>(<span class="params">queryUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, queryUrl, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          resolve(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajaxPromise(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="promise-的链式调用"><a href="#promise-的链式调用" class="headerlink" title="promise 的链式调用"></a>promise 的链式调用</h2><ul><li>每次调用返回的都是一个新的 Promise 实例</li><li>链式调用的参数通过返回值传递</li></ul><p><code>then</code>可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 <code>Promise</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">&quot;1.txt&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> readFile(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="promise-API"><a href="#promise-API" class="headerlink" title="promise API"></a>promise API</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><ul><li><strong>参数</strong>：接受一个数组，数组内都是 <code>Promise</code>实例</li><li><strong>返回值</strong>：返回一个 <code>Promise</code>实例，这个 <code>Promise</code>实例的状态转移取决于参数的 <code>Promise</code>实例的状态变化。当参数中所有的实例都处于 <code>resolve</code>状态时，返回的 <code>Promise</code>实例会变为 <code>resolve</code>状态。如果参数中任意一个实例处于 <code>reject</code>状态，返回的 <code>Promise</code>实例变为 <code>reject</code>状态。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不管两个 promise 谁先完成，Promise.all 方法会按照数组里面的顺序将结果返回<br>Promise.all()方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>ES2020 引入了Promise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p><p>Promise.allSettled()方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更。</p><p><strong>返回值</strong><br>[<br>  {status: ‘fulfilled’, value: …response…},<br>  {status: ‘fulfilled’, value: …response…},<br>  {status: ‘rejected’, reason: …error object…}<br>]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ fetch(<span class="string">&#x27;index.html&#x27;</span>), fetch(<span class="string">&#x27;https://does-not-exist/&#x27;</span>) ];</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出成功的请求</span></span><br><span class="line"><span class="keyword">const</span> successfulPromises = results.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出失败的请求，并输出原因</span></span><br><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">p</span> =&gt;</span> p.reason);</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>取最快的返回结果值无论成功或者失败</p><ul><li><strong>参数</strong>：接受一个数组，数组内都是 <code>Promise</code>实例</li><li><strong>返回值</strong>：返回一个 <code>Promise</code>实例，这个 <code>Promise</code>实例的状态转移取决参数的 <code>Promise</code>实例的<code>第一个状态变化</code>。当参数中第一个实例处于 <code>resolve</code>状态时，返回的 <code>Promise</code>实例会变为 <code>resolve</code>状态。如果参数中第一个实例处于 <code>reject</code>状态，返回的 <code>Promise</code>实例变为 <code>reject</code>状态。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只要p1、p2、p3之中有一个实例率先改变状态，实例的状态就跟着改变。那个率先改变的 <span class="built_in">Promise</span> 实例的返回值为结果。</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2，p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。<br>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promise.resolve**返回一个 <code>Promise</code>实例，这个实例处于 <code>resolve</code>状态。</p><p>根据传入的参数不同有不同的功能：</p><ul><li>值(对象、数组、字符串等)：作为 <code>resolve</code>传递出去的值</li><li><code>Promise</code>实例：原封不动返回</li></ul><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>返回一个 <code>Promise</code>实例，这个实例处于 <code>reject</code>状态。</p><ul><li>参数一般就是抛出的错误信息。</li></ul><h2 id="q"><a href="#q" class="headerlink" title="q"></a>q</h2><p>Q 是一个在 Javascript 中实现 promise 的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&quot;q&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  fs.readFile(filename, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      deferred.reject(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deferred.resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">&quot;1.txt1&quot;</span>).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="function"><span class="title">defer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> _success, _error;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        _success(data);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">reject</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">        _error(err);</span><br><span class="line">      &#125;,</span><br><span class="line">      promise: &#123;</span><br><span class="line">        <span class="function"><span class="title">then</span>(<span class="params">success, error</span>)</span> &#123;</span><br><span class="line">          _success = success;</span><br><span class="line">          _error = error;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pending = [],</span><br><span class="line">    value;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    resolve: <span class="function"><span class="keyword">function</span> (<span class="params">_value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        value = _value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = pending.length; i &lt; ii; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> callback = pending[i];</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;</span><br><span class="line">        pending = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    promise: &#123;</span><br><span class="line">      then: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">          pending.push(callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="bluebird"><a href="#bluebird" class="headerlink" title="bluebird"></a>bluebird</h2><p>实现 promise 标准的库是功能最全，速度最快的一个库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">&quot;./bluebird&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">Promise</span>.promisify(<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).readFile);</span><br><span class="line">readFile(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">contents</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">Promise</span>.promisifyAll(<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>));</span><br><span class="line"></span><br><span class="line">fs.readFileAsync(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">contents</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="function"><span class="title">promisify</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fn.apply(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          args.concat(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              resolve(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">promisifyAll</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(attr) &amp;&amp; <span class="keyword">typeof</span> obj[attr] == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        obj[attr + <span class="string">&quot;Async&quot;</span>] = <span class="built_in">this</span>.promisify(obj[attr]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="co"><a href="#co" class="headerlink" title="co"></a>co</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> number = <span class="built_in">Math</span>.random();</span><br><span class="line">      <span class="keyword">if</span> (number &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        resolve(number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&quot;数字太小&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> getNumber();</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">let</span> c = <span class="keyword">yield</span> getNumber();</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> g = gen();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">lastValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; done, value &#125; = g.next(lastValue);</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        resolve(lastValue);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          value.then(next, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            reject(val);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">co(read).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="keyword">else</span> resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> readFile(<span class="string">&quot;./1.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> readFile(<span class="string">&quot;./2.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> g = gen();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; done, value &#125; = g.next(val);</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">      value.then(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-A-完整实现"><a href="#Promise-A-完整实现" class="headerlink" title="Promise/A+完整实现"></a>Promise/A+完整实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> item(value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> item(value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;循环引用&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> then, called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x == <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  onFulfilled =</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled == <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onFulfilled</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected == <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  <span class="keyword">if</span> (self.status == <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status == <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">          result[i] = data;</span><br><span class="line">          <span class="keyword">if</span> (++count == promises.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defer = &#123;&#125;;</span><br><span class="line">  defer.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    defer.resolve = resolve;</span><br><span class="line">    defer.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> defer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * npm i -g promises-aplus-tests</span></span><br><span class="line"><span class="comment"> * promises-aplus-tests Promise.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="http://liubin.org/promises-book/">JavaScript Promise迷你书</a><br><a href="https://promisesaplus.com/">Promise/A+规范</a><br><a href="https://juejin.cn/post/7043758954496655397">Promise 手写</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js异步</title>
      <link href="2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/js%E5%BC%82%E6%AD%A5/"/>
      <url>2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/js%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul><li>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段,比如，有一个任务是读取文件进行处理，异步的执行过程就是下面这样。</li></ul><p><img src="http://img.zhufengpeixun.cn/asyncfunc1.png"></p><p>这种不连续的执行，就叫做异步。相应地，连续的执行，就叫做同步。</p><p><img src="http://img.zhufengpeixun.cn/syncfunc.png"></p><h2 id="异步编程的语法目标，就是怎样让它更像同步编程-有以下几种"><a href="#异步编程的语法目标，就是怎样让它更像同步编程-有以下几种" class="headerlink" title="异步编程的语法目标，就是怎样让它更像同步编程,有以下几种"></a>异步编程的语法目标，就是怎样让它更像同步编程,有以下几种</h2><ul><li>回调函数实现</li><li>事件监听</li><li>发布订阅</li><li>Promise/A+ 和生成器函数</li><li>async/await<a id="more"></a><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2></li></ul><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;&amp;#x67D0;&amp;#x4E2A;&amp;#x6587;&amp;#x4EF6;&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是一个错误优先的回调函数(error-first callbacks),这也是 Node.js 本身的特点之一。</p><!-- more --><h2 id="回调的问题"><a href="#回调的问题" class="headerlink" title="回调的问题"></a>回调的问题</h2><h3 id="5-1-异常处理"><a href="#5-1-异常处理" class="headerlink" title="5.1 异常处理"></a>5.1 异常处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//xxx</span></span><br><span class="line">&#125;<span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span>&#123;<span class="comment">//TODO&#125;</span></span><br></pre></td></tr></table></figure><p>异步代码时 <code>try catch</code>不再生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;&amp;#x6355;&amp;#x83B7;&amp;#x9519;&amp;#x8BEF;&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(t);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为这个回调函数被存放了起来，直到下一个事件环的时候才会取出,try 只能捕获当前循环内的异常，对 callback 异步无能为力。</p><p>Node 在处理异常有一个约定，将异常作为回调的第一个实参传回，如果为空表示没有出错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params">err, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>异步方法也要遵循两个原则</p><ul><li>必须在异步之后调用传入的回调函数</li><li>如果出错了要向回调函数传入异常供调用者判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (success) callback(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span> callback(<span class="string">&quot;&amp;#x9519;&amp;#x8BEF;&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;&amp;#x6355;&amp;#x83B7;&amp;#x9519;&amp;#x8BEF;&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>**回调地狱<a href="#t852-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1">#</a>**异步多级依赖的情况下嵌套非常深，代码难以阅读的维护</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.readFile(<span class="string">&quot;template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(template + <span class="string">&quot; &quot;</span> + data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="异步流程解决方案"><a href="#异步流程解决方案" class="headerlink" title="异步流程解决方案"></a>异步流程解决方案</h2><h3 id="事件发布-订阅模型"><a href="#事件发布-订阅模型" class="headerlink" title="事件发布/订阅模型"></a>事件发布/订阅模型</h3><p>订阅事件实现了一个事件与多个回调函数的关联</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> eve = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="keyword">let</span> html = &#123;&#125;;</span><br><span class="line">eve.on(<span class="string">&quot;ready&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  html[key] = value;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(html).length == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(html);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    eve.emit(<span class="string">&quot;ready&quot;</span>, <span class="string">&quot;template&quot;</span>, template);</span><br><span class="line">  &#125;);</span><br><span class="line">  fs.readFile(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    eve.emit(<span class="string">&quot;ready&quot;</span>, <span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="哨兵变量"><a href="#哨兵变量" class="headerlink" title="哨兵变量"></a>哨兵变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> after = <span class="function"><span class="keyword">function</span> (<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    result[key] = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(result).length == times) &#123;</span><br><span class="line">      callback(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> done = after(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    done(<span class="string">&quot;template&quot;</span>, template);</span><br><span class="line">  &#125;);</span><br><span class="line">  fs.readFile(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    done(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">rende;</span><br></pre></td></tr></table></figure><h3 id="Promise-Deferred-模式"><a href="#Promise-Deferred-模式" class="headerlink" title="Promise/Deferred 模式"></a>Promise/Deferred 模式</h3><h3 id="生成器-Generators-yield"><a href="#生成器-Generators-yield" class="headerlink" title="生成器 Generators/ yield"></a>生成器 Generators/ yield</h3><ul><li>当你在执行一个函数的时候，你可以在某个点暂停函数的执行，并且做一些其他工作，然后再返回这个函数继续执行， 甚至是携带一些新的值，然后继续执行。</li><li>上面描述的场景正是 JavaScript 生成器函数所致力于解决的问题。当我们调用一个生成器函数的时候，它并不会立即执行， 而是需要我们手动的去执行迭代操作（next 方法）。也就是说，你调用生成器函数，它会返回给你一个迭代器。迭代器会遍历每个中断点。</li><li>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据</li></ul><h4 id="生成器的使用"><a href="#生成器的使用" class="headerlink" title="生成器的使用"></a>生成器的使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.next()); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Co"><a href="#Co" class="headerlink" title="Co"></a>Co</h4><p><code>co</code>是一个为 <code>Node.js</code>和浏览器打造的基于生成器的流程控制工具，借助于 Promise，你可以使用更加优雅的方式编写非阻塞代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="keyword">else</span> resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> template = <span class="keyword">yield</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">&#125;</span><br><span class="line">co(read).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> it = gen();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    !(<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">lastVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; value, done &#125; = it.next(lastVal);</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value.then(next, <span class="function">(<span class="params">reason</span>) =&gt;</span> reject(reason));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/ await"></a>Async/ await</h2><p>使用 <code>async</code>关键字，你可以轻松地达成之前使用生成器和 co 函数所做到的工作</p><h3 id="Async-的优点"><a href="#Async-的优点" class="headerlink" title="Async 的优点"></a>Async 的优点</h3><ul><li>内置执行器</li><li>更好的语义</li><li>更广的适用性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="keyword">else</span> resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> template = <span class="keyword">await</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = read();</span><br><span class="line">result.then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure><h3 id="async-函数的实现"><a href="#async-函数的实现" class="headerlink" title="async 函数的实现"></a>async 函数的实现</h3><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> template = <span class="keyword">await</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> template = <span class="keyword">yield</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符优先级</title>
      <link href="2022/03/13/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>2022/03/13/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/03/13/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 运算符优先级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算符优先级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>git init</td><td>git仓库初始化</td></tr><tr><td>git clone <giturl></giturl></td><td>复制现有仓库</td></tr><tr><td>git status</td><td>查看git仓库状态</td></tr><tr><td>git log</td><td>查看commit列表记录<br>–oneline  浓缩成一行一条记录<br>–stat         输出文件改动的统计数据<br>-p               输出改动文件的具体内容<br>-w              忽略空格的修改和-p一起用</td></tr><tr><td>git show <SHA></SHA></td><td>查看commit具体记录，也有–stat,-p,-w的配置</td></tr><tr><td>git add .</td><td>将工作区全部改动提交到暂存区</td></tr><tr><td>git commit</td><td>将暂存区改动提交到版本库<br>-m             添加本次改动的title<br>–amend  更改最后一个commit包括缓存区改动和改动的title</td></tr><tr><td>git diff</td><td>查看工作区修改</td></tr><tr><td>git tag -a <tagname></tagname></td><td>设置commit标签<br>-a               设置标签名<br>-d               删除标签名</td></tr><tr><td>git checkout <Branch></Branch></td><td>切换分支</td></tr><tr><td>git checkout -b &lt;本地分支名&gt; &lt;远程分支名&gt;</td><td>创建本地分支并关联远程分支</td></tr><tr><td>git checkout -t &lt;远程分支名&gt;</td><td>创建本地分支并自动关联远程分支，本地分支名和远程分支一致</td></tr><tr><td>git checkout .</td><td>撤销工作区的修改(只能撤销在已有文件上的修改)</td></tr><tr><td>git restore .</td><td>撤销工作区的修改</td></tr><tr><td>git clean -df</td><td>删除工作区新增的文件</td></tr><tr><td>git clean -xdf</td><td>删除工作区新增的文件和文件夹</td></tr><tr><td>git merge <branch></branch></td><td>合并分支</td></tr><tr><td>git revert <sha></sha></td><td>还原，并向前提交一个新的commit来保存还原的内容</td></tr><tr><td>git reset</td><td>重置，会删除commit，慎用<br>–hard  会清空工作目录和暂存区的改动<br>–soft    则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。<br>–mixed  默认行为，保留工作目录，并且清空暂存区<br>HEAD^表示当前版本<br>HEAD^^上上一个版本<br>HEAD~2上上一个版本</td></tr><tr><td>git reset HEAD^</td><td>使用场景：已使用git add . 命令，未使用git commit -m ‘’命令</td></tr><tr><td>git reset –soft HEAD^</td><td>使用场景：已使用git commit -m ‘’命令，撤销之后会把修改放在暂存区</td></tr><tr><td>git reset  –hard  HEAD^</td><td>使用场景：已使用git commit -m，撤销之后不会保留任何更改，比如打包之后提交了commit，想重新打包，则可以使用</td></tr><tr><td>git reset HEAD</td><td>撤销缓存区的修改，撤销上一次add</td></tr><tr><td>git remote -v</td><td>远程库查询</td></tr><tr><td>git remote add origin <url></url></td><td>添加远程库</td></tr><tr><td>git remote remove <origin></origin></td><td>删除远程库</td></tr><tr><td>git push origin –delete <branch></branch></td><td>删除远程分支</td></tr><tr><td>git push &lt;分支名&gt;</td><td>推送本地分支到远程分支</td></tr><tr><td>git push origin –delete <branch></branch></td><td>删除远程分支</td></tr><tr><td>git push origin –delete &lt;分支名&gt;</td><td>删除远程分支</td></tr><tr><td>git config –global core.autocrlf false</td><td>禁用换行方式转换</td></tr><tr><td>git push -u origin master</td><td>跟踪远程分支</td></tr><tr><td>git push -f</td><td>强制推送</td></tr><tr><td>git pull &lt;分支名&gt;</td><td>拉取远程分支到本地分支</td></tr><tr><td>git pull -u origin dev</td><td>拉取远程分支</td></tr><tr><td>git branch</td><td>列出所有分支(仅本地分支)</td></tr><tr><td>git branch -a</td><td>列出所有分支(包括远程分支)</td></tr><tr><td>git branch -d &lt;分支名&gt;</td><td>删除分支</td></tr><tr><td>git branch -D &lt;分支名&gt;</td><td>强行删除分支</td></tr><tr><td>git branch &lt;分支名&gt;</td><td>创建新分支</td></tr><tr><td>git branch -m &lt;旧分支名&gt;  &lt;新分支名&gt;</td><td>重命名分支</td></tr><tr><td>git branch -vv</td><td>查看本地分支与远程分支的关联分支</td></tr><tr><td>git clean -n</td><td>显示将要删除的新增文件，不显示新增的文件夹及包含的文件</td></tr><tr><td>git clean -f</td><td>删除新增文件，不删除新增的文件夹及包含的文件</td></tr><tr><td>git clean -df</td><td>删除新增文件以及新增的文件夹和其包含的文件</td></tr><tr><td>git fetch &lt;分支名&gt;</td><td>获取远端的更新，但不进行合并</td></tr><tr><td>git config –global core.quotepath false</td><td>git中文显示数字的问题</td></tr><tr><td>git log –pretty=oneline 文件名 （文件名是文件路径+文件名，输入完整）</td><td>git查看某个文件的提交历史</td></tr><tr><td>git show 某次commit 的哈希值  文件名</td><td>git查看某个文件某次提交的修改</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>git config –global gui.encoding utf-8</td><td></td></tr><tr><td>git config –global i18n.commit.encoding utf-8</td><td></td></tr><tr><td>git config –global i18n.logoutputencoding utf-8</td><td></td></tr><tr><td>$env:LESSCHARSET=’utf-8’</td><td>解决 powerShell git log显示中文的问题</td></tr><tr><td>git config –global core.autocrlf false</td><td>git提示LF CRLF转换的警告</td></tr><tr><td>git blame -L <lineStart>,<lineEnd> &lt;path+fileName&gt;</lineEnd></lineStart></td><td>git查看部分行的历史改动记录</td></tr><tr><td>git config –global core.quotepath false</td><td>解决中文显示成数字的bug</td></tr><tr><td>GIT_MERGE_AUTOEDIT=no      export GIT_MERGE_AUTOEDIT</td><td>用来解决git bash 合并时自动打开VIM编辑器的问题</td></tr><tr><td>git blame</td><td>找到具体代码的责任人</td></tr></tbody></table><a id="more"></a><h3 id="git恢复某个文件到上一个提交版本"><a href="#git恢复某个文件到上一个提交版本" class="headerlink" title="git恢复某个文件到上一个提交版本"></a>git恢复某个文件到上一个提交版本</h3><p>git提交了比较多的文件到远程，但是在合并时发现其中有一个文件合并有冲突或者某个原因不想修改该文件了，那就需要单独把这个文件回退到上一个提交版本状态。方法如下：</p><p>1.首先查看一下该文件的commit记录：git log 文件，例如 git log src/index.java</p><p>2.找到需要提交到上一个版本的commit号，然后checkout该文件的上一版本，输入下面的指令：</p><p>git checkout [commit id] 文件，例如 git checkout a57fb4b474888f0db4cba18de2180496 src/index.java</p><p>3.然后将checkout的版本提交到本地</p><p>git commit -m “回退到上一版本”</p><p>4.最后将改变提交到分支远程：</p><p>git push origin 分支名</p><p>这样此文件本地和远程都是上一版本内容</p><h1 id="git合并特定的commit"><a href="#git合并特定的commit" class="headerlink" title="git合并特定的commit"></a>git合并特定的commit</h1><p>多版本并行开发的时候一般都是一个版本一个分支，验收通过上线的时候将该分支直接合并到生产环境中</p><p>但是有的时候我们只想合并某一个或几个commit，来满足业务的需求(这个功能今晚上，其他可以晚点上)</p><p>使用git cherry-pick <commit id> 合并特定的commit，操作对象是commit而非分支</commit></p><p>commit id 可以是来自任何分支，他不关心分支，因为commit id 总是唯一的</p><p>使用git log来查看commit id，可以是完整的commit id，也可以是id前6位</p><p>实际演示</p><p>本地有两个分支，master和uat，我们将uat分支的commitid=9494f1的记录合并到master上，而不合并整个分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b uat  &#x2F;&#x2F; 创建uat分支</span><br><span class="line">... &#x2F;&#x2F; 修改两次，提交两次commit</span><br><span class="line">git log   &#x2F;&#x2F; 记录两次修改的commit   第一次修改为9494f1 第二次修改为d3450d</span><br><span class="line">git checkout master &#x2F;&#x2F; 切回master分支</span><br><span class="line">git cherry-pick 9494f1  &#x2F;&#x2F; 合并commit</span><br><span class="line">git log &#x2F;&#x2F; 发现commit已合并</span><br></pre></td></tr></table></figure><h2 id="git贮藏功能使用场景"><a href="#git贮藏功能使用场景" class="headerlink" title="git贮藏功能使用场景"></a>git贮藏功能使用场景</h2><p>1、如果你某个分支开发过程中，这个分支的内容是要在本月月底上线的，但是生产上已经出现了一个重大bug，需要你立马去修复。你在分支开发的内容已经开发一部分了，工作区有内容是不能切换分支的，这个时候就可以用到贮藏的功能了</p><h2 id="git贮藏功能使用流程（sourceTree）"><a href="#git贮藏功能使用流程（sourceTree）" class="headerlink" title="git贮藏功能使用流程（sourceTree）"></a>git贮藏功能使用流程（sourceTree）</h2><p>第一步：将修改一半的文件先贮藏起来，以防以后需要使用</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-1.png" alt="1574129769274"></p><p>选中修改的文件，点击贮藏按钮</p><p>第二步：再输入框中输入文字描述本次贮藏，然后点击确定按钮（之后就可以进行修改bug的工作）</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-2.png" alt="1574129926356"></p><p>第三步：应用贮藏功能</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-3.png" alt="1574130371631"></p><p>选择分支=&gt;选择贮藏=&gt;点击鼠标右键=&gt;应用贮藏区=&gt;确定=&gt;恢复为修改一般的初始状态</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-4.png" alt="1574130600911"></p><h2 id="git贮藏功能使用流程（git-shell）"><a href="#git贮藏功能使用流程（git-shell）" class="headerlink" title="git贮藏功能使用流程（git shell）"></a>git贮藏功能使用流程（git shell）</h2><ul><li>贮藏</li></ul><p>git stash：将当前工作贮藏</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-6.png" alt="1574130796152"></p><p>git stash save  “描述内容”:给每个stash加一个message</p><p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/own\biji\notes\images\git贮藏\git-5.png" alt="1574133235403"></p><ul><li>查看贮藏列表</li></ul><p>git stash list：查看贮藏的列表</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-7.png" alt="1574131196038"></p><ul><li>应用</li></ul><p>git stash apply:将缓存堆栈中的第一个stash多次应用到工作目录中，但并不删除stash拷贝</p><p>git stash apply stash@{0} ：恢复贮藏序列为0的贮藏中的工作内容,但并不删除stash拷贝</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-8.png" alt="1574131410296"></p><ul><li>删除</li></ul><p>git stash drop：将缓存堆栈中的第一个stash删除</p><p>git stash drop stash@{0}：删除贮藏序列为0的贮藏中的工作内容</p><p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/own\biji\notes\images\git贮藏\git-9.png" alt="1574132441468"></p><p>git stash clear：删除所有缓存的stash</p><ul><li>应用并删除</li></ul><p>git stash pop：将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</p><p>git stash pop stash@{0}：将贮藏序列为0的贮藏中的工作内容应用并且删除</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-10.png" alt="1574133389346"></p><ul><li>查看具体的修改记录</li></ul><p>git stash show:查看缓存堆栈中的第一个stash的diff</p><p>git stash show stash@{0}:查看贮藏序列为0的stash的diff</p><p><img src="/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-11.png" alt="1574133731206"></p><h2 id="git最基本的6个操作"><a href="#git最基本的6个操作" class="headerlink" title="git最基本的6个操作"></a>git最基本的6个操作</h2><ul><li>创建本地仓库<br> 创建.gitignore配置文件<br> git init<br> git add *<br> git commit -m “xxx”</li><li>创建远程仓库<br> New Repository<br> 指定名称<br> 创建</li><li>将本地仓库推送到远程仓库<br> git remote add origin <a href="https://github.com/zxfjd3g/xxx.git">https://github.com/zxfjd3g/xxx.git</a> 关联远程仓库<br> git push origin master</li><li>如果本地有更新, 推送到远程<br> git add *<br> git commit -m “xxx”<br> git push origin master</li><li>如果远程有更新, 拉取到本地<br> git pull origin master<br> git fetch origin master:tmp</li><li>克隆远程仓库到本地<br> git clone <a href="https://github.com/zxfjd3g/xxx.git">https://github.com/zxfjd3g/xxx.git</a><br> git checkout -b dev origin/dev</li></ul><h2 id="说说git的分支-合并与冲突"><a href="#说说git的分支-合并与冲突" class="headerlink" title="说说git的分支,合并与冲突"></a>说说git的分支,合并与冲突</h2><ul><li>分支是在开发主线之外编写你的代码完成特定工作而不影响开发主线</li><li>分支的操作:<br> 查看分支: git branch<br> 创建分支: git branch dev<br> 切换分支: git checkout dev<br> 比较分支: git diff master dev<br> 合并分支: git merge dev</li><li>冲突<br> 产生冲突: 当对2个分支进行合并时, 如果同一个文件的同一行内容不一样, 就会产生冲突<br> 解决冲突:<pre><code>修正合并后产生冲突的代码git add *git commit -m &quot;resolve conflict&quot;</code></pre></li></ul><h2 id="说说git公司多人协作与开源项目多人协作"><a href="#说说git公司多人协作与开源项目多人协作" class="headerlink" title="说说git公司多人协作与开源项目多人协作"></a>说说git公司多人协作与开源项目多人协作</h2><ul><li>公司多人协作: 先在github上创建组织(修改权限), 多个同事加入此组织, 在组织下创建项目, 成员都可以进行推送更新</li><li>开源多人协作: fork仓库到自己的账户下, 修改fork仓库的代码, 向原仓库发起一个pull request, 对方接收到请求后可以选择合并</li></ul><h2 id="区别fork-复刻-与clone-克隆"><a href="#区别fork-复刻-与clone-克隆" class="headerlink" title="区别fork(复刻)与clone(克隆)"></a>区别fork(复刻)与clone(克隆)</h2><ul><li>fork: 将别人的远程仓库完全复制为自己的远程仓库</li><li>clone:  将远程仓库(自己/别人)完全复制为本地仓库</li></ul><h2 id="区别git的pull与fetch"><a href="#区别git的pull与fetch" class="headerlink" title="区别git的pull与fetch"></a>区别git的pull与fetch</h2><ul><li>简单来说，git pull 是 git fetch + git merge</li><li>执行pull: 将远程仓库的更新拉取到本地后, 与本地仓库当前分支进行自动合并(可能会遇到冲突)</li><li>执行fetch: 将远程仓库的更新拉取到一个暂时的新分支上, 后面需要手动进行merge操作(可以先进行diff操作)</li></ul><h2 id="git的几个主要分支"><a href="#git的几个主要分支" class="headerlink" title="git的几个主要分支"></a>git的几个主要分支</h2><ul><li>master分支<br>主分支，产品的功能全部实现后，最终在master分支对外发布。</li><li>develop分支<br>开发分支，基于master分支克隆，产品的编码工作在此分支进行。</li><li>release分支<br>测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。</li><li>bugfix/hotfix分支<br>Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。</li><li>feature分支<br>功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> git命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器原理</title>
      <link href="2021/05/14/browersRander/"/>
      <url>2021/05/14/browersRander/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h2><ul><li><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html">浏览器原理</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 浏览器原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>googleV8</title>
      <link href="2020/11/27/googleV8/"/>
      <url>2020/11/27/googleV8/</url>
      
        <content type="html"><![CDATA[<h2 id="如何学习谷歌高性能-JavaScript-引擎V8"><a href="#如何学习谷歌高性能-JavaScript-引擎V8" class="headerlink" title="如何学习谷歌高性能 JavaScript 引擎V8"></a>如何学习谷歌高性能 JavaScript 引擎V8</h2><ul><li><p>什么是 V8？<br>V8 是 JavaScript 虚拟机的一种。我们可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的编程语言 JavaScript，翻译成机器能够理解的机器语言。如下图所示：<br><img src="/2020/11/27/googleV8/v8_01.jpg" alt="JavaScript引擎"></p><p>上图中，中间的“黑盒”就是 JavaScript 引擎 V8。目前市面上有很多种 JavaScript 引擎，诸如 SpiderMonkey、V8、JavaScriptCore 等。而由谷歌开发的开源项目 V8 是当下使用最广泛的 JavaScript 虚拟机，全球有超过 25 亿台安卓设备，而这些设备中都使用了 Chrome 浏览器，所以我们写的 JavaScript 应用，大都跑在 V8 上。<br>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升</p><a id="more"></a><p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。</p><p>V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以你会看到目前市面上 JavaScript 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率</p><p>V8 的主要功能，就是结合 JavaScript 语言的特性和本质来编译执行它</p></li><li><p>学习V8</p><p>V8 的编译流水线，其完整流程<br><img src="/2020/11/27/googleV8/v8_02.jpg" alt="v8编译流水线"><br>编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等等。这些技术决定着一段 JavaScript 代码能否正常执行，以及代码的执行效率。</p><p>V8 中使用的隐藏类（Hide Class），这是将 JavaScript 中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果你熟悉 V8 的工作机制，在你编写 JavaScript 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码</p><p>V8 实现了 JavaScript 代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，你可以优化你的代码更加适应这个机制，从而提高程序性能</p><p>除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是 <strong><em>事件循环系统</em></strong> 和 <strong><em>垃圾回收机制</em></strong>。</p><p>事件循环系统和 JavaScript 中的难点——异步编程特性紧密相关。JavaScript 是单线程的，JavaScript 代码都是在一个线程上执行，如果同一时间发送了多个 JavaScript 执行的请求，就需要排队，也就是进行异步编程。<br>V8 的事件循环系统会调度这些排队任务，保证 JavaScript 代码被 V8 有序地执行。因此也可以说，事件循环系统就是 V8 的心脏，它驱动了 V8 的持续工作。</p><p>JavaScript 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是我们经常会遇到的一个问题。你需要知道 V8 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了<br><img src="/2020/11/27/googleV8/all_v8.jpg" alt="v8"></p></li></ul><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p><img src="/2020/11/27/googleV8/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.png" alt="编译原理"></p><blockquote class="pullquote mindmap mindmap-lg"><ul><li>googlV8<ul><li>v8的基础环境<ul><li>堆空间<ul><li>树状存储结构</li><li>存储对象</li><li>存储闭包函数引用的原生类型</li></ul></li><li>栈空间<ul><li>先进后出</li><li>存储原生类型</li></ul></li><li>全局执行上下文<ul><li>初始化this</li><li>全局作用域</li><li>全局对象</li></ul></li><li>宿主环境<ul><li>宿主类型<ul><li>浏览器</li><li>node</li><li>其他宿主</li></ul></li><li>内置<ul><li>内置函数</li><li>内置对象<ul><li>浏览器 window</li><li>node.global</li></ul></li></ul></li></ul></li><li>事件循环系统<ul><li>消息队列</li><li>任务调度系统</li></ul></li></ul></li><li>v8执行流程<ul><li>词法分析<ul><li>扫描源码</li><li>分割源码中的字符</li><li>输出Token</li></ul></li><li>语法分析<ul><li>基于词法分析出来的Token分析语法错误，给出提示</li><li>输出AST</li><li>输出作用域<ul><li>词法作用域规则</li><li>包含当前域中的对象和函数</li></ul></li><li>惰性编译<ul><li>推迟解析函数中的代码</li><li>到执行函数时再解析</li><li>默认只解析顶层代码</li></ul></li><li>预解析器<ul><li>快速查看函数</li><li>检查函数的语法是否正确</li><li>检查是否有闭包函数<ul><li>如果函数引用了父函数中的变量，那么必须将引用的变量分配到堆中</li></ul></li></ul></li></ul></li><li>字节码<ul><li>v8执行javascript过程中的中间代码</li><li>根据作用域和AST生成</li><li>机器代码的抽象</li><li>v8虚拟机的指令集</li><li>字节码缓存<ul><li>降低内存</li><li>提升执行速度</li></ul></li></ul></li><li>解释执行字节码<ul><li>两种经典的虚拟机架构<ul><li>寄存器的虚拟机<ul><li>累加器<ul><li>计算过程中临时变量存放在累加器中</li></ul></li><li>寄存器<ul><li>PC寄存器—— 用来存放下一条字节码指令<ul><li>通用寄存器—— 用来存放数据</li></ul></li></ul></li><li>堆和栈<ul><li>堆存放对象等数据<ul><li>栈管理函数调用关系</li></ul></li></ul></li></ul></li><li>基于栈架构的虚拟机<ul><li>寄存器<ul><li>pc寄存器</li><li>通用寄存器</li></ul></li><li>栈<ul><li>管理函数调用</li><li>存放临时变量</li></ul></li><li>堆<ul><li>存放对象等数据</li></ul></li></ul></li><li>v8才用的是寄存器的虚拟机<ul><li>充分使用累加器</li><li>字节码指令集的编程风格和基于栈的有差异</li><li>顺序执行字节码</li></ul></li></ul></li></ul></li><li>优化字节码执行速度<ul><li>为什么解释执行慢<ul><li>javascript 是动态语言</li><li>v8事先不知道类型的形状</li><li>动态查找属性</li><li>执行之前需要编译</li></ul></li><li>内联缓存<ul><li>缓存对象形状</li><li>下次执行相同类型时，直接使用该形态来快速定位属性</li></ul></li></ul></li><li>即时编译<ul><li>监视器<ul><li>监视解释器的执行过程</li><li>发现热点代码</li><li>将热点代码提交给编辑器优化</li></ul></li><li>编译器<ul><li>编译器会编译热点代码</li><li>并优化编译后的二进制机器代码</li><li>二进制代码能够被高效执行</li></ul></li><li>隐藏类<ul><li>提取代码中的对象的形状</li><li>并记录具体形状</li><li>通过形状快速定位对象属性</li></ul></li><li>反优化<ul><li>对象的形状被动态修改了</li><li>隐藏类失效</li><li>触发反优化机制</li></ul></li></ul></li></ul></li><li>事件循环系统<ul><li>什么是事件循环系统<ul><li>javascript是单线程模式</li><li>单线程同时只能执行一个任务</li><li>有新的任务就需要排队执行</li><li>引入消息队列</li><li>消息队列中的任务是宏任务</li><li>任务调度器<ul><li>循环读取消息队列中的任务</li><li>分派给指定的任务处理器</li></ul></li></ul></li><li>异步编程<ul><li>回掉函数模式<ul><li>以回掉函数的方式编写异步代码</li><li>可读性差</li><li>代码难维护</li><li>回掉地狱</li></ul></li><li>Promise 模式<ul><li>半同步的方式编写异步代码</li><li>使用微任务</li><li>改造了回调函数</li><li>可读性提升</li></ul></li><li>async/await 模式<ul><li>同步的方式编写异步代码</li><li>使用微任务</li><li>使用了协程</li><li>可读性大幅提升</li><li>原理复杂</li></ul></li></ul></li></ul></li><li>javascript设计思想<ul><li>函数一等公民<ul><li>函数拥有普通类型的特性<ul><li>可以作为参数</li><li>可以作为返回值</li><li>可以赋值给一个变量</li></ul></li><li>基于对象设计<ul><li>基本类型<ul><li>String</li><li>Number</li><li>Boolean</li><li>Null</li><li>Undefined</li><li>Symbol</li><li>BigInt</li></ul></li><li>对象类型<ul><li>普通对象</li><li>函数</li><li>数组</li></ul></li></ul></li><li>对象是动态的<ul><li>可以在运行时改变对象属性</li></ul></li><li>支持闭包<ul><li>函数即对象</li><li>函数可以作为返回值</li><li>子函数可以引用父函数内部的变量</li><li>父函数返回子函数，子函数引用父函数的变量需要一同打包带走</li></ul></li><li>函数表达式<ul><li>函数声明<ul><li>在编译阶段，会将声明的函数转换成函数对象</li><li>函数声明会被变量提升</li></ul></li><li>函数表达式<ul><li>在编译阶段，不会对函数表达式做任何操作</li><li>立即调用函数表达式</li></ul></li></ul></li></ul></li><li>类型系统和垃圾回收<ul><li>类型系统<ul><li>什么是类型系统<ul><li>内存中的二进制是没有类型的</li><li>我们可以强制给一组二进制赋予类型信息</li><li>类型信息为许多操作提供隐含的上下文<ul><li>两个整数类型相加</li><li>两个字符串类型相加</li></ul></li><li>类型系统限制了不合法的类型操作<ul><li>1+ ‘2’ js 中合法</li><li>1+ ‘2’ Python 中不合法</li></ul></li></ul></li><li>不同的类型如何存储<ul><li>对象存储在堆中</li><li>基本类型存储在栈中</li></ul></li><li>传值和传引用<ul><li>原生类型一律传值</li><li>对象类型一律传引用</li></ul></li></ul></li><li>垃圾回收<ul><li>采用自动垃圾回收策略</li></ul></li></ul></li><li>作用域<ul><li>源代码中定义变量的区域</li><li>静态作用域（写代码的时候静态确认下来的）</li><li>动态作用域 （和函数调用的位置有关）</li><li>javascript 是基于静态作用域</li><li>作用域链(沿着多个作用域，查找变量的链路)<ul><li>函数级作用域</li><li>函数内声明的变量生成周期和函数绑定</li><li>块级作用域</li><li>变量和函数声明</li></ul></li></ul></li><li>原型链继承<ul><li>原型<ul><li>每个对象都有一个原型属性</li><li>原型也是一个对象</li><li>通过__proto__指向原型对象</li></ul></li><li>原型链(查找对象属性的链路)<ul><li>先在当前的属性中查找</li><li>再在原型对象中查找</li><li>再在原型的原型对象中查找直到 顶层Object的原型对象</li></ul></li><li>new 关键字</li></ul></li></ul></li><li>垃圾回收系统<ul><li>什么是自动垃圾回收系统<ul><li>自动跟踪正在使用的对象并回收不再使用的对象</li></ul></li><li>回收方式<ul><li>手动分配和回收<ul><li>显示分配内存</li><li>手动回收内存</li></ul></li><li>智能指针<ul><li>记住每个对象被引用的次数</li><li>当引用计数为0 时，便自动回收该对象</li></ul></li><li>自动内存管理<ul><li>所有被引用的元素都用一个根元素</li><li>每次从根向下遍历，没有被遍历到的数据视为垃圾数据</li></ul></li></ul></li><li>代记假说<ul><li>大部分对象在内存中存活的时间短</li><li>不死的对象会会活的更久</li></ul></li><li>分代收集<ul><li>新生代存放新对象那</li><li>老生代存放老对象</li></ul></li><li>垃圾回收器<ul><li>副垃圾回收器(负责新生代的垃圾回收)</li><li>主垃圾回收器（负责老生代的代码回收）</li></ul></li><li>垃圾回收流程<ul><li>通用流程<ul><li>回收非活动对象占用的内存</li><li>整理内存碎片</li></ul></li><li>副垃圾回收器<ul><li>Scavenge 算法</li><li>新生代的对象和空闲区域</li><li>对象晋升策略</li></ul></li><li>主垃圾回收器<ul><li>标记清除算法</li><li>标记整理算法</li><li>大对象</li><li>晋升的对象</li></ul></li><li>全停顿<ul><li>垃圾回收操作会占用主线程</li><li>会阻塞主线程<ul><li>引发问题<ul><li>代码不规范，触发频繁的垃圾回收，主业务被阻塞</li></ul></li><li>优化方法<ul><li>优化代码<ul><li>减少触发垃圾回收次数</li><li>采用增量垃圾回收</li></ul></li><li>v8 采用并行垃圾回收策略</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> googleV8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> googleV8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="操作符的强制类型转换规则"><a href="#操作符的强制类型转换规则" class="headerlink" title="== 操作符的强制类型转换规则"></a>== 操作符的强制类型转换规则</h2><ul><li>字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较</li><li>其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较</li><li>null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</li><li>对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后基本类型，再进行比较</li><li>如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）</li><li>如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</li></ul><h2 id="对象转原始类型"><a href="#对象转原始类型" class="headerlink" title="对象转原始类型"></a>对象转原始类型</h2><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下：</p><ul><li>如果已经是原始类型了，那就不需要转换了</li><li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li><li>调用 <code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li><li>如果都没有返回原始类型，就会报错</li></ul><p>当然你也可以重写 <code>Symbol.toPrimitive</code> ，该方法在转原始类型时调用优先级最高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><h2 id="、Object-is-、Set-去重的区别"><a href="#、Object-is-、Set-去重的区别" class="headerlink" title="===、Object.is()、Set 去重的区别"></a>===、Object.is()、Set 去重的区别</h2><ul><li>这几个的差异是在-0 与+0；NaN 上</li><li>=== -0 与+0 是相等的 NaN 与 NaN 是不相等的</li><li>Object.is() 与===相反，-0 与+0 是不相等的，NaN 与 NaN 是相等的</li><li>Set 认为两组都是相等的</li><li>includes 和 Set 相同</li></ul><h2 id="Array-indexOf-和-includes-的区别"><a href="#Array-indexOf-和-includes-的区别" class="headerlink" title="Array indexOf 和 includes 的区别"></a>Array indexOf 和 includes 的区别</h2><ul><li>返回值不同<ul><li>indexOf 返回数值类型，表示当前第一个匹配到的数组索引</li><li>includes 返回布尔类型，判断是否在数组中存在这个值</li></ul></li><li>比较算法的差异<ul><li>indexOf 使用严格相等(===)来比较是否相等</li><li>includes 使用 sameValueZero 算法来比较是否相同(SameValueZero，自 ES2016 开始，用于 ArrayBuffer 构造函数，以及 Map 和 Set 操作以及 includes 方法)</li></ul></li></ul><h2 id="this-指向-当前方法执行的主体-谁执行的这个方法-那么-THIS-就是谁-所以-THIS-和当前方法在哪创建的或者在哪执行的都没有必然的关系"><a href="#this-指向-当前方法执行的主体-谁执行的这个方法-那么-THIS-就是谁-所以-THIS-和当前方法在哪创建的或者在哪执行的都没有必然的关系" class="headerlink" title="this 指向 当前方法执行的主体(谁执行的这个方法,那么 THIS 就是谁,所以 THIS 和当前方法在哪创建的或者在哪执行的都没有必然的关系)"></a>this 指向 当前方法执行的主体(谁执行的这个方法,那么 THIS 就是谁,所以 THIS 和当前方法在哪创建的或者在哪执行的都没有必然的关系)</h2><p><code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p><ul><li>给元素的某个事件绑定方法，方法中的 THIS 都是当前操作的元素本身</li><li>函数执行，看函数前面是否有点，有的话，点前面是谁 THIS 就是谁，没有点，THIS 是 WINDOW（在 JS 的严格模式下，没有点 THIS 是 UNDEFINED）</li><li>构造函数执行，方法中的 this 一般都是当前类的实例</li><li>箭头函数中没有自己的 THIS,THIS 是上下文中的 THIS</li><li>在小括号表达式中，会影响 THIS 的指向</li><li>使用 call/apply/bind 可以改变 this 指向<a id="more"></a></li></ul><h2 id="case-语句是使用恒等（-）来判断的"><a href="#case-语句是使用恒等（-）来判断的" class="headerlink" title="case 语句是使用恒等（===）来判断的"></a>case 语句是使用恒等（===）来判断的</h2><h2 id="正则-test-方法的参数如果不是字符串，会经过抽象-ToString-操作强制转成字符串"><a href="#正则-test-方法的参数如果不是字符串，会经过抽象-ToString-操作强制转成字符串" class="headerlink" title="正则 test 方法的参数如果不是字符串，会经过抽象 ToString 操作强制转成字符串"></a>正则 test 方法的参数如果不是字符串，会经过抽象 ToString 操作强制转成字符串</h2><h2 id="JSON-stringify-拷贝时-obj-的缺陷"><a href="#JSON-stringify-拷贝时-obj-的缺陷" class="headerlink" title="JSON.stringify 拷贝时 obj 的缺陷"></a>JSON.stringify 拷贝时 obj 的缺陷</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/json.stringify.png" alt="JSON.stringify"></p><ul><li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失</li><li>拷贝 Date 引用类型会变成字符串</li><li>无法拷贝不可枚举的属性</li><li>无法拷贝对象的原型链</li><li>拷贝正则会变成空对象</li><li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null</li><li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)</li></ul><h2 id="js-常见的-6-中继承方式"><a href="#js-常见的-6-中继承方式" class="headerlink" title="js 常见的 6 中继承方式"></a>js 常见的 6 中继承方式</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%A7%E6%89%BF.png" alt="JavaScript继承"></p><ul><li><p>原型链继承<br>介绍：子类的原型指向父类构造的实例<br>缺点： 原型属性共享问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;child2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child1.prototype = <span class="keyword">new</span> Parent1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1());</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2();</span><br><span class="line">s1.play.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.play, s2.play);</span><br></pre></td></tr></table></figure></li><li><p>构造函数继承<br>缺点：只能继承父类的实例属性和方法，不能继承原型属性或者方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent1.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;child1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="built_in">console</span>.log(child); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// Child1 &#123; name: &#x27;parent1&#x27;, type: &#x27;child1&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.getName()); <span class="comment">// 会报错 child.getName is not a function</span></span><br></pre></td></tr></table></figure></li><li><p>组合继承<br>缺点：父类函数会多次执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;parent3&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第二次调用 Parent3()</span></span><br><span class="line">  Parent3.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;child3&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次调用 Parent3()</span></span><br><span class="line"></span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s3.play, s4.play); <span class="comment">// 不互相影响</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s3.getName()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s4.getName()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>原型式继承<br>缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent4 = &#123;</span><br><span class="line">  name: <span class="string">&quot;parent4&quot;</span>,</span><br><span class="line"></span><br><span class="line">  friends: [<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line"></span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person4 = <span class="built_in">Object</span>.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">person4.friends.push(<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person5 = <span class="built_in">Object</span>.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person4.name);</span><br><span class="line"><span class="comment">// tom</span></span><br><span class="line"><span class="built_in">console</span>.log(person4.name === person4.getName());</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.name);</span><br><span class="line"><span class="comment">// parent4</span></span><br><span class="line"><span class="built_in">console</span>.log(person4.friends);</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.friends);</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p>寄生式继承</p></li><li><p>寄生组合继承<br>寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">    child.prototype = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;parent6&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent6.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent6.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.friends = <span class="string">&quot;child5&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line">Child6.prototype.getFriends = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.friends;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person6 = <span class="keyword">new</span> Child6();</span><br><span class="line"><span class="built_in">console</span>.log(person6);</span><br><span class="line"><span class="built_in">console</span>.log(person6.getName());</span><br><span class="line"><span class="built_in">console</span>.log(person6.getFriends());</span><br></pre></td></tr></table></figure></li></ul><h2 id="js-原型链"><a href="#js-原型链" class="headerlink" title="js 原型链"></a>js 原型链</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="js原型链"></p><ul><li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code> 该属性指向原型。该属性的值是一个堆内存，堆内存中默认自带一个属性<code>constructor</code>,值是函数本身。</li><li>每个对象都有 <code>__proto__</code>属性，指向了创建该对象的构造函数的原型。</li><li>对象可以通过 <code>__proto__</code>来寻找不属于该对象的属性， <code>__proto__</code> 将对象连接起来组成了原型链。</li></ul><h2 id="定时器为什么不是精确的"><a href="#定时器为什么不是精确的" class="headerlink" title="定时器为什么不是精确的"></a>定时器为什么不是精确的</h2><ul><li>操作系统的计时器本身就有偏差，js的计时器最终调用的还是操作系统的函数，</li><li>按照W3Ｃ的标准，浏览器实现计时器时　嵌套超过５层，则带有４毫秒的最少时间，这样在计时时间少于４毫秒时带来偏差</li><li>受事件循环的影响，计时器任务只有在主线程空闲的时候才能执行</li></ul><h2 id="JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？"><a href="#JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？" class="headerlink" title="JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？"></a>JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</h2><ul><li>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条</li><li>offsetHeight：表示元素的高度，包含了 border 和滚动条</li><li>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分</li><li>clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</li><li>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</li></ul><p><a href="https://blog.csdn.net/weixin_43655631/article/details/98093345">各种位置</a></p><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别?"></a>箭头函数和普通函数的区别?</h2><ul><li><p>箭头函数没有自己的 this，只能通过作用域链来向上查找离自己最近的那个函数的 this</p></li><li><p>箭头函数不能作为 constructor，因此不能通过 new 来调用，所以它并没用 new.target 这个属性</p></li><li><p>箭头函数没有原型prototype</p></li><li><p>箭头函数没有 argument 属性，可以通过 rest 可以获取</p></li><li><p>箭头函数不能直接使用 call 和 apply，bind 来改变 this</p></li><li><p>箭头函数不能使用 yield，不能作为 generator 函数</p></li><li><p>箭头函数语法比普通函数更加简洁</p></li><li><p>ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数或构造方法。如果构造函数不是通过 new 命令或 Reflect.construct()调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数时怎样调用的。包括 super 也不存在以及原型 prototype —- 因为在执行 new 的时候需要将函数的原型赋值给实力对象的原型属性。</p></li></ul><h2 id="Generator函数-生成器函数与普通函数的区别"><a href="#Generator函数-生成器函数与普通函数的区别" class="headerlink" title="Generator函数 生成器函数与普通函数的区别"></a>Generator函数 生成器函数与普通函数的区别</h2><ul><li>函数特征：关键字function与函数名之间有*，函数体内部yeild关键字</li><li>函数调用后不执行，而是返回一个指针对象（遍历器对象）。调用对象的next()方法，执行一段yield逻辑。故函数的分段执行的，yield是暂停执行的标志，next()可以恢复执行。</li><li>yield与return的区别：yield有记忆功能，return没有；一个函数可以多次执行yeild，但只会return一次</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因</p><ul><li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li><li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li><li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li><li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li></ul><h2 id="TypeScript-里面有哪些-JavaScript-没有的类型"><a href="#TypeScript-里面有哪些-JavaScript-没有的类型" class="headerlink" title="TypeScript 里面有哪些 JavaScript 没有的类型?"></a>TypeScript 里面有哪些 JavaScript 没有的类型?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">相比较JavaScript，TypeScript独有的类型</span><br><span class="line">any</span><br><span class="line">声明为any的变量可以赋予任意类型的值</span><br><span class="line"></span><br><span class="line">tuple</span><br><span class="line">元组类型用来表示已知元素数量和类型的数组，个元素的类型不必相同，对应位置的类型需要一样</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line">x = [‘string’, <span class="number">0</span>]; <span class="comment">// 正常</span></span><br><span class="line">x = [<span class="number">0</span>, ‘string’]; <span class="comment">// 报错</span></span><br><span class="line">enum</span><br><span class="line">枚举类型用于定义值集合</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="built_in">console</span>.log©; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">void</span> 标识方法返回值的类型，表示方法没有返回值。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br><span class="line">never</span><br><span class="line">never是其它类型(包括<span class="literal">null</span>和<span class="literal">undefined</span>)的子类型，是不会发生的类型。例如，never总是抛出异常或永不返回的异常的函数表达式的返回类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 never 的函数终点不可达</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回类型是 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> error(‘Something failed’);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 never 的函数终点不可达</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">unknown 未知类型，一般在使用后再手动转具体的类型</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line"></span><br><span class="line">联合类型，多种类型之一</span><br><span class="line"></span><br><span class="line">string | number; <span class="comment">// string 或 number</span></span><br><span class="line">intersection</span><br><span class="line">交叉类型，多种类型合并</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">a</span>: string; &#125; &amp; &#123; <span class="attr">b</span>: number; &#125; <span class="comment">// =&gt; &#123; a: string; b: number &#125;</span></span><br><span class="line">Generics</span><br><span class="line">泛型</span><br><span class="line"></span><br><span class="line">interface Backpack &#123;</span><br><span class="line">add: <span class="function">(<span class="params">obj: T</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">get: <span class="function">() =&gt;</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对-URL-进行编码-解码的实现方式"><a href="#对-URL-进行编码-解码的实现方式" class="headerlink" title="对 URL 进行编码/解码的实现方式"></a>对 URL 进行编码/解码的实现方式</h2><ul><li>：escape 和 unescape:<br>escape()不能直接用于 URL 编码，它的真正作用是返回一个字符的 Unicode 编码值<br>除了 ASCII 字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码。在 u0000 到 u00ff 之间的符号被转成%xx 的形式，其余符号被转成%uxxxx 的形式。对应的解码函数是 unescape()。</li><li>：encodeURL 和 decodeURL：<br>encodeURI()是 Javascript 中真正用来对 URL 编码的函数。<br>它用于对 URL 的组成部分进行个别编码，除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的 utf-8 形式，并且在每个字节前加上%。<br>它对应的解码函数是 decodeURI()</li><li>：encodeURLComponent 和 decodeURLComponent:<br>与 encodeURI()的区别是，它用于对整个 URL 进行编码。”; / ? : @ &amp; = + $ , #”，这些在 encodeURI()中不被编码的符号，在 encodeURIComponent()中统统会被编码。<br>它对应的解码函数是 decodeURIComponent()</li></ul><h2 id="严格模式-与非严格模式区别"><a href="#严格模式-与非严格模式区别" class="headerlink" title="严格模式 与非严格模式区别"></a>严格模式 与非严格模式区别</h2><ul><li>禁用 with 语法，使用将报错</li><li>禁止用 delete 删除显示声明的标识符 变量和函数 eval arguments</li><li>给不允许扩展的 object 增加属性会报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line">obj.b = <span class="number">2</span>; <span class="comment">// 严格模式下会报错;非严格模式不会报错，但也不会生效 &#x27;b&#x27; in obj 为false</span></span><br></pre></td></tr></table></figure><ul><li>给未申明的变量赋值会报错</li><li>函数形参重复时会报错</li><li>对象字面量不能存在相同的属性名</li><li>不能声明或重写 eval 和 arguments 这两个标识</li><li>禁止用 0 前缀声明的八进制字面量</li><li>在代码中使用一些扩展的保留字</li><li>禁用 caller 与 callee</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller, fn.caller); <span class="comment">// 严格模式下报错；非严格模式指向fn2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee); <span class="comment">// 严格模式报错；非严格模式指向fn</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure><h2 id="es5和es6的继承有什么区别"><a href="#es5和es6的继承有什么区别" class="headerlink" title="es5和es6的继承有什么区别"></a>es5和es6的继承有什么区别</h2><ul><li>ES5的继承时通过prototype或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）</li><li>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。</li><li>ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错</li></ul><h2 id="es6-calss-同时有prototype属性和-proto-属性"><a href="#es6-calss-同时有prototype属性和-proto-属性" class="headerlink" title="es6  calss 同时有prototype属性和__proto__属性"></a>es6  calss 同时有prototype属性和__proto__属性</h2><ul><li>大多数浏览器的ES5中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为语法糖，同时有prototype属性和__proto__属性，因此存在两条继承链</li><li>（1）子类的__proto__属性，表示构造函数的继承，总是指向父类</li><li>（2）子类的prototype属性的__proto__属性表示方法的继承，总是指向父类的prototype属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="ES6-super-指向问题"><a href="#ES6-super-指向问题" class="headerlink" title="ES6 super 指向问题"></a>ES6 super 指向问题</h2><ul><li>在类的构造方法中 super()，super 指向父类的构造器，this 指向 new 创建的实例</li><li>在普通的原型方法，和构造函数中作为对象使用 super.xxx, super 指向父类原型对象；this 指向新创建的实例</li><li>静态方法中 super.xxx，super 指向父类， this 指向当前类；</li></ul><h2 id="JSON-stringify-使用注意事项"><a href="#JSON-stringify-使用注意事项" class="headerlink" title="JSON.stringify 使用注意事项"></a>JSON.stringify 使用注意事项</h2><ul><li>转换属性值中有 toJSON 方法，慎用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toJSON</span></span><br><span class="line"><span class="keyword">let</span> toJsonMyIntro = &#123;</span><br><span class="line">  name: <span class="string">&quot;Gopal&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  like: <span class="string">&quot;FE&quot;</span>,</span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;前端&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(toJsonMyIntro)); <span class="comment">// &quot;前端&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>被转换值中有 undefined、任意的函数以及 symbol 值，慎用</p><p>1 一种是数组对象，undefined、任意的函数以及 symbol 值会被转换成 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">undefined</span>, <span class="built_in">Object</span>, <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>)]);</span><br><span class="line"><span class="comment">// &#x27;[null,null,null]&#x27;</span></span><br></pre></td></tr></table></figure><p>2 一种是非数组对象，在序列化的过程中会被忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="built_in">Object</span>, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>) &#125;);</span><br><span class="line"><span class="comment">// &#x27;&#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>包含循环引用的对象，慎用</p></li><li><p>以 symbol 为属性键的属性，慎用,所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。</p></li><li><p>值为 NaN 和 Infinity，慎用 数组的值，或者非数组对象属性值为 NaN 和 Infinity 的，会被转换成 null</p></li><li><p>具有不可枚举的属性值时，慎用 不可枚举的属性默认会被忽略：</p></li></ul><h2 id="Object-keys-的顺序问题及参数解析"><a href="#Object-keys-的顺序问题及参数解析" class="headerlink" title="Object.keys()的顺序问题及参数解析"></a>Object.keys()的顺序问题及参数解析</h2><ul><li>如果属性名的类型是 Number(整数) 或者是 String(整数)，那么 Object.keys 返回值是按照 key 从小到大排序</li><li>如果属性名的类型是 String，浮点数，那么 Object.keys 返回值是按照属性被创建的时间升序排序。</li><li>如果属性名的类型是 Symbol，那么逻辑同 String 相同</li></ul><h2 id="axios-与-fetch-的区别"><a href="#axios-与-fetch-的区别" class="headerlink" title="axios 与 fetch 的区别"></a>axios 与 fetch 的区别</h2><p>Axios:</p><ol><li>从浏览器中创建 XMLHttpRequest</li><li>支持 Promise API</li><li>客户端支持防止 CSRF</li><li>提供了一些并发请求的接口（重要，方便了很多的操作）</li></ol><p>Fetch</p><ol><li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li><li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>fetch 没有办法原生监测请求的进度，而 XHR 可以</li></ol><h2 id="函数提升和变量提升优先级哪个高"><a href="#函数提升和变量提升优先级哪个高" class="headerlink" title="函数提升和变量提升优先级哪个高"></a>函数提升和变量提升优先级哪个高</h2><ul><li>函数提升，函数提升优先级高于变量提升</li><li>变量提升，变量提升不会覆盖（同名）函数提升，只有变量再次赋值时，才会被覆盖</li></ul><h2 id="ES6-中共有五种针对对象遍历的方法"><a href="#ES6-中共有五种针对对象遍历的方法" class="headerlink" title="ES6 中共有五种针对对象遍历的方法"></a>ES6 中共有五种针对对象遍历的方法</h2><ul><li>for in<br>for in 循环遍历对象自身的和继承的可枚举的属性（不含 Symbol 属性）</li><li>Object.keys(obj)<br>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）</li><li>Object.getOwnPropertyNames(obj)<br>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但包括不可枚举属性）</li><li>Object.getOwnPropertySymbols(obj)<br>返回一个数组，包含对象自身所有的 Symbol 属性</li><li>Reflect.ownKeys(obj)<br>返回一个数组，包含对象自身的所有属性，不论属性名是 Symbol 或字符串，也不管是否可枚举。</li></ul><h2 id="如何理解-JS-的异步？"><a href="#如何理解-JS-的异步？" class="headerlink" title="如何理解 JS 的异步？"></a>如何理解 JS 的异步？</h2><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行</p><h2 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a>EventLoop 事件循环</h2><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p><p>任务没有优先级，在消息队列中先进先出</p><p>但<strong>消息队列是有优先级的</strong></p><p>根据 W3C 的最新解释:</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li></ul><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p></blockquote><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>微队列：用户存放需要最快执行的任务，优先级「最高」</li></ul><p>JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h3 id="浏览器中的事件环（Event-Loop"><a href="#浏览器中的事件环（Event-Loop" class="headerlink" title="浏览器中的事件环（Event Loop)"></a><strong>浏览器中的事件环（Event Loop)</strong></h3><p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><ul><li><p>eventLoop 是由JS的宿主环境（浏览器）来实现的；</p></li><li><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="事件循环流程"></p></li><li><p>浏览器中的任务源(task):</p><ul><li><code>宏任务(macrotask)</code>：<br>  宿主环境提供的，比如浏览器<br>  ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</li><li><code>微任务(microtask)</code>：<br>  语言本身提供的，比如promise.then<br>  then、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li></ul></li></ul><p>传送门 ☞ <a href="https://juejin.cn/post/7001881781125251086" title="https://juejin.cn/post/7001881781125251086"># 宏任务和微任务</a></p><h3 id="Node-环境中的事件环（Event-Loop"><a href="#Node-环境中的事件环（Event-Loop" class="headerlink" title="Node 环境中的事件环（Event Loop)"></a><strong>Node 环境中的事件环（Event Loop)</strong></h3><p><code>Node</code>是基于V8引擎的运行在服务端的<code>JavaScript</code>运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一些I/O，比如新的网络连接等，所以Node的Event Loop(事件环机制)与浏览器的是不太一样。<br>event loop 每一次循环都要执行这6个阶段。每个阶段都有自己的callback队列，每当进入某个阶段，都会从所属的队列中取出callback来执行，当队列为空或者被执行callback的数量达到系统的最大数量时候，进入下一阶段。这六个阶段都被执行完毕之后被称为一个循环</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="2020120317343116.png"> 执行顺序如下：</p><ul><li><p><code>timers</code>: 计时器，执行setTimeout和setInterval的回调</p></li><li><p><code>pending callbacks</code>: 执行延迟到下一个循环迭代的 I/O 回调</p></li><li><p><code>idle, prepare</code>: 队列的移动，仅系统内部使用</p></li><li><p><code>poll轮询</code>: 检索新的 I/O 事件;执行与 I/O 相关的回调。回到 timer 阶段执⾏回调<br>并且在进⼊该阶段时如果没有设定了 timer 的话，会发⽣以下两件事情</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执⾏，直到队列为空或者达到系统限制</li><li>如果 poll 队列为空时，会有两件事发⽣<br>  1 如果有 setImmediate 回调需要执⾏，poll 阶段会停⽌并且进⼊到 check 阶段执⾏回调<br>  2如果没有 setImmediate 回调需要执⾏，会等待回调被加⼊到队列中并⽴即执⾏回调，这⾥同样会有个超时时间设置防⽌⼀直等待下去</li></ul></li><li><p><code>check</code>: 执行<code>setImmediate</code>回调，setImmediate在这里执行</p></li><li><p><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，一些关闭的回调函数，如：socket.on(‘close’, …)</p></li></ul><h2 id="js事件机制"><a href="#js事件机制" class="headerlink" title="js事件机制"></a>js事件机制</h2><h3 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h3><p>事件触发有三个阶段：</p><ul><li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发 （捕获）</li><li>传播到事件触发处时触发注册的事件 （目标阶段）</li><li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发 （冒泡）</li></ul><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个 <code>body</code> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p><ul><li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li><li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li><li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li></ul><p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    event.stopImmediatePropagation()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话<strong>应该注册在父节点上</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#ul&#x27;</span>)</span></span><br><span class="line"><span class="javascript"> ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(event.target);</span></span><br><span class="line"> &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件代理的方式相较于直接给目标注册事件来说，有以下优点：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2> <div class="pdf-container" data-target="./渲染页面.pdf" data-height="500px"></div><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p><h2 id="js-编程范式"><a href="#js-编程范式" class="headerlink" title="js 编程范式"></a>js 编程范式</h2><ul><li>命令式（Imperative JavaScript）命令式就是简单的从上而下完成任务，流水账过程式编码风格：</li><li>面向对象（Object-Oriented JavaScript）</li><li>函数式<ul><li>函数式编程是一种强调以函数使用为主的软件开发风格；</li><li>纯函数指没有副作用的函数，相同的输入有相同的输出；</li><li>在函数式编程里面，将多个不同函数组合是一个非常非常非常重要的思想；</li><li>函数式编程将函数视为积木，通过一些高阶函数来提高代码的模块化和可重用性</li></ul></li></ul><p><a href="hanshushi.png">函数式</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM&amp;BOM面试题</title>
      <link href="2020/10/29/DOM&amp;BOM%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/DOM&amp;BOM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM&amp;BOM面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题集</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9C%A8%E7%BA%BF/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9C%A8%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题集"><a href="#面试题集" class="headerlink" title="面试题集"></a>面试题集</h2><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&mid=2650081252&idx=1&sn=1fedc422a3806fa1f9c3faf31bb2a20b&chksm=83db9a81b4ac1397132de99ebdbdbdad57dcc6785d0b8fe1a5ee2b57dbb960b0fbf65015c3ca&scene=126&sessionid=1603760808&key=54ce6b15dc70fa94e4cee849718a95dcb45463880bfbf73a52f6e49f4e4a65fb8adec9e1c54df8bf81bfa1d78626a8537229cc36083224e425c795f892103475ca5f06542d47eec5dabc5d55c77dc7f9fabc4524bbc83cf94060d9236d1061a0fa026db04b47ae38fdfd65662df5549a11d6cd60ff371f5492081a022254d0e7&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AXrZ8Ft8M/kmfXMdRQOHyYs=&pass_ticket=Kkp6C7aNRW+SS3CyH29rTpuzIryrfuzR2BkuJOMPRmZ73lUqRYKqbJR1nz5SlRhp&wx_header=0">面试题 1</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247486750&idx=1&sn=d7e13a8393b83ac330d9b48690428c0e&chksm=fa2bedf7cd5c64e19fcafbe4dab742b65cfe168ad567f3f799b5fc229a35710eb4164084897c&scene=126&sessionid=1602725812&key=6664ac14267ba66883c13581e1d9e62b3ffc7ddfc44d1984c762bde82d19131986d5d9af50595ab1d798e16e45eddd68ded75929bfc6217a87ec0dcacb393b0aa10b53bcd066f65c7865905a425d129f9f1f110464e3a8faa5601a1b7a192f46240134dd033c0bacd43e93b0b51701140f106a0a52acfaabf76e8fee9f2cae06&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=Adc0WAca8bFpyYT3RtaxAjo=&pass_ticket=gNZw604QfgMyZ5MfqQB17Zb9G0KO/y/Gpe3+UhEBieJBkyQwt1xU8LnZyQLLT598&wx_header=0">面试题 2</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NTk2NzUxNg==&mid=2247488674&idx=1&sn=3f5c6af2c52365525aa84ff92b9f865b&chksm=ea941651dde39f4790e96e2d8f2530fa23257afb50de8d40d6d318507b873f9d870c0f507863&mpshare=1&scene=1&srcid=1026yMwvhU6WsEBstdZUyIgl&sharer_sharetime=1603682665969&sharer_shareid=1b2206d548f7c54418de346a0102e46f&key=041bb01ba83758f9c012f304255f853e521afbe7bbf65555a0e068f76f2c433eea39d0413b426b59a870039c71945328b288292bbbbac9811706f2f09f6716c482684831e94eab0b6935f37a6a5c8892d4ca9ecd897e139bf608b85a18e8ee5339e931c56cc60e39443738eeb63253718488c0322710c61a17510cbfa97910cb&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AQ+cZHmGMZ8MBH/qQ1l2YVc=&pass_ticket=L+jndQVDhQl1X8R7c+wxUxrwQN/fivdCt7LVG0oUoik5qA1Gx2ZTiVGm+4shiHQn&wx_header=0">源码面试题</a></p></li><li><p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions">前端开发面试题</a></p></li><li><p><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/">WEB 前端面试宝典</a></p></li><li><p><a href="https://github.com/shfshanyue/blog/blob/master/post/juejin-interview.md">掘金前端面试题合集</a></p></li><li><p><a href="https://yuchengkai.cn/">前端面试图谱</a></p></li><li><p><a href="https://github.com/biaochenxuying/blog/issues/47">前端面试开源项目汇总 | Github 上 100K+ Star 的前端面试开源项目汇总</a></p></li><li><p><a href="https://blog.poetries.top/FE-Interview-Questions/">前端面试常考问题整理 | 按模块和知识点分类</a></p></li><li><p><a href="https://juejin.cn/column/6964717704712290317">2021 前端面试题集</a></p></li><li><p><a href="https://h5bp.org/Front-end-Developer-Interview-Questions/">Front-end Developer Interview Questions</a></p></li><li><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map">CS-Interview-knowledge-Map</a></p></li><li><p><a href="https://github.com/shfshanyue/Daily-Question">Daily-Question</a></p></li><li><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question">Daily-Interview-Question</a></p></li><li><p><a href="https://lucifer.ren/fe-interview">fe-interview 大前端面试宝典</a></p></li><li><p><a href="https://github.com/biaochenxuying/blog/blob/master/interview/fe-interview.md">前端硬核面试专题</a></p></li><li><p><a href="https://leetcode-cn.com/problemset/all">LeetCode 算法试题学习</a></p></li><li><p><a href="https://www.nowcoder.com/">LeetCode 算法试题学习</a></p></li></ul><p>2021面试题<br><a href="http://www.cnblogs.com/penghuwan/p/7194133.html">http://www.cnblogs.com/penghuwan/p/7194133.html</a><br><a href="https://www.zhihu.com/question/60577972">https://www.zhihu.com/question/60577972</a><br><a href="https://zhuanlan.zhihu.com/p/35493203">https://zhuanlan.zhihu.com/p/35493203</a><br><a href="https://juejin.im/post/59ffb4b66fb9a04512385402">https://juejin.im/post/59ffb4b66fb9a04512385402</a><br><a href="https://www.cnblogs.com/fengxiongZz/p/8191503.html">https://www.cnblogs.com/fengxiongZz/p/8191503.html</a><br><a href="https://yuchengkai.cn/docs/zh/frontend/">https://yuchengkai.cn/docs/zh/frontend/</a><br><a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/doctype-and-brower-render.html">https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/doctype-and-brower-render.html</a><br><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers">https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers</a><br><a href="https://github.com/qiu-deqing/FE-interview">https://github.com/qiu-deqing/FE-interview</a><br><a href="https://github.com/FEGuideTeam/FEGuide/blob/master/%E6%A1%86%E6%9E%B6/vue.md">https://github.com/FEGuideTeam/FEGuide/blob/master/%E6%A1%86%E6%9E%B6/vue.md</a><br><a href="https://juejin.im/post/5bc92e9ce51d450e8e777136">https://juejin.im/post/5bc92e9ce51d450e8e777136</a><br><a href="https://juejin.im/post/5c0e68ec6fb9a04a01642925">https://juejin.im/post/5c0e68ec6fb9a04a01642925</a></p><p>2022面试题<br><a href="https://barryyeee.github.io/InterviewGuide/">https://barryyeee.github.io/InterviewGuide/</a><br><a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a><br><a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a><br><a href="https://github.com/azl397985856/leetcode">https://github.com/azl397985856/leetcode</a><br><a href="https://github.com/azl397985856/fe-interview">https://github.com/azl397985856/fe-interview</a><br><a href="https://github.com/jiajunhua/imhuay-Algorithm_Interview_Notes-Chinese">https://github.com/jiajunhua/imhuay-Algorithm_Interview_Notes-Chinese</a><br><a href="https://github.com/WenDesi/lihang_book_algorithm">https://github.com/WenDesi/lihang_book_algorithm</a><br><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July">https://github.com/julycoding/The-Art-Of-Programming-By-July</a><br><a href="https://github.com/helloqingfeng/Awsome-Front-End-learning-resource">https://github.com/helloqingfeng/Awsome-Front-End-learning-resource</a><br><a href="https://github.com/poetries/FE-Interview-Questions">https://github.com/poetries/FE-Interview-Questions</a><br><a href="https://space.bilibili.com/9099840/video">https://space.bilibili.com/9099840/video</a><br><a href="https://jishuin.proginn.com/p/763bfbd23be3">https://jishuin.proginn.com/p/763bfbd23be3</a><br><a href="https://github.com/phodal/fe">https://github.com/phodal/fe</a><br><a href="https://github.com/lefex/FE">https://github.com/lefex/FE</a><br><a href="https://github.com/haizlin/fe-interview">https://github.com/haizlin/fe-interview</a><br><a href="https://github.com/qiu-deqing/FE-interview">https://github.com/qiu-deqing/FE-interview</a><br><a href="https://github.com/lgwebdream/FE-Interview">https://github.com/lgwebdream/FE-Interview</a></p><p>2022年算法知识集合<br><a href="https://leetcode.cn/">https://leetcode.cn/</a><br>Leetcode<br><a href="https://www.gitbook.com/book/siddontang/leetcode-solution/details">https://www.gitbook.com/book/siddontang/leetcode-solution/details</a><br>LeetCode题解<br><a href="https://zhuanlan.zhihu.com/p/38005681">https://zhuanlan.zhihu.com/p/38005681</a><br>如何高效使用 LeetCode<br><a href="https://www.zhihu.com/question/280279208/">https://www.zhihu.com/question/280279208/</a><br>大家都是如何刷 LeetCode 的？<br><a href="https://github.com/MisterBooo/LeetCodeAnimation">https://github.com/MisterBooo/LeetCodeAnimation</a><br>用动画的形式呈现解LeetCode题目的思路<br><a href="https://programmercarl.com/">https://programmercarl.com/</a><br>代码随想录<br><a href="https://labuladong.github.io/algo/">https://labuladong.github.io/algo/</a><br>LABULADONG 的算法网站</p> <div class="pdf-container" data-target="./前端面试题整合.pdf" data-height="500px"></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="在CSS中，有继承性的属性主几种"><a href="#在CSS中，有继承性的属性主几种" class="headerlink" title="在CSS中，有继承性的属性主几种"></a>在CSS中，有继承性的属性主几种</h2><ul><li>字体系列属性<ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul></li><li>文本系列属性<ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul></li><li>元素可见性<ul><li>visibility：控制元素显示隐藏</li></ul></li><li>列表布局属性<ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul></li><li>光标属性</li><li>cursor：光标显示为何种形态</li></ul><h2 id="你不知道的-CSS-之包含块"><a href="#你不知道的-CSS-之包含块" class="headerlink" title="你不知道的 CSS 之包含块"></a>你不知道的 CSS 之包含块</h2><p>包含块英语全称为<strong>containing block</strong>，书写 CSS 时，大多数情况下你是感受不到它的存在;但这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：*<a href="https://drafts.csswg.org/css2/#containing-block-details">https://drafts.csswg.org/css2/#containing-block-details</a>*<br><strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png" alt="image-20220814223451349" style="zoom: 33%;"><p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p><p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p><p>这个答案实际上是不准确的。正确的答案应该是，<strong>div.item 的宽高是根据它的包含块来计算的</strong>，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p><p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p><p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p><p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p><ul><li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</li><li>如果 position 属性是 fixed，那么包含块由视口建立。</li><li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li></ul><p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p><p>公布正确答案：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png" alt="image-20220814233548188" style="zoom: 33%;"><p>怎么样？有没有和你所想象的对上？</p><p>其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。</p><p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。</p><p>实际上对于非根元素来讲，包含块还有一种可能，<code>那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</code></p><ul><li>transform 或 perspective 的值不是 none</li><li>will-change 的值是 transform 或 perspective</li><li>filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效).</li><li>contain 的值是 paint (例如: contain: paint;)</li></ul><p>我们还是来看一个示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>); <span class="comment">/* 新增代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png" alt="image-20220814234347149" style="zoom:33%;"><p>可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。</p><p>关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p><p>具体你可以移步到：*<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</a>*</p><h2 id="CSS属性计算过程"><a href="#CSS属性计算过程" class="headerlink" title="CSS属性计算过程"></a>CSS属性计算过程</h2><p>假设在 HTML 中有这么一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码也非常简单，就是在 body 中有一个 h1 标题而已，该 h1 标题呈现出来的外观是如下：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060724.png" alt="image-20220813140724136" style="zoom:50%;"><p>目前我们没有设置该 h1 的任何样式，但是却能看到该 h1 有一定的默认样式，例如有默认的字体大小、默认的颜色。</p><p>那么问题来了，我们这个 h1 元素上面除了有默认字体大小、默认颜色等属性以外，究竟还有哪些属性呢？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014216.png" alt="image-20220815094215982" style="zoom:30%;"><p>答案是<strong>该元素上面会有 CSS 所有的属性。</strong>你可以打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此 h1 上面所有 CSS 属性对应的值。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-061516.png" alt="image-20220813141516153"></p><p>换句话说，<strong>我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式</strong>。这一点往往是让初学者比较意外的，因为我们平时在书写 CSS 样式时，往往只会书写必要的部分，例如前面的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这往往会给我们造成一种错觉，认为该 p 元素上面就只有 color 属性。而真实的情况确是，任何一个 HTML 元素，都有一套完整的 CSS 样式，只不过你没有书写的样式，<strong>大概率可能</strong>会使用其默认值。例如上图中 h1 一个样式都没有设置，全部都用的默认值。</p><p>但是注意，我这里强调的是“大概率可能”，难道还有我们“没有设置值，但是不使用默认值”的情况么？</p><p>嗯，确实有的，所以我才强调你要了解“CSS 属性的计算过程”。<br><code>属性值的计算过程</code>，分为如下这么 <em>4</em> 个步骤：</p><ul><li>确定声明值</li><li>层叠冲突</li><li>使用继承</li><li>使用默认值</li></ul><h3 id="确定声明值"><a href="#确定声明值" class="headerlink" title="确定声明值"></a>确定声明值</h3><p>首先第一步，是确定声明值。所谓声明值就是作者自己所书写的 CSS 样式，例如前面的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们声明了 p 元素为红色，那么就会应用此属性设置。</p><p>当然，除了作者样式表，一般浏览器还会存在“用户代理样式表”，简单来讲就是浏览器内置了一套样式表。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-063500.png" alt="image-20220813143500066"></p><p>在上面的示例中，作者样式表中设置了 color 属性，而用户代理样式表（浏览器提供的样式表）中设置了诸如 display、margin-block-start、margin-block-end、margin-inline-start、margin-inline-end 等属性对应的值。</p><p>这些值目前来讲也没有什么冲突，因此最终就会应用这些属性值。</p><h3 id="层叠冲突"><a href="#层叠冲突" class="headerlink" title="层叠冲突"></a>层叠冲突</h3><p>在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。</p><p>此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤：</p><ul><li>比较源的重要性</li><li>比较优先级</li><li>比较次序</li></ul><p>来来来，我们一步一步来看。</p><h4 id="比较源的重要性"><a href="#比较源的重要性" class="headerlink" title="比较源的重要性"></a>比较源的重要性</h4><p>当不同的 CSS 样式来源拥有相同的声明时，此时就会根据样式表来源的重要性来确定应用哪一条样式规则。</p><p>那么问题来了，咱们的样式表的源究竟有几种呢？</p><p>整体来讲有三种来源：</p><ul><li>浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称<strong>用户代理样式</strong>。</li><li>网页的作者可以定义文档的样式，这是最常见的样式表，称之为<strong>页面作者样式</strong>。</li><li>浏览器的用户，可以使用自定义样式表定制使用体验，称之为<strong>用户样式</strong>。</li></ul><p>对应的重要性顺序依次为：页面作者样式 &gt; 用户样式 &gt; 用户代理样式</p><p>更详细的来源重要性比较，可以参阅 <em>MDN</em>：*<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade</a>*</p><p>我们来看一个示例。</p><p>例如现在有<strong>页面作者样式表</strong>和<strong>用户代理样式表</strong>中存在属性的冲突，那么会以作者样式表优先。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color </span>: red;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-064222.png" alt="image-20220813144222152"></p><p>可以明显的看到，作者样式表和用户代理样式表中同时存在的 display 属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。</p><h4 id="比较优先级"><a href="#比较优先级" class="headerlink" title="比较优先级"></a>比较优先级</h4><p>那么接下来，如果是在在同一个源中有样式声明冲突怎么办呢？此时就会进行样式声明的优先级比较。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span> <span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，同属于<strong>页面作者样式</strong>，源的重要性是相同的，此时会以选择器的权重来比较重要性。</p><p>很明显，上面的选择器的权重要大于下面的选择器，因此最终标题呈现为 <em>50px</em>。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-071546.png" alt="image-20210916151546500" style="zoom: 40%;"><p>可以看到，落败的作者样式在 <em>Elements&gt;Styles</em> 中会被划掉。</p><p>有关选择器权重的计算方式，不清楚的同学，可以进入此传送门：*<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity">https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity</a>*</p><h4 id="比较次序"><a href="#比较次序" class="headerlink" title="比较次序"></a>比较次序</h4><p>经历了上面两个步骤，大多数的样式声明能够被确定下来。但是还剩下最后一种情况，那就是样式声明既是同源，权重也相同。</p><p>此时就会进入第三个步骤，比较样式声明的次序。</p><p>举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，同样都是<strong>页面作者样式</strong>，<strong>选择器的权重也相同</strong>，此时位于下面的样式声明会层叠掉上面的那一条样式声明，最终会应用 <em>20px</em> 这一条属性值。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-103928.png" alt="image-20220823183928330"></p><p>至此，样式声明中存在冲突的所有情况，就全部被解决了。</p><h3 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h3><p>层叠冲突这一步完成后，解决了相同元素被声明了多条样式规则究竟应用哪一条样式规则的问题。</p><p>那么如果没有声明的属性呢？此时就使用默认值么？</p><p><em>No、No、No</em>，别急，此时还有第三个步骤，那就是使用继承而来的值。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们针对 div 设置了 color 属性值为红色，而针对 p 元素我们没有声明任何的属性，但是由于 color 是可以继承的，因此 p 元素从最近的 div 身上继承到了 color 属性的值。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065102.png" alt="image-20220813145102293"></p><p>这里有两个点需要同学们注意一下。</p><p>首先第一个是我强调了是<strong>最近的</strong> div 元素，看下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065653.png" alt="image-20220813145652726"></p><p>因为这里并不涉及到选中 p 元素声明 color 值，而是从父元素上面继承到 color 对应的值，因此这里是<strong>谁近就听谁</strong>的，初学者往往会产生混淆，又去比较权重，但是这里根本不会涉及到权重比较，因为压根儿就没有选中到 p 元素。</p><p>第二个就是哪些属性能够继承？</p><p>关于这一点的话，大家可以在 MDN 上面很轻松的查阅到。例如我们以 text-align 为例，如下图所示：</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070148.png" alt="image-20220813150147885"></p><h3 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h3><p>好了，目前走到这一步，如果属性值都还不能确定下来，那么就只能是使用默认值了。</p><p>如下图所示：</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070825.png" alt="image-20220813150824752"></p><p>前面我们也说过，一个 HTML 元素要在浏览器中渲染出来，必须具备所有的 CSS 属性值，但是绝大部分我们是不会去设置的，用户代理样式表里面也不会去设置，也无法从继承拿到，因此最终都是用默认值。</p><h2 id="如何理解BFC"><a href="#如何理解BFC" class="headerlink" title="如何理解BFC"></a>如何理解BFC</h2><p>Box:Box 是 CSS 布局的对象和基本单位，一个页面是由很多个 Box 组成的，这个 Box 就是我们常说的盒模型<br>Block Formatting Cotext:块级上下文格式化，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位以及和其他元素的关系和相互作用<br>块级格式化上下文(Block Formatting Cotext，BFC)是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。<br>通俗来讲：BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并不会影响其他环境中的物品。如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响</p><p>创建 BFC 的条件<br>根元素：Body；</p><p>元素设置浮动：float 除 none 以外的值；</p><p>元素设置绝对定位：position（absolute、fixed）；</p><p>display 值为：inline-block、table-cell、table-caption、flex 等</p><p>overflow 值为：hidden、auto、scroll</p><p>BFC 的特点：<br>垂直方向，自上而下排列，和文档流的排列方式一直<br>在 BFC 中上下相邻的两个容器的 margin 会重叠<br>计算 BFC 的高度时，需要计算浮动元素的高度<br>BFC 区域不会与浮动的容器发生重叠<br>BFC 是独立的容器，容器内部元素不会影响外部元素<br>每个元素的左 margin 值和容器的左 border 相接触</p><p>BFC 的作用<br>解决margin的重叠问题：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。</p><p>解决高度塌陷的问题：在对子元素设置浮动之后，父元素会发生高度塌陷，也就是父元素的高度为 0，解决这个问题，只需要把父元素变成一个 BFC。常用的办法是给父元素设置overflow：hidden。</p><p>创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background</span>: red;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line"><span class="attribute">background</span>:blue;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左侧设置float：left，右侧设置overflow：hidden。这样右边就触发BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现自适应两栏布局 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/htm%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/htm%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http网落协议面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="请求在客户端报-413-是什么错误-怎么解决呢"><a href="#请求在客户端报-413-是什么错误-怎么解决呢" class="headerlink" title="请求在客户端报 413 是什么错误,怎么解决呢?"></a>请求在客户端报 413 是什么错误,怎么解决呢?</h2><ul><li>HTTP 413 错误(Request entity too large 请求实体太大)，就是客户端发送的实体主体部分比服务器能够或者希望处理的要大时，会出现这样的错误。一般上传文件时会出现这样的错误概率比较大。<br>解决方案可以修改服务器的配置文件。配置客户端请求大小和缓存大小</li></ul><h2 id="quic-基-于-udp-怎-么-保-证-可-靠-性"><a href="#quic-基-于-udp-怎-么-保-证-可-靠-性" class="headerlink" title="quic 基 于 udp 怎 么 保 证 可 靠 性"></a>quic 基 于 udp 怎 么 保 证 可 靠 性</h2><h2 id="讲-一-下-同-源-策-略-和-跨-域-方-案-？-CORS-的-几-个-头-部-是-什-么-？"><a href="#讲-一-下-同-源-策-略-和-跨-域-方-案-？-CORS-的-几-个-头-部-是-什-么-？" class="headerlink" title="讲 一 下 同 源 策 略 和 跨 域 方 案 ？ CORS 的 几 个 头 部 是 什 么 ？"></a>讲 一 下 同 源 策 略 和 跨 域 方 案 ？ CORS 的 几 个 头 部 是 什 么 ？</h2><h2 id="grpc-相-比-http-的-优-势-？"><a href="#grpc-相-比-http-的-优-势-？" class="headerlink" title="grpc 相 比 http 的 优 势 ？"></a>grpc 相 比 http 的 优 势 ？</h2><h2 id="http-和-https-的基本概念"><a href="#http-和-https-的基本概念" class="headerlink" title="http 和 https 的基本概念"></a>http 和 https 的基本概念</h2><p>http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。<br>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p><h2 id="http-和-https-的区别及优缺点？"><a href="#http-和-https-的区别及优缺点？" class="headerlink" title="http 和 https 的区别及优缺点？"></a>http 和 https 的区别及优缺点？</h2><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li><li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li><li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高。</li><li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><a id="more"></a><h2 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h2><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li><li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li><li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li><li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol><p>传送门 ☞ <a href="https://juejin.cn/post/6995109407545622542"># 解读 HTTP1/HTTP2/HTTP3</a></p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ol><li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack=j+1），<code>同时也发送一个自己的SYN包</code>（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><blockquote><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p></blockquote><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><ol><li><p><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<code>客户端进入FIN-WAIT-1（终止等待1）状态</code>。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p></li><li><p><code>服务器收到连接释放报文，发出确认报文</code>，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，<code>服务端就进入了CLOSE-WAIT（关闭等待）状态</code>。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p></li><li><p>客户端收到服务器的确认请求后，此时，<code>客户端就进入FIN-WAIT-2（终止等待2）状态</code>，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p></li><li><p><code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，<code>服务器就进入了LAST-ACK（最后确认）状态</code>，等待客户端的确认。</p></li><li><p><code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，<code>客户端就进入了TIME-WAIT（时间等待）状态</code>。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，<code>当客户端撤销相应的TCB后，才进入CLOSED状态</code>。</p></li><li><p>服务器只要收到了客户端发出的确认，<code>立即进入CLOSED状态</code>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，<code>服务器结束TCP连接的时间要比客户端早一些</code>。</p></li></ol><h2 id="TCP-IP-如何保证数据包传输的有序可靠？"><a href="#TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP/IP / 如何保证数据包传输的有序可靠？"></a>TCP/IP / 如何保证数据包传输的有序可靠？</h2><p>对字节流分段并进行编号然后<code>通过 ACK 回复</code>和<code>超时重发</code>这两个机制来保证。</p><p>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；<br>（2）并为每个已发送的数据包启动一个超时定时器；<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。<br>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol><li>TCP是面向<code>链接</code>的，而UDP是面向无连接的。</li><li>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</li></ol><p>传送门 ☞ <a href="https://juejin.cn/post/6992743999756845087" title="https://juejin.cn/post/6992743999756845087"># 深度剖析TCP与UDP的区别</a></p><h2 id="http缓存的理解"><a href="#http缓存的理解" class="headerlink" title="http缓存的理解"></a>http缓存的理解</h2><p><a href="https://juejin.cn/post/6844903763665240072">强缓存和协商缓存</a></p><p>缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。</p><ul><li>浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的 Cache-Control 和 Expires 来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。后面会讲 Cache-Control 和 Expires 相关。</li><li>如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过 If-None-Match 头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将 If-None-Match 的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将 If-None-Match 的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过 If-Modified-Since 头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。</li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p> <a href="https://juejin.cn/post/6992843117963509791">彻底理解浏览器的缓存机制</a></p><ul><li><p>Expires<br>Expires 是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。如我现在这个网页的<br>Expires 值是： expires:Fri, 14 Apr 2017 10:47:02 GMT 。这个时间代表这这个资源的失效时<br>间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方<br>式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会<br>导致缓存混乱。如果同时出现 Cache-Control:max-age 和 Expires ，那么 max-age 优先级更高。如我<br>主页的response headers部分如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  cache-control:max-age=<span class="number">691200</span></span><br><span class="line">expires:Fri, <span class="number">14</span> Apr <span class="number">2017</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">0</span>2 GMT</span><br></pre></td></tr></table></figure></li><li><p>Cache-Control<br>Cache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例<br>如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面<br>几个比较常用的设置值:</p><ul><li><p>no-cache：不使用强缓存。直接使用缓存协商，先与服务器确认返回的响应是否被更改，如果之<br>前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下<br>载。</p></li><li><p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都<br>会下载完整的资源。</p></li><li><p>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</p></li><li><p>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p></li><li><p>Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高</p><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BC%BA%E7%BC%93%E5%AD%98.png" alt="强缓存"></p></li></ul></li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，<br>从而让服务器判断请求资源是否可以缓存访问。</p><p>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，<br>浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，<br>但是直接浏览器访问那个图片或文件，看到的内容却是新的。</p><p>这个主要涉及到两组header字段： Etag 和 If-None-Match 、 Last-Modified 和 If-Modified-Since 。</p><ul><li><p>Etag 和 If-None-Match<br>Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变<br>化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。</p><p>与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response<br>header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p></li><li><p>Last-Modify/If-Modify-Since</p><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间<br>标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p><p>当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-<br>Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。<br>如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。</p></li><li><p>为什么要有Etag<br>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag<br>呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-<br>Modified，最后才决定是否返回304。</p><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="协商缓存"></p></li></ul><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.png" alt="浏览器缓存"></p><h2 id="说下进程、线程和协程"><a href="#说下进程、线程和协程" class="headerlink" title="说下进程、线程和协程"></a>说下进程、线程和协程</h2><p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p><strong>协程</strong>，英文Coroutines，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><h3 id="进程和线程的区别与联系"><a href="#进程和线程的区别与联系" class="headerlink" title="进程和线程的区别与联系"></a>进程和线程的区别与联系</h3><p>【区别】：<br>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；<br>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；<br>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p>【联系】： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；<br>资源分配给进程，同一进程的所有线程共享该进程的所有资源；<br>处理机分给线程，即真正在处理机上运行的是线程；<br>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>传送门 ☞ <a href="https://juejin.cn/post/7005465381791875109" title="https://juejin.cn/post/7005465381791875109"># 一文搞懂进程、线程、协程及JS协程的发展</a> <a href="https://link.juejin.cn/?target=http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml" title="http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml">☞了解更多</a></p><p>关于浏览器传送门 ☞<a href="https://juejin.cn/post/6993095345576083486" title="https://juejin.cn/post/6993095345576083486"># 深入了解现代 Web 浏览器</a></p><h2 id="http1-x-和http2-x区别"><a href="#http1-x-和http2-x区别" class="headerlink" title="http1.x 和http2.x区别"></a>http1.x 和http2.x区别</h2><ul><li>HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。<br>二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示</li><li>HTTP2支持多路复用<br>因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求</li><li>HTTP2头部压缩<br>HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值</li><li>HTTP2支持服务器推送<br>HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容</li></ul><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/http.png" alt="http"><br><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/http2.png" alt="http2"><br><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.png" alt="网络协议"></p><h2 id="浏览器为什么要请求并发数限制"><a href="#浏览器为什么要请求并发数限制" class="headerlink" title="浏览器为什么要请求并发数限制"></a>浏览器为什么要请求并发数限制</h2><ul><li><p>对操作系统端口资源考虑<br>PC的端口总数为 65536<br>一个HTTP请求就会建立一个TCP链接，一个 TCP 链接就会占用一个端口，什么是 TCP 链接<br>[[HTTP协议 与 TCP协议 的区别]]<br>操作系统通常会对总端口一半开放对外请求，以防端口数量不被迅速消耗殆尽</p></li><li><p>过多并发导致频繁切换产生性能问题<br>一个线程对应处理一个 http 请求，那么如果并发数量巨大的话会导致线程频繁切换。而线程的上下文切换有时候并不是轻量级的资源。这导致得不偿失，所以请求控制器里面会产生一个链接池，以复用之前的链接。所以我们可以看作同域名下链接池最大为 4-8 个，如果链接池全部被使用后阻塞后面请求任务，等待有空闲链接时执行后续任务</p><p><a href="https://blog.csdn.net/zsy3757486/article/details/121779679">什么是链接池</a></p></li><li><p>避免同一客户端并发大量请求超过服务端的并发阈值<br>在服务端通常都对同一客户端来源设置并发阈值避免恶意攻击，如果浏览器不对同一域名做并发限制可能会导致超过服务端的并发阈值被 BAN 掉</p></li><li><p>客户端良知机制<br>为了防止两个应用抢占资源时导致强势一方无限制的获取资源导致弱势一方永远阻塞状态</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http网落协议面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/node%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/node%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-run-xxx-的过程"><a href="#npm-run-xxx-的过程" class="headerlink" title="npm run xxx 的过程"></a>npm run xxx 的过程</h2><ul><li>运行 npm run XXX</li><li>npm 先在当前目录 的 node_modules/.bin 查找要执行的程序，如果找到则运行；没有找到 则从全局的 node_modules/.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li><li><a href="https://blog.csdn.net/qq_31967985/article/details/124367380?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1-124367380-blog-125222803.pc_relevant_multi_platform_whitelistv2_exp180w&spm=1001.2101.3001.4242.2&utm_relevant_index=4">npm install 到npm run xxx深度解读</a></li></ul><a id="more"></a><h2 id="bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？"><a href="#bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？" class="headerlink" title=".bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？"></a>.bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？</h2><ul><li>它存在项目最外层的package-lock.json文件中<br>从 package-lock.json 中可知，当我们npm i 整个新建的vue项目的时候，npm 将 bin/vue-cli-service.js 作为 bin 声明了。<br>所以在 npm install 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了</li></ul><h2 id="package-json-与-package-lock-json-的关系"><a href="#package-json-与-package-lock-json-的关系" class="headerlink" title="package.json 与 package-lock.json 的关系"></a>package.json 与 package-lock.json 的关系</h2><p> <a href="https://www.cnblogs.com/yalong/p/15013880.html">package.json 与 package-lock.json 的关系</a></p><h2 id="master挂了了的话pm2怎么处理理"><a href="#master挂了了的话pm2怎么处理理" class="headerlink" title="master挂了了的话pm2怎么处理理"></a>master挂了了的话pm2怎么处理理</h2><h2 id="node-stream"><a href="#node-stream" class="headerlink" title="node stream"></a>node stream</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/node%E9%9D%A2%E8%AF%95%E9%A2%98/node_stream.png" alt="node-stream"><br><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/node%E9%9D%A2%E8%AF%95%E9%A2%98/pm2.png" alt="pm2"></p><h2 id="为什么模块循环依赖不会死循环？CommonJS和ES-Module的处理不同？"><a href="#为什么模块循环依赖不会死循环？CommonJS和ES-Module的处理不同？" class="headerlink" title="为什么模块循环依赖不会死循环？CommonJS和ES Module的处理不同？"></a>为什么模块循环依赖不会死循环？CommonJS和ES Module的处理不同？</h2><p><a href="https://mp.weixin.qq.com/s/t-TUAzL0q0oK7HsDVQRNMw">模块循环依赖</a></p><ul><li><p>CommonJS和ES Module都对循环引入做了处理，不会进入死循环，但方式不同：</p></li><li><p>CommonJS借助模块缓存，遇到require函数会先检查是否有缓存，已经有的则不会进入执行，在模块缓存中还记录着导出的变量的拷贝值；</p><ul><li>ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。</li><li>CommonJS的export和module.export指向同一块内存，但由于最后导出的是module.export，所以不能直接给export赋值，会导致指向丢失。</li></ul></li><li><p>查找模块时，核心模块和文件模块的查找都比较简单，对于react/vue这种第三方模块，会从当前目录下的node_module文件下开始，递归往上查找，找到该包后，根据package.json的main字段找到入口文件。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="有-没-有-做-过-优-化-相-关-的-？-webpack-做-了-哪-些-优-化"><a href="#有-没-有-做-过-优-化-相-关-的-？-webpack-做-了-哪-些-优-化" class="headerlink" title="有 没 有 做 过 优 化 相 关 的 ？ webpack 做 了 哪 些 优 化"></a>有 没 有 做 过 优 化 相 关 的 ？ webpack 做 了 哪 些 优 化</h2><h2 id="cache-loader-和-hard-source-webpack-plugin-的-区-别是-什-么-？"><a href="#cache-loader-和-hard-source-webpack-plugin-的-区-别是-什-么-？" class="headerlink" title="cache-loader 和 hard-source-webpack-plugin 的 区 别是 什 么 ？"></a>cache-loader 和 hard-source-webpack-plugin 的 区 别是 什 么 ？</h2><h2 id="Babel-profill：怎么把-es6-转化为-es5，兼容-ie"><a href="#Babel-profill：怎么把-es6-转化为-es5，兼容-ie" class="headerlink" title="Babel-profill：怎么把 es6 转化为 es5，兼容 ie"></a>Babel-profill：怎么把 es6 转化为 es5，兼容 ie</h2><ul><li><p>Parser 解析<br>第一步主要是将 ES6 语法解析为 AST 抽象语法树。</p></li><li><p>Transformer 转换<br>第二步是将打散的 AST 语法通过配置好的 plugins 和 presets 转换成新的 AST 语法。这一步主要是由 babel-transform 插件完成。plugins 和 presets 通常在 .babelrc 文件中配置。</p></li><li><p>Generator 生成<br>第三步是将新的 AST 语法树对象再生成浏览器都可以识别的 ES5 语法。这一步主要是由 babel-generator 插件完成</p><p>我们写的原始代码、<br>1.–&gt;parse(解析)阶段，通过–&gt;babylon 工具做代码的解析转换为–&gt;AST(抽象语法树)<br>2.–&gt;transform(改变)阶段，<br>通过—&gt;babel-traverse 工具，把代码转为 es5 或 es3，如果 babel 没有达到我们的预期 babel 还提供了很多插件可以继续转换到–&gt;AST 阶段<br>3.AST(抽象语法树)阶段–&gt;<br>通过 plugin 工具处理过滤代码(删除代码、增加代码)，在 AST 语法树上改，改完之后到—&gt;AST 这个树上，到—&gt;generator 阶段，<br>4.—&gt;generator(生成、生产)阶段<br>通过—&gt;babel-generator 工具处理还原代码，变成浏览器所识别的文本到—&gt;code,我们看到的最后编译后的代码</p></li></ul><h2 id="webpack-plugin-的-原-理-是-什-么-？"><a href="#webpack-plugin-的-原-理-是-什-么-？" class="headerlink" title="webpack plugin 的 原 理 是 什 么 ？"></a>webpack plugin 的 原 理 是 什 么 ？</h2><h2 id="plugin-中-有-异-步-请-求-会-阻-塞-后-面-的-plugin-吗-？"><a href="#plugin-中-有-异-步-请-求-会-阻-塞-后-面-的-plugin-吗-？" class="headerlink" title="plugin 中 有 异 步 请 求 会 阻 塞 后 面 的 plugin 吗 ？"></a>plugin 中 有 异 步 请 求 会 阻 塞 后 面 的 plugin 吗 ？</h2><h2 id="webpack-的-性-能-优-化-？"><a href="#webpack-的-性-能-优-化-？" class="headerlink" title="webpack 的 性 能 优 化 ？"></a>webpack 的 性 能 优 化 ？</h2><h2 id="hard-sour-c-e-webpack-plugin-是-怎-么-做-缓-存-的-？-修-改-文-件-后-会怎-么-样-？"><a href="#hard-sour-c-e-webpack-plugin-是-怎-么-做-缓-存-的-？-修-改-文-件-后-会怎-么-样-？" class="headerlink" title="hard-sour c e-webpack-plugin 是 怎 么 做 缓 存 的 ？ 修 改 文 件 后 会怎 么 样 ？"></a>hard-sour c e-webpack-plugin 是 怎 么 做 缓 存 的 ？ 修 改 文 件 后 会怎 么 样 ？</h2><h2 id="parallel-的-原-理-是-什-么-？-多-个-子-进-程-怎-么-通-信-？"><a href="#parallel-的-原-理-是-什-么-？-多-个-子-进-程-怎-么-通-信-？" class="headerlink" title="parallel 的 原 理 是 什 么 ？ 多 个 子 进 程 怎 么 通 信 ？"></a>parallel 的 原 理 是 什 么 ？ 多 个 子 进 程 怎 么 通 信 ？</h2><h2 id="webpack-与-gulp-grunt"><a href="#webpack-与-gulp-grunt" class="headerlink" title="webpack 与 gulp/grunt"></a>webpack 与 gulp/grunt</h2><ul><li>webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案。</li><li>Grunt/Gulp 是非模块化打包工具, 是工具链，可以配合各种插件做 js 压缩，css 压缩，less 编译 替代手工实现自动化工作</li></ul><h2 id="webpack-的核心概念"><a href="#webpack-的核心概念" class="headerlink" title="webpack 的核心概念"></a>webpack 的核心概念</h2><ul><li>Entry：入口，Webpack 进行打包的起始点(文件)</li><li>Output：出口，webpack 编译打包生成的 bundle(文件)</li><li>Loader：模块加载(转换)器，将非 js 模块包装成 webpack 能理解的 js 模块</li><li>Plugin：插件，在 Webpack 构建流程中的特定时机插入具有特定功能的代码</li><li>Module：模块，在 Webpack 眼里一切皆模块，默认只识别 js 文件, 如果是其它类型文件利用对应的 loader 转换为 js 模块</li><li>Chunk/bundle：代码块/束，一个 Chunk 由多个模块组合而成, 最终浏览器执行的是 webpack 打包生成的 chunk 文件</li></ul><h2 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h2><ul><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><h2 id="有哪些常见的Plugin？他们是解决什么问题的？"><a href="#有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Plugin？他们是解决什么问题的？"></a>有哪些常见的Plugin？他们是解决什么问题的？</h2><p>html-webpack-plugin：可以复制一个有结构的html文件，并自动引入打包输出的所有资源（JS/CSS）<br>clean-webpack-plugin：重新打包自动清空 dist 目录<br>mini-css-extract-plugin：提取 js 中的 css 成单独文件<br>optimize-css-assets-webpack-plugin：压缩css<br>uglifyjs-webpack-plugin：压缩js<br>commons-chunk-plugin：提取公共代码</p><h2 id="webpack-模块化打包的基本流程"><a href="#webpack-模块化打包的基本流程" class="headerlink" title="webpack 模块化打包的基本流程"></a>webpack 模块化打包的基本流程</h2><ul><li>连接: webpack 从入口 JS 开始, 递归查找出所有相关联的模块, 并<code>连接</code>起来形成一个图(网)的结构</li><li>编译: 将 JS 模块中的模块化语法<code>编译</code>为浏览器可以直接运行的模块语法(当然其它类型资源也会处理)</li><li>合并: 将图中所有编译过的模块<code>合并</code>成一个或少量几个 bundle 文件, 而浏览器运行是打包生成的 bundle 文件</li></ul><h2 id="比较-loader-与-plugin"><a href="#比较-loader-与-plugin" class="headerlink" title="比较 loader 与 plugin"></a>比较 loader 与 plugin</h2><p><strong>不同的作用</strong></p><ul><li><strong>Loader</strong>直译为”加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。</li><li><strong>Plugin</strong>直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p><strong>不同的用法</strong></p><ul><li><strong>Loader</strong>在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li><strong>Plugin</strong>在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li></ul><h2 id="webpack-打包后文件体积过大怎么办"><a href="#webpack-打包后文件体积过大怎么办" class="headerlink" title="webpack 打包后文件体积过大怎么办"></a>webpack 打包后文件体积过大怎么办</h2><ul><li>异步加载模块（代码分割）；提取第三方库（使用 cdn 或者 vender）；代码压缩；去除不必要的插件；去除 devtool 选项等等</li></ul><h2 id="webpack-的-Tree-shaking-是什么"><a href="#webpack-的-Tree-shaking-是什么" class="headerlink" title="webpack 的 Tree-shaking 是什么?"></a>webpack 的 Tree-shaking 是什么?</h2><ul><li>Webpack 在打包 js 模块时, 会将模块中向外暴露但没有被使用的功能从打包文件中移除<br>2 个前提:<br>必须是使用 ES6 的 export 向外暴露的<br>必须进行 JS 的压缩处理</li></ul><h2 id="live-reload-与-hot-realod-HMR"><a href="#live-reload-与-hot-realod-HMR" class="headerlink" title="live-reload 与 hot-realod/HMR"></a>live-reload 与 hot-realod/HMR</h2><ul><li>相同点: 代码修改后都会自动重新编译打包</li><li>不同点:<ul><li>live-reload: 刷新整体页面, 从而查看到最新代码的效果, 页面状态全部都是新的</li><li>Hot-reload: 没有刷新整个页面, 只是加载了修改模块的打包文件并运行,从而更新页面的局部界面, 整个界面的其它部分的状态还在</li></ul></li></ul><p><img src="https://juejin.cn/post/7011765691812413476" alt="webpack"></p><h2 id="resolve-alias-字符串替换"><a href="#resolve-alias-字符串替换" class="headerlink" title="resolve.alias 字符串替换"></a>resolve.alias 字符串替换</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-mixin"><a href="#vue-mixin" class="headerlink" title="vue mixin"></a>vue mixin</h2><ul><li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li><li>数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先</li><li>值为对象的选项，例如 methods、components，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对</li></ul><h2 id="路由钩子函数有三种"><a href="#路由钩子函数有三种" class="headerlink" title="路由钩子函数有三种"></a>路由钩子函数有三种</h2><ul><li>全局钩子： beforeEach、 afterEach</li><li>单个路由里面的钩子： beforeEnter、 beforeLeave</li><li>组件钩子：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave</li></ul><h2 id="react-vue-中的-key-的作用-内部原理是什么"><a href="#react-vue-中的-key-的作用-内部原理是什么" class="headerlink" title="react/vue 中的 key 的作用/内部原理是什么"></a>react/vue 中的 key 的作用/内部原理是什么</h2><ol><li>虚拟 DOM 的 key 的作用?<ol><li>简单说: key 是虚拟 DOM 对象的标识, 在更新显示时 key 起着极其重要的作用</li><li>详细说: 当列表数组中的数据发生变化生成新的虚拟 DOM 后, React 进行新旧虚拟 DOM 的 diff 比较<ul><li>key 没有变<br> item 数据没变, 直接使用原来的真实 DOM<br> item 数据变了, 对原来的真实 DOM 进行数据更新</li><li>key 变了销毁原来的真实 DOM, 根据 item 数据创建新的真实 DOM 显示(即使 item 数据没有变)</li></ul></li></ol></li><li>key 为 index 的问题<ol><li>添加/删除/排序 =&gt; 产生没有必要的真实 DOM 更新 ==&gt; 界面效果没问题, 但效率低</li><li>如果 item 界面还有输入框 =&gt; 产生错误的真实 DOM 更新 ==&gt; 界面有问题<br>注意: 如果不存在添加/删除/排序操作, 用 index 没有问题</li></ol></li><li>解决:<br>使用 item 数据的标识数据作为 key, 比如 id 属性值</li></ol><h2 id="NextTick-原理"><a href="#NextTick-原理" class="headerlink" title="NextTick 原理"></a>NextTick 原理</h2><p><code>nextTick</code> 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。</p><p>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。</p><p>对于实现 macrotasks ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用 <code>setTimeout</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="keyword">typeof</span> MessageChannel !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">&#x27;[object MessageChannelConstructor]&#x27;</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue面试题"><a href="#vue面试题" class="headerlink" title="vue面试题"></a>vue面试题</h2><p>[vue面试题]<a href="https://github.com/57code/vue-interview">https://github.com/57code/vue-interview</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全和工程化面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。</p><p>XSS 可以分为多种类型，但是总体上我认为分为两类：<strong>持久型和非持久型</strong>。</p><p>持久型也就是攻击的代码被服务端写入进<strong>数据库</strong>中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。</p><p>举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容</p><p>这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</p><p>非持久型相比于前者危害就小的多了，一般通过<strong>修改 URL 参数</strong>的方式加入攻击代码，诱导用户访问链接从而进行攻击。</p><p>举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>                                                  </span><br></pre></td></tr></table></figure><p>但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。</p><p>对于 XSS 攻击来说，通常有两种方式可以用来防御。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;&amp;#96;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2F;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = <span class="built_in">require</span>(<span class="string">&#x27;xss&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> html = xss(<span class="string">&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure><p>以上示例使用了 <code>js-xss</code> 来实现，可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签。</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。</p><p>通常可以通过两种方式来开启 CSP：</p><ol><li>设置 HTTP Header 中的 <code>Content-Security-Policy</code></li><li>设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ol><p>这里以设置 HTTP Header 来举例</p><ul><li><p>只允许加载本站资源</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src ‘self’</span><br></pre></td></tr></table></figure></li><li><p>只允许加载 HTTPS 协议图片</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: img-src https://*</span><br></pre></td></tr></table></figure></li><li><p>允许加载任何来源框架</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: child-src &#x27;none&#x27;</span><br></pre></td></tr></table></figure></li></ul><p>当然可以设置的属性远不止这些，你可以通过查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">文档</a> 的方式来学习，这里就不过多赘述其他的属性了。</p><p>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">涉及面试题：什么是 CSRF 攻击？如何防范 CSRF 攻击？</span><br></pre></td></tr></table></figure><p>CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p><p>举个例子，假设网站中有一个通过 <code>GET</code> 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain.com/xxx?comment=&#x27;attack&#x27;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>那么你是否会想到使用 <code>POST</code> 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 <code>POST</code> 请求。</p><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><p>防范 CSRF 攻击可以遵循以下几种规则：</p><ol><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 Token</li></ol><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>可以对 Cookie 设置 <code>SameSite</code> 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p><h4 id="验证-Referer"><a href="#验证-Referer" class="headerlink" title="验证 Referer"></a>验证 Referer</h4><p>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">涉及面试题：什么是点击劫持？如何防范点击劫持？</span><br></pre></td></tr></table></figure><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/1/16768734d57c5f47?w=812&h=424&f=png&s=43633"></p><p>对于这种攻击方式，推荐防御的方法有两种。</p><h3 id="X-FRAME-OPTIONS"><a href="#X-FRAME-OPTIONS" class="headerlink" title="X-FRAME-OPTIONS"></a>X-FRAME-OPTIONS</h3><p><code>X-FRAME-OPTIONS</code> 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 <code>iframe</code> 嵌套的点击劫持攻击。</p><p>该响应头有三个值可选，分别是</p><ul><li><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</li><li><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</li><li><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示</li></ul><h3 id="JS-防御"><a href="#JS-防御" class="headerlink" title="JS 防御"></a>JS 防御</h3><p>对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">id</span>=<span class="string">&quot;click-jack&quot;</span>&gt;</span></span><br><span class="line">    html &#123;</span><br><span class="line">      display: none !important;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    if (self == top) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;click-jack&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.removeChild(style)</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">      top.location = self.location</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码的作用就是当通过 <code>iframe</code> 的方式加载页面时，攻击者的网页直接不显示所有内容了。</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">涉及面试题：什么是中间人攻击？如何防范中间人攻击？</span><br></pre></td></tr></table></figure><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。</p><p>通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。</p><p>当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。</p><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E6%BC%8F%E6%B4%9E.png" alt="前端漏洞"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端安全和工程化面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化琐碎事"><a href="#性能优化琐碎事" class="headerlink" title="性能优化琐碎事"></a>性能优化琐碎事</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：该知识点属于性能优化领域。</span><br></pre></td></tr></table></figure><h2 id="计算图片大小"><a href="#计算图片大小" class="headerlink" title="计算图片大小"></a>计算图片大小</h2><p>对于一张 100 <em>100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 <strong>RGBA</strong> 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000</em> 1 * 4 / 1024）。</p><p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p><p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p><ul><li><strong>减少像素点</strong></li><li><strong>减少每个像素点能够显示的颜色</strong></li></ul><h2 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h2><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h2 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h2><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//yuchengkai.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。</p><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p><p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。</p><h2 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h2><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>懒加载就是将不关键的资源延后加载。</p><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。</p><p>因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。</p><h1 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h1><p>在这一的章节中，我不会浪费篇幅给大家讲如何写配置文件。<strong>如果你想学习这方面的内容，那么完全可以去官网学习</strong>。在这部分的内容中，我们会聚焦于以下两个知识点，并且每一个知识点都属于高频考点：</p><ul><li>有哪些方式可以减少 Webpack 的打包时间</li><li>有哪些方式可以让 Webpack 打出来的包更小</li></ul><h2 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h2><h3 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h3><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。当然了，我们是有办法优化的。</p><p>首先我们可以<strong>优化 Loader 的文件搜索范围</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// js 文件才使用 babel</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 只在 src 文件夹下查找</span></span><br><span class="line">        include: [resolve(<span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">        <span class="comment">// 不会去查找的路径</span></span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</p><p>当然这样做还不够，我们还可以将 Babel 编译过的文件<strong>缓存</strong>起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      include: [resolve(<span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// id 后面的内容对应下面</span></span><br><span class="line">      loader: <span class="string">&#x27;happypack/loader?id=happybabel&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">&#x27;happybabel&#x27;</span>,</span><br><span class="line">    loaders: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">    <span class="comment">// 开启 4 个线程</span></span><br><span class="line">    threads: <span class="number">4</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p><p>接下来我们就来学习如何使用 DllPlugin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独配置在一个文件中</span></span><br><span class="line"><span class="comment">// webpack.dll.conf.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 想统一打包的类库</span></span><br><span class="line">    vendor: [<span class="string">&#x27;react&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">    library: <span class="string">&#x27;[name]-[hash]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// name 必须和 output.library 一致</span></span><br><span class="line">      name: <span class="string">&#x27;[name]-[hash]&#x27;</span>,</span><br><span class="line">      <span class="comment">// 该属性需要与 DllReferencePlugin 中一致</span></span><br><span class="line">      context: __dirname,</span><br><span class="line">      path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;[name]-manifest.json&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...省略其他配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      <span class="comment">// manifest 就是之前打包出来的 json 文件</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">&#x27;./dist/vendor-manifest.json&#x27;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>在 Webpack3 中，我们一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p><h3 id="一些小的优化点"><a href="#一些小的优化点" class="headerlink" title="一些小的优化点"></a>一些小的优化点</h3><p>我们还可以通过一些小的优化点来加快打包速度</p><ul><li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li><li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</li><li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li></ul><h2 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：该内容也属于性能优化领域。</span><br></pre></td></tr></table></figure><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，<strong>这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p><p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。</p><h3 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h3><p><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong></p><p>比如我们希望打包两个文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>对于这种情况，我们打包出来的代码会类似这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, <span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code> 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><p><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 代码片段实现</title>
      <link href="2020/10/29/js-codeSnippet/"/>
      <url>2020/10/29/js-codeSnippet/</url>
      
        <content type="html"><![CDATA[<h2 id="做一个-PC-端的网页，设计图是-1920X1080，要在常见屏上显示正常-，比如：1280X720-1366X768-1440X900-1920X1080。就要使用-REM，width、height、margin、padding、left、top-都采用了-REM"><a href="#做一个-PC-端的网页，设计图是-1920X1080，要在常见屏上显示正常-，比如：1280X720-1366X768-1440X900-1920X1080。就要使用-REM，width、height、margin、padding、left、top-都采用了-REM" class="headerlink" title="做一个 PC 端的网页，设计图是 1920X1080，要在常见屏上显示正常 ，比如：1280X720 1366X768 1440X900 1920X1080。就要使用 REM，width、height、margin、padding、left、top 都采用了 REM"></a>做一个 PC 端的网页，设计图是 1920X1080，要在常见屏上显示正常 ，比如：1280X720 1366X768 1440X900 1920X1080。就要使用 REM，width、height、margin、padding、left、top 都采用了 REM</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tid;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> designSize = <span class="number">1920</span>; <span class="comment">// 设计图尺寸</span></span><br><span class="line">    <span class="keyword">let</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">    <span class="keyword">let</span> wW = html.clientWidth; <span class="comment">// 窗口宽度</span></span><br><span class="line">    <span class="keyword">let</span> rem = (wW * <span class="number">100</span>) / designSize;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontSize = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;resize&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">      tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;pageshow&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">        tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>计算 font-size 的逻辑是：<br>当设计图是 1920 时,规定 HTML 的 FONT-SIZE 的值是 100. 也就是,当浏览器窗口调整到 1920PX 时,1REM=100PX,如果要设定一个 160PX(1920 设计图时)的 margin-top,那么 REM 设置值是 1.6rem.</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin, hashMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (origin == <span class="literal">undefined</span> || <span class="keyword">typeof</span> origin !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(origin);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(origin);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> hashKey = hashMap.get(origin);</span><br><span class="line">  <span class="keyword">if</span> (hashKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashKey;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> target = <span class="keyword">new</span> origin.constructor();</span><br><span class="line">  hashMap.set(origin, target);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> origin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.hasOwnProperty(k)) &#123;</span><br><span class="line">      target[k] = deepClone(origin[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 判断数据是否是复杂类型</span></span><br><span class="line">      <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="comment">//判断数据是否是数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123;</span><br><span class="line">          <span class="comment">//声明一个空数组来接收拷贝后的数据</span></span><br><span class="line">          <span class="keyword">let</span> result = []</span><br><span class="line">          obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 需要递归深层遍历，否则复制的是地址</span></span><br><span class="line">            result.push(fn(item))</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// 返回输出这个数组,数组拷贝完成</span></span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果是对象,就声明一个空对象来接收拷贝后的数据</span></span><br><span class="line">          <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="comment">// 使用递归深层遍历</span></span><br><span class="line">            result[k] = fn(obj[k])</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 返回输出这个对象,对象拷贝完成</span></span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 简单数据类型则直接返回输出</span></span><br><span class="line">      <span class="keyword">return</span> obj</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="js-原有的-toFixed-函数得到结果并非-想要的-需要自己重新定义"><a href="#js-原有的-toFixed-函数得到结果并非-想要的-需要自己重新定义" class="headerlink" title="js 原有的 toFixed 函数得到结果并非 想要的 需要自己重新定义"></a>js 原有的 toFixed 函数得到结果并非 想要的 需要自己重新定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFixed</span>(<span class="params">number, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;number不是数字&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.pow(<span class="number">10</span>, m) * number) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, m);</span><br><span class="line">  result = <span class="built_in">String</span>(result);</span><br><span class="line">  <span class="keyword">if</span> (result.indexOf(<span class="string">&quot;.&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="number">0</span>) &#123;</span><br><span class="line">      result += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">      result += <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).join(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = result.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">1</span>].length &lt; m) &#123;</span><br><span class="line">      arr[<span class="number">1</span>] += <span class="keyword">new</span> <span class="built_in">Array</span>(m - arr[<span class="number">1</span>].length + <span class="number">1</span>).join(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = arr.join(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind 实现"></a>bind 实现</h2><ul><li><p>箭头函数的 this 永远指向它所在的作用域，函数作为构造函数用 new 关键字调用时，不应该改变其 this 指向，因为 new 绑定 的优先级高于 显示绑定 和 硬绑定</p></li><li><p>返回⼀个函数，绑定 this，传递预置参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拿到参数，为了传给调用者</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> nop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 构建一个干净的函数，用于保存原函数的原型</span></span><br><span class="line">  <span class="comment">// 绑定的函数</span></span><br><span class="line">  <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this instanceof nop, 判断是否使用 new 来调用 bound</span></span><br><span class="line">    <span class="comment">// 如果是 new 来调用的话，this的指向就是其实例，</span></span><br><span class="line">    <span class="comment">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span></span><br><span class="line">    <span class="keyword">return</span> self.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> nop ? <span class="built_in">this</span> : thisArg,</span><br><span class="line">      args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.prototype) &#123;</span><br><span class="line">    nop.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改绑定函数的原型指向</span></span><br><span class="line">  bound.prototype = <span class="keyword">new</span> nop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="call-实现"><a href="#call-实现" class="headerlink" title="call 实现"></a>call 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this指向调用call的对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用call的若不是函数则报错</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  thisArg = thisArg || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将调用call函数的对象添加到thisArg的属性中</span></span><br><span class="line">  thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 执行该属性</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.fn(...arg);</span><br><span class="line">  <span class="comment">// 删除该属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">  <span class="comment">// 返回函数执行结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply 实现"></a>apply 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.fn(...arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简单的防抖-函数"><a href="#简单的防抖-函数" class="headerlink" title="简单的防抖 函数"></a>简单的防抖 函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn();</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-实现的过程"><a href="#new-实现的过程" class="headerlink" title="new 实现的过程"></a>new 实现的过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为new是关键字,函数的形式来实现，将构造函数和构造函数的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">Fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.创建一个空对象，并将对象的__proto__指向构造函数的prototype 这里我两步一起做了</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Fn.prototype);</span><br><span class="line">  <span class="comment">//2.将构造函数中的this指向obj，执行构造函数代码,获取返回值</span></span><br><span class="line">  <span class="keyword">const</span> res = Fn.apply(obj, args);</span><br><span class="line">  <span class="comment">//3.判断返回值类型</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="compose-函数实现-函数组合"><a href="#compose-函数实现-函数组合" class="headerlink" title="compose 函数实现 函数组合"></a>compose 函数实现 函数组合</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">!fns.length</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">v</span>) =&gt;</span> v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">fns.length === <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fns.reducer(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> pre(cur(...args))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="settimeout-模拟实现-setinterval"><a href="#settimeout-模拟实现-setinterval" class="headerlink" title="settimeout 模拟实现 setinterval"></a>settimeout 模拟实现 setinterval</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySettimeout</span>(<span class="params">fn, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(interval, t);</span><br><span class="line">  &#125;</span><br><span class="line">  interval();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    cancel: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">fn, delay, times</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn()</span><br><span class="line">        times--</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(a, delay)</span><br><span class="line">        <span class="keyword">if</span> (times &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, delay)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mySetInterval(fn, <span class="number">2000</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  requestAnimationFrame 实现setInterval</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now</span><br><span class="line">  <span class="keyword">let</span> startTime = now()</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime</span><br><span class="line">  <span class="keyword">const</span> loop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">  <span class="keyword">return</span> timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="params">timer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现订阅</span></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, callBack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type] = [callBack];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type].push(callBack);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除订阅</span></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type, callBack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.events[type] = <span class="built_in">this</span>.events[type].filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item !== callBack;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只执行一次订阅事件</span></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">type, callBack</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callBack();</span><br><span class="line">      <span class="built_in">this</span>.off(type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(type, fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type, ...rest</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type] &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.events[type].forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn.apply(<span class="built_in">this</span>, rest));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><p>JS 来说，数组长度大于 10 会采用快排，否则使用插入排序 <a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L760:7">源码实现</a> 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 <code>O(N * logN)</code>相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存数组长度</span></span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="comment">// 外层循环用于控制从头到尾的比较+交换到底有多少轮</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; </span><br><span class="line">    <span class="comment">// 每循环完一次就少一次比教</span></span><br><span class="line">    <span class="comment">// 内层循环用于完成每一轮遍历过程中的重复比较+交换 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="comment">// 若相邻元素前面的数比后面的大</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 交换两者</span></span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回数组</span></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="　插入排序"></a>　插入排序</h3><p>第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//当前要处理的数</span></span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">            <span class="comment">//如果前一个数大于后一个数,将前一个数往后移一位</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的j是要处理的数排序后应该在的位置</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>分区: 从数组中任意选择一个基准，所有比基准小的元素放到基准前面，比基准大的元素放到基准的后面<br>递归：递归地对基准前后的子数组进行分区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quirkSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">arr.length &lt;= <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line">  <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并”的意思是将两个或两个以上的有序表组合成一个新的有序表。假如初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]（向上取整）个长度为2或1的有序子序列；再两两归并，……，如此重复，直到得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。</p><p>步骤解析：</p><p>1、把长度为n的输入序列分成两个长度为n/2的子序列；</p><p>2、对这两个子序列继续分为m/2的子序列，一直分下去，直为1个元素；</p><p>3、将两个排序好的子序列合并成一个最终的排序序列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">len &lt; <span class="number">2</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//首先将无序数组划分为两个数组</span></span><br><span class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> left = arr.slice(<span class="number">0</span>,mid);</span><br><span class="line">  <span class="keyword">var</span> right = arr.slice(mid,len);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));<span class="comment">//递归分别对左右两部分数组进行排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="function"><span class="title">while</span>(<span class="params">left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">left[<span class="number">0</span>]&lt;=right[<span class="number">0</span>]</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//如果左边的数据小于右边的数据，将左边数据取出，放在新数组中</span></span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       result.push(right.shift());</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">while</span>(<span class="params">left.length</span>)</span>&#123;</span><br><span class="line">     result.push(left.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">while</span>(<span class="params">right.length</span>)</span>&#123;</span><br><span class="line">     result.push(right.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>];</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr));<span class="comment">//3,5,15,26,36,38,44,47</span></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>找到数组中的最小值，选中它并将其放置在第一位<br>接着找到第二个最小值，选中它并将其放置到第二位<br>执行n-1轮，就可以完成排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.selectionSort = <span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length - <span class="number">1</span>; ++i</span>)</span> &#123; </span><br><span class="line">        <span class="comment">// 假设最小的值是当前的下标</span></span><br><span class="line">        <span class="keyword">let</span> indexMin = i;</span><br><span class="line">        <span class="comment">//遍历剩余长度找到最小下标</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> j = i; j &lt; <span class="built_in">this</span>.length; ++j</span>)</span> &#123; </span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>[j] &lt; <span class="built_in">this</span>[indexMin] </span>)</span> &#123; </span><br><span class="line">                indexMin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">indexMin !== i</span>)</span> &#123; </span><br><span class="line">            <span class="comment">//交换当前下标i与最小下标的值，重复this.length次</span></span><br><span class="line">            <span class="keyword">const</span> temp = <span class="built_in">this</span>[i];</span><br><span class="line">            <span class="built_in">this</span>[i] = <span class="built_in">this</span>[indexMin];</span><br><span class="line">            <span class="built_in">this</span>[indexMin] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">arr.selectionSort();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数柯粒化-实现一个-add-方法-add-1-2-3-6-add-1-2-3-4-10"><a href="#函数柯粒化-实现一个-add-方法-add-1-2-3-6-add-1-2-3-4-10" class="headerlink" title="函数柯粒化 实现一个 add 方法 add(1)(2)(3)=6 add(1,2,3)(4)=10"></a>函数柯粒化 实现一个 add 方法 add(1)(2)(3)=6 add(1,2,3)(4)=10</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allArgs = [...args];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...newArgs</span>) </span>&#123;</span><br><span class="line">    allArgs = [...allArgs, ...newArgs];</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  &#125;</span><br><span class="line">  fn.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!allArgs.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allArgs.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持多参数传递</span></span><br><span class="line"><span class="comment">// 创建一个可以多步执行的柯里化函数，当参数满足数量时就去执行它：</span></span><br><span class="line"><span class="comment">// 函数公式：fn(x,y,z,w) ==&gt; fn(x)(y)(z)(w);</span></span><br><span class="line"><span class="keyword">let</span> createCurry = <span class="function">(<span class="params">fn,...params</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> args = parsms || [];</span><br><span class="line">    <span class="keyword">let</span> fnLen = fn.length; <span class="comment">// 指定柯里化函数的参数长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...res</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 通过作用域链获取上一次的所有参数</span></span><br><span class="line">        <span class="keyword">let</span> allArgs = args.slice(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 深度拷贝闭包共用的args参数，避免后续操作影响（引用类型）</span></span><br><span class="line">        allArgs.push(...res);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">allArgs.length &lt; fnLen</span>)</span>&#123;</span><br><span class="line">           <span class="comment">// 当参数数量小于原函数的参数长度时，递归调用createCurry函数</span></span><br><span class="line">           <span class="keyword">return</span> createCurry.call(<span class="built_in">this</span>,fn,...allArgs);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">// 当参数数量满足时，触发函数执行</span></span><br><span class="line">          <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>,allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h2><p>惰性加载表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用的过程中 该函数被覆盖为另一个合适的方式执行的函数 这样任何对原函数的调用就不用再经过调用过的分支函调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  getTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getTime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getTime());</span><br><span class="line"><span class="built_in">console</span>.log(getTime());</span><br><span class="line"><span class="built_in">console</span>.log(getTime());</span><br><span class="line"><span class="built_in">console</span>.log(getTime());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="缓存函数-递归函数执行优化"><a href="#缓存函数-递归函数执行优化" class="headerlink" title="缓存函数  递归函数执行优化"></a>缓存函数  递归函数执行优化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> k = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).join(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[k] = cache[k] || fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fab</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m &lt;= <span class="number">2</span> ? <span class="number">1</span>: fab(m-<span class="number">1</span>) + fab(m-<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = memorize(fab);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">8</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LRU-缓-存-函-数"><a href="#LRU-缓-存-函-数" class="headerlink" title="LRU 缓 存 函 数"></a>LRU 缓 存 函 数</h2><p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法[2]，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面[3]一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。<br><a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091?fromModule=lemma_inlink">页面置换算法</a></p><p><a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2/5544813?fromModule=lemma_inlink">页面</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">capacity</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> LRUCache = <span class="function"><span class="keyword">function</span>(<span class="params">capacity</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.map.has(key)</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.map.get(key)</span><br><span class="line">        <span class="comment">// 更新存储位置</span></span><br><span class="line">        <span class="built_in">this</span>.map.delete(key)</span><br><span class="line">        <span class="built_in">this</span>.map.set(key,value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LRUCache.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.map.has(key)</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.map.delete(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.map.set(key,value)</span><br><span class="line">    <span class="comment">// 如果此时超过了最长可存储范围</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.map.size &gt; <span class="built_in">this</span>.capacity</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 删除 map 中最久未使用的元素</span></span><br><span class="line">        <span class="built_in">this</span>.map.delete(<span class="built_in">this</span>.map.keys().next().value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="instanceof-操作符的实现原理及实现"><a href="#instanceof-操作符的实现原理及实现" class="headerlink" title="instanceof  操作符的实现原理及实现"></a>instanceof  操作符的实现原理及实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left);</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">  <span class="function"><span class="title">while</span>(<span class="params"><span class="literal">true</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!proto</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">proto === prototype</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-urls-数组中存放了-10-个接口地址。同时还定义了一个-loadDate-函数，这个函数接受一个-url-参数，返回一个-Promise-对象，该-Promise-在接口调用成功时返回-resolve，失败时返回-reject。要求：任意时刻，同时下载的链接数量不可以超过-3-个"><a href="#在-urls-数组中存放了-10-个接口地址。同时还定义了一个-loadDate-函数，这个函数接受一个-url-参数，返回一个-Promise-对象，该-Promise-在接口调用成功时返回-resolve，失败时返回-reject。要求：任意时刻，同时下载的链接数量不可以超过-3-个" class="headerlink" title="在 urls 数组中存放了 10 个接口地址。同时还定义了一个 loadDate 函数，这个函数接受一个 url 参数，返回一个 Promise 对象，该 Promise 在接口调用成功时返回 resolve，失败时返回 reject。要求：任意时刻，同时下载的链接数量不可以超过 3 个"></a>在 <code>urls</code> 数组中存放了 10 个接口地址。同时还定义了一个 <code>loadDate</code> 函数，这个函数接受一个 <code>url</code> 参数，返回一个 <code>Promise</code> 对象，该 <code>Promise</code> 在接口调用成功时返回 <code>resolve</code>，失败时返回 <code>reject</code>。要求：任意时刻，同时下载的链接数量不可以超过 3 个</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/2&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/3&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/4&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/5&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/6&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/7&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/9&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;http://jsonplaceholder.typicode.com/posts/10&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadDate</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">    xhr.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">limitLoad</span>(<span class="params">urls, handler, limit</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对数组进行一个拷贝</span></span><br><span class="line">    <span class="keyword">const</span> sequence = [].concat(urls)</span><br><span class="line">    <span class="keyword">let</span> promises = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现并发请求达到最大值</span></span><br><span class="line">    promises = sequence.splice(<span class="number">0</span>, limit).map(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里返回的 index 是任务在数组 promises 的脚标</span></span><br><span class="line">        <span class="comment">//用于在 Promise.race 后找到完成的任务脚标</span></span><br><span class="line">        <span class="keyword">return</span> handler(url).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用数组的 reduce 方法来以队列的形式执行</span></span><br><span class="line">    <span class="keyword">return</span> sequence.reduce(<span class="function">(<span class="params">last, url, currentIndex</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 返回最快改变状态的 Promise</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.race(promises)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的 catch 不仅用来捕获前面 then 方法抛出的错误</span></span><br><span class="line">            <span class="comment">// 更重要的是防止中断整个链式调用</span></span><br><span class="line">            <span class="built_in">console</span>.error(err)</span><br><span class="line">        &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 用新的 Promise 替换掉最快改变状态的 Promise</span></span><br><span class="line">            promises[res] = handler(sequence[currentIndex]).then(</span><br><span class="line">                () =&gt; &#123; <span class="keyword">return</span> res &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">limitLoad(urls, loadDate, <span class="number">3</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为 loadDate 函数也返回一个 Promise</span></span><br><span class="line"><span class="comment">所以当 所有图片加载完成后可以继续链式调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">limitLoad(urls, loadDate, 3).then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;所有url数据请求成功&#x27;);</span></span><br><span class="line"><span class="comment">&#125;).catch(err =&gt; &#123;</span></span><br><span class="line"><span class="comment">    console.error(err);</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="实现-Promise-all-race-allSettled-any"><a href="#实现-Promise-all-race-allSettled-any" class="headerlink" title="实现 Promise.all/race/allSettled/any"></a>实现 Promise.all/race/allSettled/any</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个失败则返回失败的结果，全部成功返回全成功的数组</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promiseList = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (promiseList.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseList.length; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promiseList[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        result[i] = res</span><br><span class="line">        count++</span><br><span class="line">        <span class="comment">// 不能直接通过 result.length 进行比较，因为 会存在下标大的先赋值</span></span><br><span class="line">        <span class="comment">// 例如 i = 3 第一个返回结果，此时数组变为[empty,empty,empty,res]</span></span><br><span class="line">        <span class="keyword">if</span> (count === promiseList.length) &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回第一个成功或失败的结果</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promiseList = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseList.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve([])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseList.length; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promiseList[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无论成功约否都返回，但是会添加一个 status 字段用于标记成功/失败</span></span><br><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">promiseList = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> addRes = <span class="function">(<span class="params">i, data</span>) =&gt;</span> &#123;</span><br><span class="line">      result[i] = data</span><br><span class="line">      count++</span><br><span class="line">      <span class="keyword">if</span> (count === promiseList.length) &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (promiseList.length === <span class="number">0</span>) <span class="keyword">return</span> resolve(result)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseList.length; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promiseList[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        addRes(i, &#123; <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">data</span>: res &#125;)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        addRes(i, &#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">data</span>: e &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AggregateError，当多个错误需要包装在一个错误中时，该对象表示一个错误。</span></span><br><span class="line"><span class="comment">// 和 Promise.all 相反，全部失败返回失败的结果数组，有一个成功则返回成功结果</span></span><br><span class="line"><span class="built_in">Promise</span>.any = <span class="function"><span class="keyword">function</span> (<span class="params">promiseList = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseList.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseList.length; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promiseList[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        result[i] = e</span><br><span class="line">        <span class="keyword">if</span> (count === promiseList.length) &#123;</span><br><span class="line">          reject(<span class="keyword">new</span> AggregateError(result))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> js 代码片段实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js 代码片段实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react面试题</title>
      <link href="2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/react%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/react%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="state-如何注入组件，从-redux-到组件经历的过程"><a href="#state-如何注入组件，从-redux-到组件经历的过程" class="headerlink" title="state 如何注入组件，从 redux 到组件经历的过程"></a>state 如何注入组件，从 redux 到组件经历的过程</h2><h2 id="react-最新的生命周期"><a href="#react-最新的生命周期" class="headerlink" title="react 最新的生命周期"></a>react 最新的生命周期</h2><p>React 16 之后有三个⽣命周期被废弃(但并未删除)</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate<br>计划在 17 版本完全删除这三个函数，只保留 UNSAVE_前缀的三个函数，⽬的是为了向下兼容，但是对于开发者⽽⾔应该尽量避免使⽤他们，⽽是使⽤新增的⽣命周期函数替代它们</li></ul><p>最新的⽣命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p><ul><li>挂载阶段<ul><li>constructor: 构造函数，最先被执⾏,我们通常在构造函数⾥初始化 state 对象或者给⾃定义⽅法绑定 this</li><li>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState) ,这是个静态⽅法,当我们接收到新的属性想去修改我们 state，可以使⽤ getDerivedStateFromProps</li><li>render: render 函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等内容</li><li>componentDidMount: 组件装载之后调⽤，此时我们可以获取到 DOM 节点并操作，⽐如对 canvas，svg 的操作，服务器请求，订阅都可以写在这个⾥⾯，但是记得在 componentWillUnmount 中取消订阅</li></ul></li><li>更新阶段<ul><li>getDerivedStateFromProps: 此⽅法在更新个挂载阶段都可能会调⽤</li><li>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState) ,有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回⼀个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利⽤此⽣命周期来优化 React 程序性能</li><li>render: 更新阶段也会触发此⽣命周期</li><li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState) , 这 个 ⽅ 法 在 render 之 后 ，componentDidUpdate 之前调⽤，有两个参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有⼀个返回值，会作为第三个参数传给 componentDidUpdate，如果你不想要返回值，可以返回 null，此⽣命周期必须与 componentDidUpdate 搭配使⽤</li><li>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot) ,该⽅法在 getSnapshotBeforeUpdate ⽅法之后被调⽤，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的,如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统⼀触发回调或更新状态。</li></ul></li><li>卸载阶段</li></ul><h2 id="setState-是同步还是异步"><a href="#setState-是同步还是异步" class="headerlink" title="setState 是同步还是异步"></a>setState 是同步还是异步</h2><h2 id="react-组件的通信"><a href="#react-组件的通信" class="headerlink" title="react 组件的通信"></a>react 组件的通信</h2><h2 id="react-优化手段"><a href="#react-优化手段" class="headerlink" title="react 优化手段"></a>react 优化手段</h2><h2 id="讲-一-下-react-fiber？"><a href="#讲-一-下-react-fiber？" class="headerlink" title="讲 一 下 react fiber？"></a>讲 一 下 react fiber？</h2><ul><li><p>React 通过Fiber 架构，让这个执⾏过程变成可被中断。“适时”地让出 CPU 执⾏权，除了可以让浏<br>览器及时地响应⽤户的交互，还有其他好处:<br>●分批延时对DOM进⾏操作，避免⼀次性操作⼤量 DOM 节点，可以得到更好的⽤户体验；<br>●给浏览器⼀点喘息的机会，它会对代码进⾏编译优化（JIT）及进⾏热代码优化，或者对 reflow 进⾏修<br>正。</p></li><li><p>Fiber 也称协程或者纤程。它和线程并不⼀样，协程本身是没有并发或者并⾏能⼒的（需要配<br>合线程），它只是⼀种控制流程的让出机制。让出 CPU 的执⾏权，让 CPU 能在这段时间执⾏其他的操<br>作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给⾼优先级的任务，浏览器空闲后再恢复<br>渲染。</p></li></ul><h2 id="redux-和-mobx-的-区-别-和-使-用-场-景"><a href="#redux-和-mobx-的-区-别-和-使-用-场-景" class="headerlink" title="redux 和 mobx 的 区 别 和 使 用 场 景"></a>redux 和 mobx 的 区 别 和 使 用 场 景</h2><h2 id="常-用-的-react-hooks-方-法"><a href="#常-用-的-react-hooks-方-法" class="headerlink" title="常 用 的 react hooks 方 法"></a>常 用 的 react hooks 方 法</h2><h2 id="useState-怎-么-做-缓-存-的"><a href="#useState-怎-么-做-缓-存-的" class="headerlink" title="useState 怎 么 做 缓 存 的"></a>useState 怎 么 做 缓 存 的</h2><h2 id="react-ssr-是-在-什-么-场-景-下-做-的-？"><a href="#react-ssr-是-在-什-么-场-景-下-做-的-？" class="headerlink" title="react ssr 是 在 什 么 场 景 下 做 的 ？"></a>react ssr 是 在 什 么 场 景 下 做 的 ？</h2><h2 id="react-ssr-双-端-怎-么-做-构-建-的-？-区-别-在-哪-里-？"><a href="#react-ssr-双-端-怎-么-做-构-建-的-？-区-别-在-哪-里-？" class="headerlink" title="react ssr 双 端 怎 么 做 构 建 的 ？ 区 别 在 哪 里 ？"></a>react ssr 双 端 怎 么 做 构 建 的 ？ 区 别 在 哪 里 ？</h2><h2 id="render-和-renderToString-的-底-层-实-现-上-的-区-别-？"><a href="#render-和-renderToString-的-底-层-实-现-上-的-区-别-？" class="headerlink" title="render 和 renderToString 的 底 层 实 现 上 的 区 别 ？"></a>render 和 renderToString 的 底 层 实 现 上 的 区 别 ？</h2><h2 id="react-ssr-和-ejs-性-能-的-差-异-？"><a href="#react-ssr-和-ejs-性-能-的-差-异-？" class="headerlink" title="react ssr 和 ejs 性 能 的 差 异 ？"></a>react ssr 和 ejs 性 能 的 差 异 ？</h2><h2 id="useRef-与-createRef-区别"><a href="#useRef-与-createRef-区别" class="headerlink" title="useRef 与 createRef 区别"></a>useRef 与 createRef 区别</h2><p>createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。</p><h2 id="React-Fiber-是什么"><a href="#React-Fiber-是什么" class="headerlink" title="React Fiber 是什么?"></a>React Fiber 是什么?</h2><h3 id="Fiber-出现的背景"><a href="#Fiber-出现的背景" class="headerlink" title="Fiber 出现的背景"></a>Fiber 出现的背景</h3><p>首先要知道的是，JS 引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待。在这样的机制下，如果 JS 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿<br>而这正是 React15 的 Stack Reconciler 所面临的问题，即是 JS 对主线程的超时占用问题。Stack Reconciler 是一个同步的递归过程，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止，所以当 React 在渲染组件时，从开始到渲染完成整个过程是一气呵成的。如果渲染的组件比较庞大，JS 执行会占据主线程较长时间，会导致页面响应度变差。而且所有的任务都是按照先后顺序，没有区分优先级，这样就会导致优先级比较高的任务无法被优先执行</p><h3 id="Fiber-是什么"><a href="#Fiber-是什么" class="headerlink" title="Fiber 是什么"></a>Fiber 是什么</h3><p>Fiber 与进程、线程同为程序执行过程，Fiber 就是比线程还要纤细的一个过程，意味着在对渲染过程进行更加精细的控制<br>从架构角度老看，Fiber 是对 React 核心算法(即调和过程)的重写<br>从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的虚拟 DOM</p><h3 id="Fiber-是如何解决问题的？"><a href="#Fiber-是如何解决问题的？" class="headerlink" title="Fiber 是如何解决问题的？"></a>Fiber 是如何解决问题的？</h3><p>Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细得任务视作一个执行单元，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主程控制执行其他任务，最终实现更流畅的用户体验。<br>即实现了增量渲染，实现可中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber 节点</p><h3 id="Fiber-实现原理"><a href="#Fiber-实现原理" class="headerlink" title="Fiber 实现原理"></a>Fiber 实现原理</h3><p>实现的方式是 requestIdleCallback 这一 api，但 React 团队 polyfill 了这个 api，使其对比原生的浏览器兼容性更好且扩展了这个特性。requestIdleCallback 回调的执行前提条件是当前浏览器处于空闲状态。即 requestIdleCallback 的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。</p><p>首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回浏览器，让浏览器有时间在进行页面的渲染。等浏览器忙完之后有剩余时间，在继续之前 React 未完成的任务，是一种合作式调度。简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权交还给浏览器。React16 的 Reconciler 基于 Fiber 节点实现，被称为 Fiber Reconciler</p><p>作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存该组件的类型(函数组件、类组件、原生组件等等)，对应的 DOM 节点等信息</p><p>作为动态的工作单元来说，每个 Fiber 节点保存本次更新中该组件改变的状态、要执行的工作。每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何形成树的呢？靠下面的三个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指向父级Fiber节点</span><br><span class="line">this.return &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 指向子Fiber节点</span><br><span class="line">this.child &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 指向右边第一个兄弟Fiber节点</span><br><span class="line">this.sibling &#x3D; null;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器调试技巧</title>
      <link href="2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="debug-函数"><a href="#debug-函数" class="headerlink" title="debug 函数"></a>debug 函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug(test);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="DOM-断点"><a href="#DOM-断点" class="headerlink" title="DOM 断点"></a>DOM 断点</h2><p><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/dom%E6%96%AD%E7%82%B9.png" alt="12"></p><h2 id="鼠标悬浮样式查看"><a href="#鼠标悬浮样式查看" class="headerlink" title="鼠标悬浮样式查看"></a>鼠标悬浮样式查看</h2><p><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/hover.png" alt="12"></p><h2 id="控制台内置对象-0"><a href="#控制台内置对象-0" class="headerlink" title="控制台内置对象 $0 $$ $"></a>控制台内置对象 $0 $$ $</h2><ul><li><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/$0.png" alt="12"></li><li>$$ == document.querySelectorAll</li><li>$ == document.querySelector</li></ul><h2 id="保留日志"><a href="#保留日志" class="headerlink" title="保留日志"></a>保留日志</h2><ul><li>当我们刷新完页面之后，通常控制台的 Console 面板就会被清空。如果想保留控制台的日志，就可以在设置中勾选 Preserve log 选项以保留控制台中的日志<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E4%BF%9D%E7%95%99%E6%97%A5%E5%BF%97.png"></li></ul><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><ul><li>我们可以打开设置，在 Experiments 中勾选 Record coverage while performance tracing 选项。<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E8%A6%86%E7%9B%96%E7%8E%87.png"></li><li>在面板下方的 Coverage 面板中点击红色按钮以记录页面的代码覆盖率：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E8%A6%86%E7%9B%96%E7%8E%871.png"><br>代码覆盖率使用动态分析法来收集代码运行时的覆盖率，让开发者知道有代码在页面上真正的使用。动态分析是指在应用运行状态下收集代码执行数据的过程，换句话说，覆盖率数据就是在代码执行过程中通过标记收集到的。</li></ul><h2 id="显示重绘"><a href="#显示重绘" class="headerlink" title="显示重绘"></a>显示重绘</h2><ul><li>在浏览器的开发者工具中可以通过开启显示重绘选项以查看页面在执行操作时哪些元素会发生重绘<br>在控制台右上角三个点中的 More tools 选项中开启 Rendering 选项卡：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E9%87%8D%E5%9B%9E.png"></li><li>开启 Rendering（渲染）选项后，开启 Paint flashing：当刷新页面时，显示绿色的区域就是重新绘制区域<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E9%87%8D%E5%9B%9E1.png"></li></ul><h2 id="检查动画"><a href="#检查动画" class="headerlink" title="检查动画"></a>检查动画</h2><ul><li>Chrome 的开发者工具不仅可以调试样式，还可以调试动画，可以在控制台右上角三个点中的 More tools 选项中开启 Animations 选项卡：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%A3%80%E6%9F%A5%E5%8A%A8%E7%94%BB.png"></li><li>当页面的动画执行时，就会在时间轨道上查看所有的动画，点击其中一个动画可以懂得执行过程以及时间轴<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%A3%80%E6%9F%A5%E5%8A%A8%E7%94%BB1.png"><br>我们可以在时间轴上定位到任一时刻的动画帧，也可以拖动左右两端的圆点来修改动画的延迟和周期，修改之后可以在属性面板看到对应的 CSS 样式。</li></ul><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><ul><li>Chrome 浏览器内置了截图功能，可以在浏览器开发者工具中使用 Ctrl+Shift+P（Windows）或者 Command+Shift+P（Mac）快捷键打开搜索来查找 screenshot：<br>这里有四个选项： ● 第一个：截取自选区域； ● 第二个：截取整个网页； ● 第三个：截取当前节点； ● 第四个：截取当前屏幕。 截图完成后自动下载到下载目录，打开浏览器的下载框或本机的下载目录即可看到图片<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%88%AA%E5%9B%BE.png"></li></ul><h2 id="覆盖线上资源"><a href="#覆盖线上资源" class="headerlink" title="覆盖线上资源"></a>覆盖线上资源</h2><ul><li>我们可以使用本地资源覆盖网页所使用的资源，比如可以使用本地 CSS 文件覆盖网页的 css 文件，修改样式。将本地的文件夹映射到网络，在 Chrome 开发者功能里面对 CSS 样式的修改都会直接改动本地文件，页面重新加载，使用的资源也是本地资源，达到持久化的效果。<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E8%A6%86%E7%9B%96%E7%BD%91%E4%B8%8A%E8%B5%84%E6%BA%90.png"></li></ul><h2 id="事件监听断点"><a href="#事件监听断点" class="headerlink" title="事件监听断点"></a>事件监听断点</h2><ul><li>有时应用会在用户发生交互时出现问题，这时我们就可以添加事件监听器添加断点来捕获这些事件以检查交互时的问题。可以在 Source 面板右侧的 Event Listener Breakpoints 中勾选相应的事件：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%AD%E7%82%B9.png"></li></ul><h2 id="常忽略的-js-操作符"><a href="#常忽略的-js-操作符" class="headerlink" title="常忽略的 js 操作符 ?? ??= ?."></a>常忽略的 js 操作符 <code>?? ??= ?.</code></h2><ul><li>??运算符被称为 nullish coalescing 运算符(零合并操作符)。如果第一个参数不是 null/undefined，这个运算符将返回第一个参数，否则，它将返回第二个参数</li><li>??=又被称为逻辑空值赋值运算符<code>var x= null; var y = 5; console.log(x ??= y) // 5</code></li><li>?. 允许开发人员读取深嵌在对象链中的属性值，而不必显式验证每个引用。当一个引用为空时，表达式停止计算并返回一个未定义的值 <code>travelPlans.tuesday?.location</code></li></ul><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><p><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/debug%E6%9D%A1%E4%BB%B6.png" alt="debug条件"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 浏览器调试技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器调试技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线资源文档</title>
      <link href="2020/10/27/%E6%96%87%E6%A1%A3/"/>
      <url>2020/10/27/%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bookstack.cn/">书栈网</a> <a href="https://docschina.org/">印记中文</a> <a href="https://www.javascriptc.com/">JS 中文网</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN</a> <a href="https://vue3js.cn/">vue3</a> <a href="https://cn.vuejs.org/">vue</a> <a href="https://react.docschina.org/">react</a> <a href="https://angular.cn/">angular</a> <a href="https://www.yuque.com/dashboard/">语雀</a> <a href="https://www.kancloud.cn/jsfront/month/1897005">看云 js 月报</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247487217&idx=2&sn=85f731a43b93b57230a7919945a7ae0d&chksm=fa2bee18cd5c670e9d0f2546fff7e579c416aa85fb4bf49223277ffb61624f99f6b50805902b&scene=126&sessionid=1606197281&key=b446d8ff764b323102bbb0c113388de17012eba1572ae079f7de09d4953d2d1bf50d1d2090b81c2dfc588fcff11bf70221158523c35e204a1efb7892811bf190ab4421d811a457fdc3900bfed451eb8448891ba49a6aa823bab680777e2c6eafae438fa434c108f7bf67b1397b3f1dca3dd4c3a5b661ebfefd647f8ebb7179cf&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AbqEAQXqtW+qx3SZA80qofI=&pass_ticket=EgQTrjNMllPeNIVkI9qHCXD/LxBZ2Z/8w6sriw+i2SdOdjARLD0NCMZcPJQLNT7e&wx_header=0">编码规范</a></p><p><a href="https://kaiwu.lagou.com/xunlianying/index.html?courseId=25#/course">拉钩教育</a><br><a href="https://time.geekbang.org/">极客时间</a><br><a href="https://appf96umjwe7950.h5.xiaoeknow.com/v1/auth?appId=appF96umJwe7950&redirect_url=https://appF96umJwe7950.h5.xiaoeknow.com/homepage/30">珠峰培训</a><br><a href="https://www.kaikeba.com/">开课吧</a></p><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><ul><li><a href="https://codepen.io/">CodePen | 前端在线测试和演示工具 国外站点</a></li><li><a href="https://caniuse.com/">Can I use | Web 前端兼容性列表</a></li><li><a href="https://tinypng.com/">TinyPNG | PNG/JPG 图片在线压缩工具</a></li><li><a href="https://www.umeng.com/">CNZZ | 老牌站点统计工具 5 年前国内站长必上网站</a></li><li><a href="https://web.dev/measure/">web.dev | 评测网站性能 基于 Lighthouse</a></li><li><a href="https://www.shapedivider.app/">Shape Divider | 定制各种形状 SVG 的工具</a></li><li><a href="https://gtmetrix.com/">GTmetrix | 网页性能在线分析工具</a></li><li><a href="https://carbon.now.sh/">Carbon | 代码转图片工具</a></li><li><a href="https://www.wappalyzer.com/">Wappalyzer | 检测某个网站的技术栈</a></li><li><a href="https://unbug.github.io/codelf">CODEIF | 变量方法起名工具 人工智能加持</a></li><li><a href="https://tool.lu/">tool.lu | 程序员在线工具大全</a></li><li><a href="https://mp.weixin.qq.com/s/u-k91GI2POwXeKSeTz8ddQ">CSS生成代码工具</a></li><li><a href="https://mp.weixin.qq.com/s/XutryG2ylqRP3XL4Fbz4pQ">2022年精选文章合集</a></li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li><a href="http://justjavac.com/named-function-expressions-demystified.html">命名函数表达式探秘</a> - kangax、为之漫笔(翻译) (原始地址无法打开，所以此处地址为 justjavac 博客上的备份)</li><li><a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN">你不知道的 Javascript</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解 JavaScript 系列</a></li><li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns">学用 JavaScript 设计模式</a> - 开源中国</li><li><a href="https://github.com/adamlu/javascript-style-guide">Airbnb JavaScript 规范</a></li><li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a> - 阮一峰</li><li><a href="http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html">Google JavaScript 代码风格指南</a></li><li><a href="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程（alpha）</a></li><li><a href="https://github.com/justjavac/12-javascript-quirks">javascript 的 12 个怪癖</a></li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园</a></li><li><a href="https://github.com/jayli/javascript-patterns">《JavaScript 模式》</a> (《JavaScript patterns》译本)</li><li><a href="https://web.archive.org/web/20170112164945/http://typeof.net/s/jsmech/">Javascript 原理</a></li><li><a href="http://liubin.github.io/promises-book/">JavaScript Promise 迷你书</a></li><li><a href="http://pij.robinqu.me/">Javascript 编程指南</a> (<a href="https://github.com/RobinQu/Programing-In-Javascript">源码</a>)</li><li><a href="http://icodeit.org/jsccp/">JavaScript 核心概念及实践</a> (PDF)</li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247507272&idx=1&sn=709943948b39689ce32d2f241e907783&chksm=fc7e9313cb091a05d7ebfa083062cd39c9b96b6be8f58b012a84fdbda79fa6227c66e67e0aaa&token=400768939&lang=zh_CN&scene=21#wechat_redirect">10分钟彻底掌握 CSS Flex 布局</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247507988&idx=1&sn=a6f918aee92341383bb4a71bedee16b0&chksm=fc7eee4fcb096759db8e3d1878948d5c9fa630b500a6541d729f9a8cf8b4ad2663e8cc93fe92&token=400768939&lang=zh_CN&scene=21#wechat_redirect">一文读懂 CSS 单位</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247510354&idx=1&sn=6de83188c27399e042372cf16d454386&chksm=fc7ee709cb096e1fcabeb956b1a07b62f8642b4addb72ba40ee2f72c41516fbb3a1dc41c3606&token=400768939&lang=zh_CN&scene=21#wechat_redirect">玩转CSS变量</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247499112&idx=1&sn=e40e4f02a2605583bfebfacdc189d4fb&chksm=fc7eb333cb093a254d5d6104cad8fda9e835858115b856ec33fcbceeaf28bc83d4fb2b741ab5&token=400768939&lang=zh_CN&scene=21#wechat_redirect">CSS实用技巧</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247494835&idx=1&sn=9ec716c65783ecf50abac2f87eac21ff&chksm=fc7ea2e8cb092bfebac42305449a5a7708659e1ac0dbac247e186d228ab5632f8933fbb4767f&token=400768939&lang=zh_CN&scene=21#wechat_redirect">高级 CSS 选择器</a></li></ul><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ul><li><a href="http://nqdeng.github.io/7-days-nodejs/">七天学会 NodeJS</a> - 阿里团队</li><li><a href="https://github.com/nswbmw/N-blog">使用 Express + MongoDB 搭建多人博客</a></li><li><a href="http://expressjs.jser.us/">express.js 中文文档</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/express.html">Express 框架</a></li><li><a href="http://nodejs.ctolib.com/docs/sfile/jstraining/engineering.html">JavaScript 全栈工程师培训材料</a></li><li><a href="https://github.com/guo-yu/koa-guide">koa 中文文档</a></li><li><a href="https://www.npmjs.com/package/learnyounode-zh-cn">Learn You The Node.js For Much Win! (中文版)</a></li><li><a href="http://i5ting.github.io/node-debug-tutorial/">Node debug 三法三例</a></li><li><a href="https://github.com/alsotang/node-lessons">Node.js 包教不包会</a></li><li><a href="https://github.com/jollen/nodejs-fullstack-lessons">Node.js Fullstack《從零到一的進撃》</a></li><li><a href="http://www.nodebeginner.org/index-zh-cn.html">Node 入门</a></li><li><a href="https://github.com/nodejs-tw/nodejs-wiki-book">Nodejs Wiki Book</a> (繁体中文)</li><li><a href="https://www.gitbook.com/book/0532/nodejs/details">nodejs 中文文档</a></li><li><a href="https://www.gitbook.com/book/0532/nodejs/details">The NodeJS 中文文档</a> - 社区翻译</li><li><a href="https://blog.poetries.top/node-learning-notes/notes/base/01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">Node.js 学习指南</a></li><li><a href="https://theanarkh.github.io/understand-nodejs/">Node.js 源码剖析</a></li></ul><h2 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h2><ul><li><a href="https://github.com/theJian/build-a-hn-front-page">Learn React &amp; Webpack by building the Hacker News front page</a></li><li><a href="https://github.com/hateonion/react-bits-CN">React-Bits 中文文档</a></li><li><a href="http://wiki.jikexueyuan.com/project/react-native/">React Native 中文文档(含最新 Android 内容)</a></li><li><a href="https://github.com/fakefish/react-webpack-cookbook">React webpack-cookbook</a></li><li><a href="http://fraserxu.me/intro-to-react/">React.js 入门教程</a></li><li><a href="https://discountry.github.io/react/">React.js 中文文档</a></li><li><a href="https://github.com/sxfad/react-admin/">基于 Ant Design React 的管理系统架构</a></li><li><a href="https://react.jokcy.me/">React 源码解析</a></li><li><a href="https://github.com/KieSun/awesome-frontend-source-interpretation">从源码层面，剖析前端主流技术的底层实现原理</a></li><li><a href="https://juejin.cn/post/6844904157829136398">React Hooks 使用详解及实际项目中遇到的坑</a></li><li><a href="https://github.com/beichensky/Blog/issues/6">React Hooks 常见问题及解决方案</a></li><li><a href="https://react.iamkasong.com/">react 技术揭秘</a></li><li><a href="https://github.com/puxiao/react-hook-tutorial/blob/master/03%20useState%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.md">React Hook 系列教程，学习和探索 Hooks 世界</a></li></ul><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/">Vue.js 中文文档</a></li><li><a href="https://vue3.chengpeiquan.com/">Vue3.0 学习教程与实战案例</a> - chengpeiquan</li><li><a href="https://vue-js.com/learn-vue/start/">Vue 源码系列</a></li><li><a href="https://vue3js.cn/">vue3 文档</a></li></ul><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><ul><li><p><a href="https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json">深入理解 Typescript</a></p></li><li><p><a href="https://typescript.bootcss.com/">typescript</a></p></li><li><p><a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程</a> - runoob (HTML)</p></li><li><p><a href="https://www.runoob.com/w3cnote/getting-started-with-typescript.html">TypeScript 入门教程</a> - runoob (HTML)</p></li><li><p><a href="https://www.tslang.cn/">TypeScript 中文网</a> (HTML)</p></li><li><p><a href="https://github.com/jkchao/typescript-book-chinese">TypeScript Deep Dive 中文版</a> - 三毛 (HTML)</p></li><li><p><a href="https://www.runoob.com/manual/gitbook/TypeScript/_book/">TypeScript Handbook（中文版）</a> - Patrick Zhong (HTML)</p></li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul><li><a href="https://web.archive.org/web/20191004044726/http://igit.linuxtoy.org:80/index.html">沉浸式学 Git</a></li><li><a href="http://backlogtool.com/git-guide/cn/">猴子都能懂的 GIT 入门</a></li><li><a href="https://learngitbranching.js.org/">学习 Git 分支</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git - 简易指南</a></li><li><a href="http://gitref.justjavac.com/">Git 参考手册</a></li><li><a href="https://github.com/flyhigher139/Git-Cheat-Sheet">Git-Cheat-Sheet</a> - flyhigher139</li><li><a href="http://gitbook.liuhui998.com/">Git Community Book 中文版</a></li><li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git-flow 备忘清单</a></li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git magic</a></li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git Magic</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git 教程</a> - 廖雪峰</li><li><a href="https://github.com/waylau/github-help">Github 帮助文档</a></li><li><a href="https://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/">GitHub 秘籍</a></li><li><a href="https://github.com/gotgit/gotgithub">Got GitHub</a></li><li><a href="http://www.worldhello.net/gotgithub/index.html">GotGitHub</a></li><li><a href="https://zh-hginit.readthedocs.io/en/latest/">HgInit (中文版)</a></li><li><a href="https://www.mercurial-scm.org/wiki/ChineseTutorial">Mercurial 使用教程</a></li><li><a href="https://git-scm.com/book/zh/v2">Pro Git</a></li><li><a href="https://bingohuang.gitbooks.io/progit2/content">Pro Git 第二版 中文版</a> - Bingo Huang</li><li><a href="http://svnbook.red-bean.com/nightly/zh/index.html">svn 手册</a></li></ul><h2 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h2><ul><li><a href="https://deno-tutorial.js.org/">Deno 钻研之术</a></li><li><a href="https://chenshenhai.com/deno_note">Deno 进阶开发笔记</a> - 大深海</li></ul><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><ul><li><a href="http://www.jianshu.com/p/q81RER">献给写作者的 Markdown 新手指南</a></li><li><a href="https://markdown.tw/">Markdown 語法說明</a></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul><li><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html">21 分钟 MySQL 入门教程</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><ul><li><a href="https://github.com/huangz1990/annotated_redis_source">带有详细注释的 Redis 2.6 代码</a></li><li><a href="https://github.com/huangz1990/redis-3.0-annotated">带有详细注释的 Redis 3.0 代码</a></li><li><a href="http://disque.huangz.me/">Disque 使用教程</a></li><li><a href="http://redisdoc.com/">Redis 命令参考</a></li><li><a href="http://redisbook.com/">Redis 设计与实现</a></li><li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md">The Little MongoDB Book</a></li><li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md">The Little Redis Book</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 在线资源文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线资源文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react  redux中间件</title>
      <link href="2020/10/26/react%E7%AC%94%E8%AE%B0/MiddleWare%E5%BA%94%E7%94%A8/"/>
      <url>2020/10/26/react%E7%AC%94%E8%AE%B0/MiddleWare%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="MiddleWare的使用"><a href="#MiddleWare的使用" class="headerlink" title="MiddleWare的使用"></a>MiddleWare的使用</h2><h3 id="1-logger中间件"><a href="#1-logger中间件" class="headerlink" title="1.logger中间件"></a>1.logger中间件</h3><p>我们改写了，dispatch方法实现了在更改状态时打印前后的状态,但是这种方案并不好。所以我们可以采用中间的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"><span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number);</span><br><span class="line">  dispatch(action);</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="实现logger中间件"><a href="#实现logger中间件" class="headerlink" title="实现logger中间件"></a>实现logger中间件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number);</span><br><span class="line">  dispatch(action);</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> applyMiddleWare = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function"><span class="params">reducer</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="keyword">let</span> middle = middleware(store);</span><br><span class="line">  <span class="keyword">let</span> dispatch = middle(store.dispatch);</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="comment">//将中间返回的dispatch方法覆盖掉原有store中的dispatch</span></span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> applyMiddleWare(logger)(createStore)(reducer);</span><br></pre></td></tr></table></figure><h3 id="2-实现redux-thunk中间件"><a href="#2-实现redux-thunk中间件" class="headerlink" title="2.实现redux-thunk中间件"></a>2.实现redux-thunk中间件</h3><p>实现派发异步动作,actionCreator可以返回函数，可以把dispatch的权限交给此函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch,getState</span>) </span>&#123;</span><br><span class="line">      dispatch(&#123;<span class="attr">type</span>:Types.ADD,amount&#125;);</span><br><span class="line">      dispatch(&#123;<span class="attr">type</span>:Types.ADD,amount&#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(getState().number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">minus</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:Types.MINUS,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">let</span> reduxThunk = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span></span>)</span>&#123; <span class="comment">//如果是函数将派发的权限传递给函数</span></span><br><span class="line">    <span class="keyword">return</span> action(dispatch,store.getState);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-实现redux-promise中间件"><a href="#3-实现redux-promise中间件" class="headerlink" title="3.实现redux-promise中间件"></a>3.实现redux-promise中间件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="function"><span class="title">minus</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type:Types.MINUS,</span><br><span class="line">      payload:<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">        reject(&#123;<span class="attr">amount</span>:<span class="number">2</span>&#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//store/index.js</span></span><br><span class="line"><span class="keyword">let</span> reduxPromise = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">action.then</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> action.then(dispatch); <span class="comment">//只支持成功</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">action.payload&amp;&amp;action.payload.then</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果payload是一个promise 会对成功和失败都进行捕获并且将成功或失败的数据放到payload中进行派发</span></span><br><span class="line">    <span class="keyword">return</span> action.payload.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      dispatch(&#123;...action,<span class="attr">payload</span>:data&#125;);</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      dispatch(&#123;...action,<span class="attr">payload</span>:data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-compose应用"><a href="#4-compose应用" class="headerlink" title="4.compose应用"></a>4.compose应用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toResult</span>(<span class="params">who,decorator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> who+decorator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们的目的是将第一个函数的返回结果传递给第二个函数</span></span><br><span class="line"><span class="built_in">console</span>.log(len(toResult(<span class="string">&#x27;Mrs jiang&#x27;</span>, <span class="string">&#x27;很帅&#x27;</span>)));</span><br></pre></td></tr></table></figure><h4 id="实现compose"><a href="#实现compose" class="headerlink" title="实现compose"></a>实现compose</h4><p>这个compose也是redux中的一个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>)=&gt;</span><span class="function">(<span class="params">...args</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last = fns.pop();</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">prev,next</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> next(prev);</span><br><span class="line">  &#125;,last(...args))</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(compose(len, toResult)(<span class="string">&#x27;Mrs jiang&#x27;</span>, <span class="string">&#x27;很帅&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="5-applyMiddleware实现"><a href="#5-applyMiddleware实现" class="headerlink" title="5.applyMiddleware实现"></a>5.applyMiddleware实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> applyMiddleWare = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function"><span class="params">reducer</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="keyword">let</span> middles = middlewares.map(<span class="function"><span class="params">middleware</span>=&gt;</span>middleware(store))</span><br><span class="line">  <span class="keyword">let</span> dispatch = compose(...middles)(store.dispatch);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-简化applyMiddleWare应用"><a href="#6-简化applyMiddleWare应用" class="headerlink" title="6.简化applyMiddleWare应用"></a>6.简化applyMiddleWare应用</h3><p>最终实现效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer,applyMiddleware(reduxThunk,reduxPromise));</span><br></pre></td></tr></table></figure><p>最终版redux库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createStore = <span class="function">(<span class="params">reducer, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">let</span> listeners = [];</span><br><span class="line">    <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> state;</span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item());</span><br><span class="line">    &#125;;</span><br><span class="line">    dispatch(&#123;&#125;);</span><br><span class="line">    <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">l</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(l);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(createStore, reducer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        createStore,</span><br><span class="line">        dispatch,</span><br><span class="line">        getState,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> combineReducers = <span class="function">(<span class="params">reducers</span>) =&gt;</span> <span class="function">(<span class="params">newState = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> reducers) &#123;</span><br><span class="line">        newState[key] = reducers[key](newState[key], action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bindActionCreators = <span class="function">(<span class="params">actions, dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> actions) &#123;</span><br><span class="line">        obj[key] = <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(actions[key](...args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> <span class="function">(<span class="params">createStore, reducer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">    <span class="keyword">let</span> middles = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(store));</span><br><span class="line">    <span class="keyword">let</span> dispatch = compose(...middles)(store.dispatch);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...store,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = fns.pop();</span><br><span class="line">        <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next(prev);</span><br><span class="line">        &#125;, fn(...args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react redux中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-hooks</title>
      <link href="2020/10/25/react%E7%AC%94%E8%AE%B0/react-hooks/"/>
      <url>2020/10/25/react%E7%AC%94%E8%AE%B0/react-hooks/</url>
      
        <content type="html"><![CDATA[<h2 id="认识-hooks"><a href="#认识-hooks" class="headerlink" title="认识 hooks"></a>认识 hooks</h2><ul><li><p>Hook 是⼀一个特殊的函数，它可以让你“钩⼊入” React 的特性。例例如， useState 是允许你在 React 函数组件中添加 state 的 Hook</p></li><li><p>如果你在编写函数组件并意识到需要向其添加⼀一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使⽤用 Hook</p></li><li><p>函数组件强制刷新   const [,setCount] = useState({});  不传递一个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 惰性初始 state值</span></span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = useState(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11111</span>); <span class="comment">// 只执行一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使⽤-Effect-Hook"><a href="#使⽤-Effect-Hook" class="headerlink" title="使⽤ Effect Hook"></a>使⽤ Effect Hook</h2><ul><li>Effect Hook 可以让你在函数组件中执⾏行行副作⽤用操作。<br>数据获取，设置订阅以及⼿手动更更改 React 组件中的 DOM 都属于副作⽤用。不不管你知不不知道这些操作，或<br>是“副作⽤用”这个名字，应该都在组件中使⽤用过它们。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 与 componentDidMount 和 componentDidUpdate相似</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更更新 title</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数组件主体内（这⾥里里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器器、记录⽇日志以及执<br>⾏行行其他包含副作⽤用的操作都是不不被允许的，因为这可能会产⽣生莫名其妙的 bug 并破坏 UI 的⼀一致性。<br>使⽤用 useEffect 完成副作⽤用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执⾏行行。你可以<br>把 effect 看作从 React 的纯函数式世界通往命令式世界的逃⽣生通道。</p><h2 id="effect-的条件执⾏"><a href="#effect-的条件执⾏" class="headerlink" title="effect 的条件执⾏"></a>effect 的条件执⾏</h2><p>默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发⽣生变化，它就会被<br>重新创建。<br>然⽽而，在某些场景下这么做可能会矫枉过正。⽐如，在上⼀一章节的订阅示例例中，我们不需要在每次组件<br>更新时都创建新的订阅，⽽而是仅需要在 source props 改变时重新创建。<br>要实现这⼀点，可以给 useEffect 传递第⼆个参数，它是 effect 所依赖的值数组。更更新后的示例例如<br>下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  <span class="comment">// 与 componentDidMount 和 componentDidUpdate相似</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更更新 title</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;p&gt;&#123;date.toLocaleTimeString()&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，只有当 useEffect 第⼆个参数组⾥的数值改变后才会重新创建订阅<br>但依赖项为[],在初次渲染和卸载的时候执行</p><h2 id="清除-effect"><a href="#清除-effect" class="headerlink" title="清除 effect"></a>清除 effect</h2><p>组件卸载时需要清除 effect 创建的诸如订阅或计时器器 ID 等资源。要实现这⼀一点， useEffect<br>函数需返回⼀个清除函数，以防⽌止内存泄漏漏，清除函数会在组件卸载前执⾏行行。<br>执行实际<br>render -useEffect<br>render - 清理函数 - useEffect<br>render - 清理函数 - useEffect<br>render - 清理函数 - useEffect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="react-hooks-竞态"><a href="#react-hooks-竞态" class="headerlink" title="react hooks 竞态"></a>react hooks 竞态</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> didSearch = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (text) &#123;</span><br><span class="line">        dispatch</span><br><span class="line">            (&#123;</span><br><span class="line">                type: <span class="string">&#x27;search/fundSearchApp&#x27;</span>,</span><br><span class="line">                payload: &#123; <span class="attr">input</span>: text, <span class="attr">pageSize</span>: <span class="number">20</span>, <span class="attr">isQueryPerformance</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!didSearch) &#123;</span><br><span class="line">                    setSearchList(res.searchList)</span><br><span class="line">                    setCurrent(res.current)</span><br><span class="line">                    setTotal(res.total)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setSearchList([]);</span><br><span class="line">        setCurrent(<span class="number">1</span>);</span><br><span class="line">        setTotal(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        didSearch = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, [text])</span><br></pre></td></tr></table></figure><p>定义一个字段didSearch利用JS的闭包，每次都是不同的变量，在下一次text变化完成，useEffect会再次执行（渲染页面再去调用return方法再去执行useEffect），如果接口没有返回重新渲染了标识会改变使更新逻辑不再执行。</p><h2 id="自定义-hooks"><a href="#自定义-hooks" class="headerlink" title="自定义 hooks"></a>自定义 hooks</h2><p>自定义 Hook 是⼀一个函数，其名称以 “use” 开头，函数内部可以调⽤用其他的 Hook。<br><code>&lt;p&gt;&#123;useClock().toLocaleTimeString()&#125;&lt;/p&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⾃自定义hook，命名必须以use开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useClock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;date effect&quot;</span>);</span><br><span class="line">    <span class="comment">//只需要在didMount时候执⾏行行就可以了了</span></span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//清除定时器器，类似willUnmount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hooks-使用规则"><a href="#hooks-使用规则" class="headerlink" title="hooks 使用规则"></a>hooks 使用规则</h2><ul><li>只能在函数最外层调⽤用 Hook。不不要在循环、条件判断或者⼦子函数中调⽤用。</li><li>只能在 React 的函数组件中调⽤用 Hook。不不要在其他 JavaScript 函数中调⽤用。（还有⼀一个地⽅方可<br>以调⽤用 Hook —— 就是⾃自定义的 Hook 中。）</li></ul><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>把“创建”函数和依赖项数组作为参数传⼊入 useMemo ，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进⾏行行⾼高开销的计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseMemoPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> expensive = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;compute&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//只有count变化，这⾥里里才重新执⾏行行</span></span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;UseMemoPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;expensive:&#123;expensive&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;input value=&#123;value&#125; onChange=&#123;<span class="function">(<span class="params">event</span>) =&gt;</span> setValue(event.target.value)&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>把内联回调函数及依赖项数组作为参数传⼊入 useCallback ，它将返回该回调函数的 memoized 版本，<br>该回调函数仅在某个依赖项改变时才会更更新。当你把回调函数传递给经过优化的并使⽤用引⽤用相等性去避<br>免⾮非必要渲染（例例如 shouldComponentUpdate ）的⼦子组件时，它将⾮非常有⽤用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback, PureComponent &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseCallbackPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> addClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;UseCallbackPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;input value=&#123;value&#125; onChange=&#123;<span class="function">(<span class="params">event</span>) =&gt;</span> setValue(event.target.value)&#125; /&gt;</span><br><span class="line">      &lt;Child addClick=&#123;addClick&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;child render&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; addClick &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;Child&lt;/h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(addClick())&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) 。</code><br>依赖项数组不不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引⽤用的<br>值都应该出现在依赖项数组中。未来编译器器会更更加智能，届时⾃自动创建数组将成为可能</p><h2 id="useRef-保存引用值"><a href="#useRef-保存引用值" class="headerlink" title="useRef(保存引用值)"></a>useRef(保存引用值)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myswiper = useRef(<span class="literal">null</span>);  </span><br><span class="line">&lt;Swiper ref=&#123;myswiper&#125;/&gt; </span><br></pre></td></tr></table></figure><h2 id="useReducer和useContext-减少组件层级"><a href="#useReducer和useContext-减少组件层级" class="headerlink" title="useReducer和useContext(减少组件层级)"></a>useReducer和useContext(减少组件层级)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">var</span> GlobalContext= React.createContext()</span><br><span class="line"><span class="comment">// 注意此时的reduecer 返回值是一个对象 &#123;isShow:false,list:[]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> [state,dispatch]  = useReducer(reducer,&#123;<span class="attr">isShow</span>:<span class="literal">true</span>,<span class="attr">list</span>:[]&#125;)</span><br><span class="line">  <span class="keyword">return</span>  <span class="xml"><span class="tag">&lt;<span class="name">GlobalContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="xml">    dispatch</span></span><br><span class="line"><span class="xml"> &#125;&#125;&gt;</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">     &#123;</span><br><span class="line">        state.isShow?</span><br><span class="line">        &lt;div &gt;我是选项卡&lt;/div&gt;</span><br><span class="line">       :null</span><br><span class="line">     &#125;</span><br><span class="line">     &#123;props.children&#125;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">GlobalContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Detail</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> &#123;dispatch&#125; = useContext(GlobalContext)</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//隐藏</span></span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type:<span class="string">&quot;Hide&quot;</span>,</span><br><span class="line">      payload:<span class="literal">false</span></span><br><span class="line">   &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//显示</span></span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type:<span class="string">&quot;Show&quot;</span>,</span><br><span class="line">        payload:<span class="literal">true</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    detail</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-forwardRef的使用方式"><a href="#React-forwardRef的使用方式" class="headerlink" title="React.forwardRef的使用方式"></a>React.forwardRef的使用方式</h2><p>引用传递（Ref forwading）是一种通过组件向子组件自动传递 引用ref 的技术。对于应用者的大多数组件来说没什<br>么作用。但是对于有些重复使用的组件，可能有用。例如某些input组件，需要控制其focus，本来是可以使用ref来<br>控制，但是因为该input已被包裹在组件中，这时就需要使用Ref forward来透过组件获得该input的引用。可以透传<br>多层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component,forwardRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App_forwardRef</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  mytext=React.createRef()</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &lt;button type=<span class="string">&quot;button&quot;</span> onClick=&#123;<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.mytext);</span><br><span class="line">        <span class="built_in">this</span>.mytext.current.value=<span class="string">&quot;2222&quot;</span></span><br><span class="line">      &#125;&#125;&gt;获取焦点&lt;/button&gt;</span><br><span class="line">      &lt;Child ref=&#123;<span class="built_in">this</span>.mytext&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里Child是函数式组件</span></span><br><span class="line"><span class="keyword">const</span> Child=forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input defaultValue=<span class="string">&quot;11111&quot;</span> ref=&#123;ref&#125;&gt;&lt;/input&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="react-useImperativeHandle的使用"><a href="#react-useImperativeHandle的使用" class="headerlink" title="react  useImperativeHandle的使用"></a>react  useImperativeHandle的使用</h2><p><code>useImperativeHandle(ref, createHandle, [deps])</code><br>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    focus: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染s时 &lt;FancyInput ref=&#123;inputRef&#125; /&gt; 的父组件可以调用 inputRef.current.focus()。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux</title>
      <link href="2020/10/25/react%E7%AC%94%E8%AE%B0/React-Redux/"/>
      <url>2020/10/25/react%E7%AC%94%E8%AE%B0/React-Redux/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Redux应用"><a href="#React-Redux应用" class="headerlink" title="React-Redux应用"></a>React-Redux应用</h2><h3 id="1-为什么需要高阶组件"><a href="#1-为什么需要高阶组件" class="headerlink" title="1.为什么需要高阶组件"></a>1.为什么需要高阶组件</h3><p>我们先看一个非常常见的例子，一个输入框需要从本地获取数据将获取的数据放到输入框内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default class Username extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;val:&#39;&#39;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    let username &#x3D; localStorage.getItem(&#39;username&#39;)||&#39;&#39;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      val:username</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.val&#125; onChange&#x3D;&#123;()&#x3D;&gt;&#123;&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段逻辑可能在Password组件中也要使用，那么从本地存储中获取数据放到输入框内的逻辑应该就是公用逻辑。这时我们就要使用高阶组件，也就是将组件在原有的基础上进行包装。</p></blockquote><a id="more"></a><h3 id="2-实现高阶组件"><a href="#2-实现高阶组件" class="headerlink" title="2.实现高阶组件"></a>2.实现高阶组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">let local &#x3D; (key)&#x3D;&gt;(Component)&#x3D;&gt;&#123;</span><br><span class="line">  return class HighOrderComponent extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state &#x3D; &#123;val:&#39;&#39;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      let username &#x3D; localStorage.getItem(key)||&#39;&#39;;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        val:username</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return &lt;Component &#123;...this.state&#125;&#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default local;</span><br><span class="line"></span><br><span class="line">import Local from &#39;.&#x2F;Local&#39;</span><br><span class="line">class Username extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.props.val&#125; onChange&#x3D;&#123;()&#x3D;&gt;&#123;&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Local(&#39;username&#39;)(Username);</span><br></pre></td></tr></table></figure><blockquote><p>我们将公共的逻辑拿到外层组件，处理好后以属性的方式传递给原本的组件，为此高阶组件就是一个 React 组件包裹着另外一个 React 组件</p></blockquote><h3 id="3-context的用法"><a href="#3-context的用法" class="headerlink" title="3.context的用法"></a>3.context的用法</h3><p>react是单向数据流，我们想传递数据需要一层层向下传递，数据传递变得非常麻烦,我们可以用context实现数据的交互</p><ol><li><p>父 childContextTypes getChildContext函数</p></li><li><p>子 contextTypes</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App |-&gt; header -&gt; title</span><br></pre></td></tr></table></figure><h4 id="跨组件交互"><a href="#跨组件交互" class="headerlink" title="跨组件交互"></a>跨组件交互</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;</span><br><span class="line">import Header from &quot;.&#x2F;Header&quot;;</span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;color:&#39;red&#39;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static childContextTypes &#x3D; &#123; &#x2F;&#x2F;定义子组件上下文的类型</span><br><span class="line">    color:PropTypes.string,</span><br><span class="line">    setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  setColor &#x3D; (color) &#x3D;&gt;&#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        color</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123; &#x2F;&#x2F; 定义子组件上下文的数据</span><br><span class="line">    return &#123;color:this.state.color,setColor:this.setColor&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;Header&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Header extends React.Component &#123;</span><br><span class="line">  static contextTypes &#x3D; &#123;</span><br><span class="line">     setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;</span><br><span class="line">        this.context.setColor(&#39;green&#39;);</span><br><span class="line">      &#125;&#125;&gt;变绿&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;Title&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Title extends React.Component &#123;</span><br><span class="line">  static contextTypes &#x3D; &#123;</span><br><span class="line">    color:PropTypes.string</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123; &#x2F;&#x2F; 通过context获取父组件定义的数据</span><br><span class="line">    return &lt;div style&#x3D;&#123;&#123;color:this.context.color&#125;&#125;&gt;Title&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用react-redux实现todo"><a href="#4-使用react-redux实现todo" class="headerlink" title="4.使用react-redux实现todo"></a>4.使用react-redux实现todo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Todos |-&gt; TodoHeader</span><br><span class="line">      |-&gt; TodoItems</span><br><span class="line">      |-&gt; TodoFooter</span><br></pre></td></tr></table></figure><h3 id="5-实现react-redux库"><a href="#5-实现react-redux库" class="headerlink" title="5.实现react-redux库"></a>5.实现react-redux库</h3><h4 id="react-redux计数器"><a href="#react-redux计数器" class="headerlink" title="react-redux计数器"></a>react-redux计数器</h4><p>和以前写过的逻辑一致,这回加上react-redux的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import Counter from &quot;.&#x2F;components&#x2F;Counter&quot;;</span><br><span class="line">import store from &#39;.&#x2F;store&#x2F;index&#39;;</span><br><span class="line">import &#123;Provider&#125; from &#39;react-redux&#39;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    &lt;Counter&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;,window.root);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; counter组件</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      数量:&#123;this.props.number&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.props.add(1)&#125;&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button  onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.props.minus(1)&#125;&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),dispatch&#x3D;&gt;(&#123;</span><br><span class="line">  add:(amount)&#x3D;&gt;&#123;dispatch(actions.add(amount))&#125;,</span><br><span class="line">  minus:(amount)&#x3D;&gt;&#123;dispatch(actions.minus(amount))&#125;</span><br><span class="line">&#125;))(Counter)</span><br></pre></td></tr></table></figure><h4 id="编写react-redux库"><a href="#编写react-redux库" class="headerlink" title="编写react-redux库"></a>编写react-redux库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line">class Provider extends React.Component&#123;</span><br><span class="line">  static childContextTypes &#x3D; &#123;</span><br><span class="line">    store:PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123;</span><br><span class="line">    return &#123;store:this.props.store&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let connect &#x3D; (mapStateToProps,mapDispatchToProps) &#x3D;&gt; (Component) &#x3D;&gt;&#123;</span><br><span class="line">  return class Proxy extends React.Component&#123;</span><br><span class="line">    static contextTypes &#x3D; &#123;</span><br><span class="line">      store:PropTypes.object</span><br><span class="line">    &#125;;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      this.unsubscribe &#x3D; this.context.store.subscribe(()&#x3D;&gt;&#123;</span><br><span class="line">        this.setState(mapStateToProps(this.context.store.getState()))</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">      this.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(props,context)&#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state &#x3D; mapStateToProps(context.store.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return &lt;Component &#123;...this.state&#125; &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;&#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;Provider,connect&#125;</span><br></pre></td></tr></table></figure><h4 id="bindActionCreators方法"><a href="#bindActionCreators方法" class="headerlink" title="bindActionCreators方法"></a>bindActionCreators方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let bindActionCreators &#x3D; (actions,dispatch) &#x3D;&gt; &#123;</span><br><span class="line">  let obj &#x3D; &#123;&#125;</span><br><span class="line">  for(let key in actions)&#123;</span><br><span class="line">    obj[key] &#x3D; (...args)&#x3D;&gt;&#123;</span><br><span class="line">      dispatch(actions[key](...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),dispatch&#x3D;&gt;bindActionCreators(actions,dispatch))(Counter)</span><br></pre></td></tr></table></figure><blockquote><p>bindActionCreators是redux中的一个方法，并且这样的逻辑过于复杂，我们依旧希望可以在react-redux中内部可以简化操作</p></blockquote><h4 id="简化mapDispatchToProps"><a href="#简化mapDispatchToProps" class="headerlink" title="简化mapDispatchToProps"></a>简化mapDispatchToProps</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),actions)(Counter);</span><br><span class="line"></span><br><span class="line">import &#123;bindActionCreators&#125; from &#39;.&#x2F;redux&#39;</span><br><span class="line">render()&#123;</span><br><span class="line">  let r &#x3D;&#123;&#125;</span><br><span class="line">  if(typeof mapDispatchToProps &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">    r &#x3D; bindActionCreators(mapDispatchToProps,this.context.store.dispatch)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    r &#x3D; mapDispatchToProps(this.context.store.dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;Component &#123;...this.state&#125; &#123;...r&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样我们在组件中更改状态时可以直接传入actionCreator对象。</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react Redux深入</title>
      <link href="2020/10/24/react%E7%AC%94%E8%AE%B0/Redux%E6%B7%B1%E5%85%A5/"/>
      <url>2020/10/24/react%E7%AC%94%E8%AE%B0/Redux%E6%B7%B1%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Redux深入"><a href="#Redux深入" class="headerlink" title="Redux深入"></a>Redux深入</h2><h3 id="1-redux文件拆分"><a href="#1-redux文件拆分" class="headerlink" title="1.redux文件拆分"></a>1.redux文件拆分</h3><p>我们将计数器的案例进行文件拆分,使代码更加容易维护和阅读,我们来增加一个store文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store</span><br><span class="line">    │  action-types.js</span><br><span class="line">    │  index.js</span><br><span class="line">    │</span><br><span class="line">    ├─actions</span><br><span class="line">    │      counter.js</span><br><span class="line">    │</span><br><span class="line">    └─reducer</span><br><span class="line">            counter.js</span><br></pre></td></tr></table></figure><ul><li><p>action-types用来存放需要的常量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const ADD &#x3D; &#39;ADD&#39;;</span><br><span class="line">export const MINUS &#x3D; &#39;MINUS&#39;;</span><br></pre></td></tr></table></figure></li><li><p>counter中存放reducer的逻辑</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default function reducer(state&#x3D;&#123;number:0&#125;,action) &#123;</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case Types.ADD:</span><br><span class="line">      return &#123;number:state.number + action.amount&#125;;</span><br><span class="line">    case Types.MINUS:</span><br><span class="line">      return &#123;number:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>store中的index文件用来创建store</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;../redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer/counter&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer);</span><br></pre></td></tr></table></figure></li><li><p>组件中的内容可更改为</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM,&#123;render&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Types <span class="keyword">from</span> <span class="string">&#x27;./store/action-types&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    store.subscribe( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:Types.ADD,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:Types.MINUS,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleAddClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleMinusClick&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>此时我们发现在redux和组件中都应用了action-types所以我们希望继续进行拆分,在store下创建action文件夹,用来生成action对象,我们管action文件中的方法称之为actionCreator</p></blockquote><ul><li><p>action文件夹中的counter,用来生成对应组件的action对象</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Types <span class="keyword">from</span> <span class="string">&#x27;../action-types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:Types.ADD,amount&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">minus</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:Types.MINUS,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次更改组件代码</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM,&#123;render&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&#x27;./store/actions/counter&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    store.subscribe( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(actions.add(<span class="number">1</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(actions.minus(<span class="number">1</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleAddClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleMinusClick&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>我们已经将redux的流程进行了详细的拆分,让我们来总结一下redux的流程吧：</p></blockquote><p><img src="http://son.fullstackjavascript.cn/redux.png"></p><h3 id="2-实现多个counter"><a href="#2-实现多个counter" class="headerlink" title="2.实现多个counter"></a>2.实现多个counter</h3><p>在redux中只能拥有一个store所以我们需要将多个状态进行合并,状态是通过reducer返回的，所以我们可以将多个reducer进行合并达到合并状态的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">│  index.js</span><br><span class="line">│  redux.js</span><br><span class="line">│</span><br><span class="line">├─components</span><br><span class="line">│      counter1.js</span><br><span class="line">│      counter2.js</span><br><span class="line">│</span><br><span class="line">└─store</span><br><span class="line">    │  action-types.js</span><br><span class="line">    │  index.js</span><br><span class="line">    │</span><br><span class="line">    ├─actions</span><br><span class="line">    │      counter1.js</span><br><span class="line">    │      counter2.js</span><br><span class="line">    │</span><br><span class="line">    └─reducer</span><br><span class="line">            counter1.js</span><br><span class="line">            counter2.js</span><br><span class="line">            index.js</span><br></pre></td></tr></table></figure><blockquote><p>这里我们将counter1的逻辑进行拷贝，粘贴出counter2</p></blockquote><ul><li><p>action-types新增counter2处理的常量</p>  <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const ADD = &#x27;ADD&#x27;;</span><br><span class="line">export const MINUS = &#x27;MINUS&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ export const INCREMENT = &#x27;INCREMENT&#x27;;</span></span><br><span class="line"><span class="addition">+ export const DECREMENT = &#x27;DECREMENT&#x27;;</span></span><br></pre></td></tr></table></figure></li><li><p>对应的counter2中的action也进行更改</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Types <span class="keyword">from</span> <span class="string">&#x27;../action-types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:Types.INCREMENT,amount&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">minus</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:Types.DECREMENT,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样reducer中处理也是一样的</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Types <span class="keyword">from</span> <span class="string">&#x27;../action-types&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=&#123;number:<span class="number">0</span>&#125;,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> Types.INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number + action.amount&#125;;</span><br><span class="line">    <span class="keyword">case</span> Types.DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在问题出现了我们拥有了两个reducer,我们要将两个reducer进行合并,合并成一个新的reducer</p></blockquote></li><li><p>combineReducers</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> counter1 <span class="keyword">from</span> <span class="string">&#x27;./counter1&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counter2 <span class="keyword">from</span> <span class="string">&#x27;./counter2&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> combineReducers = <span class="function">(<span class="params">reducers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">state=&#123;&#125;,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> key <span class="keyword">in</span> reducers</span>)</span>&#123;</span><br><span class="line">      obj[key] = reducers[key](state[key],action); <span class="comment">//调用原有的reducer将返回的结果放到对象上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">// 将合并后的对象进行返回即可 &#123;counter1:&#123;number:0&#125;,counter2:&#123;number:0&#125;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  counter1,counter2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>最后组件中获取状态要增加合并时的命名空间来获取</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:store.getState().counter1.number&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    store.subscribe( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:store.getState().counter1.number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react Redux</title>
      <link href="2020/10/23/react%E7%AC%94%E8%AE%B0/Redux%E5%BA%94%E7%94%A8/"/>
      <url>2020/10/23/react%E7%AC%94%E8%AE%B0/Redux%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><p>我们一直通过属性来进行组件中的数据传递,这种模式是非常脆弱的。在日常的开发中经常会遇到非父子组件传递的场景。原来的方式是找到共同的父级进行数据交互，这时通信就变得比较麻烦<br>我们先通过一个简单的例子实现一下redux的工作模式:</p><h2 id="redux的理解-提供的API"><a href="#redux的理解-提供的API" class="headerlink" title="redux的理解 提供的API"></a>redux的理解 提供的API</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createStore()</span><br><span class="line">applyMiddleWare()</span><br><span class="line">combineReducers()</span><br><span class="line">store.getState()/dispatch()/subscribe()</span><br></pre></td></tr></table></figure><h3 id="1-统一数据管理"><a href="#1-统一数据管理" class="headerlink" title="1).统一数据管理"></a>1).统一数据管理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">  content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.content&#x27;</span>);</span><br><span class="line">  content.innerHTML = state.content.text;</span><br><span class="line">  content.style.color = state.content.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.title&#x27;</span>);</span><br><span class="line">  title.innerHTML = state.title.text;</span><br><span class="line">  title.style.color = state.title.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line">renderApp();</span><br></pre></td></tr></table></figure><blockquote><p>这里我们可以将renderContent,renderTitle看成两个组件将所需的数据提取到state中统一进行管理。当渲染后我们希望更改状态，封装更改状态的方法(dispatch)</p></blockquote><a id="more"></a><h3 id="2-实现dispatch"><a href="#2-实现dispatch" class="headerlink" title="2).实现dispatch"></a>2).实现dispatch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">      state = &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不要直接更改状态而是使用dispatch方法进行状态的更改,派发一个带有type的属性来进行状态的更改，但是依然无法阻止用户更改状态.</p></blockquote><h3 id="3-createStore的实现"><a href="#3-createStore的实现" class="headerlink" title="3).createStore的实现"></a>3).createStore的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = &#123;</span><br><span class="line">    title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">    content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)); <span class="comment">// 创造一份和状态同样的对象给外界来用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">      <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">        state = &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = createStore(); <span class="comment">// 拿到createStore中返回的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.content&#x27;</span>);</span><br><span class="line">  content.innerHTML = store.getState().content.text;</span><br><span class="line">  content.style.color = store.getState().content.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.title&#x27;</span>);</span><br><span class="line">  title.innerHTML = store.getState().title.text;</span><br><span class="line">  title.style.color = store.getState().title.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line">renderApp();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><!-- more --><blockquote><p>我们将状态放到了createStore函数中，目的是隔离作用域，并且再内部返回深度克隆的对象，这样用户无法再通过外界更改状态。但是状态应该由我们自身来控制，应该是外界传入的，所以要将状态拿出createStore。并且判断的逻辑也应该由我们自己来编写</p></blockquote><h3 id="4-reducer的实现"><a href="#4-reducer的实现" class="headerlink" title="4).reducer的实现"></a>4).reducer的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123; </span><br><span class="line">    state  = reducer(state,action);<span class="comment">//获取对应的状态覆盖掉store中的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;&#125;); <span class="comment">// 默认传入空对象获取reducer返回的默认结果</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> initState = &#123;</span><br><span class="line">  title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">  content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// reducer应该具有默认状态,当更改状态后使用最新的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=initState,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时我们已将需要自己处理的逻辑提取出来，但是我们每次dispatch时都需要自己触发视图的更新,我们希望采用发布订阅来实现。</p></blockquote><h3 id="5-订阅函数"><a href="#5-订阅函数" class="headerlink" title="5).订阅函数"></a>5).订阅函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = []; <span class="comment">// 放置所有订阅的函数</span></span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span>=&gt;</span>item());<span class="comment">//每次派发后执行订阅的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">fn</span>)=&gt;</span>&#123; <span class="comment">//主要用于订阅事件</span></span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123; <span class="comment">//返回一个移除监听的方法</span></span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span>=&gt;</span>l!==fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(renderApp); <span class="comment">//通过suscribe订阅派发时需要触发的函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>此时我们redux中常用的方法已经封装完成！^_^,我们将封装好的逻辑抽离成redux.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = []; <span class="comment">// 放置所有订阅的函数</span></span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span>=&gt;</span>item());<span class="comment">//每次派发后执行订阅的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">fn</span>)=&gt;</span>&#123; <span class="comment">//主要用于订阅事件</span></span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123; <span class="comment">//返回一个移除监听的方法</span></span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span>=&gt;</span>l!==fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-应用redux-js实现counter"><a href="#2-应用redux-js实现counter" class="headerlink" title="2.应用redux+js实现counter"></a>2.应用redux+js实现counter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;container&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;add&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;minus&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;redux.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> MINUS = <span class="string">&#x27;MINUS&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=&#123;number:<span class="number">0</span>&#125;,action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">      <span class="keyword">case</span> ADD:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number + action.amount&#125;;</span><br><span class="line">      <span class="keyword">case</span> MINUS:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number - action.amount&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = store.getState().number</span><br><span class="line">  &#125;</span><br><span class="line">  render();</span><br><span class="line">  store.subscribe(render);</span><br><span class="line">  add.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:ADD,<span class="attr">amount</span>:<span class="number">1</span>&#125;)</span><br><span class="line">  &#125;,<span class="literal">false</span>);</span><br><span class="line">  minus.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:MINUS,<span class="attr">amount</span>:<span class="number">2</span>&#125;)</span><br><span class="line">  &#125;,<span class="literal">false</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>由此我们使用了自己的redux库链接了原生js进行使用。</p></blockquote><h2 id="3-应用redux-react实现counter"><a href="#3-应用redux-react实现counter" class="headerlink" title="3.应用redux+react实现counter"></a>3.应用redux+react实现counter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM,&#123;render&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;./redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> MINUS = <span class="string">&#x27;MINUS&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=&#123;number:<span class="number">0</span>&#125;,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> ADD:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number + action.amount&#125;;</span><br><span class="line">    <span class="keyword">case</span> MINUS:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    store.subscribe( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:ADD,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:MINUS,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleAddClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleMinusClick&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><blockquote><p>这里我们将redux数据映射到了组件自己的状态，并且订阅了setState事件。每次状态更新时都会重新刷新组件</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 路由的使用</title>
      <link href="2020/10/22/react%E7%AC%94%E8%AE%B0/React%E8%B7%AF%E7%94%B1/"/>
      <url>2020/10/22/react%E7%AC%94%E8%AE%B0/React%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>本章我们来介绍react中路由的使用,现在使用的路由是React-Router-4版本,我们需要下载的包叫react-router-dom</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>这里我们下载好后需要他内部的路由容器组件,主要包含BrowserRouter,HashRouter,MemoryRouter</p></blockquote><h3 id="容器组件的区别"><a href="#容器组件的区别" class="headerlink" title="容器组件的区别"></a>容器组件的区别</h3><ul><li>BrowserRouter: 浏览器自带的H5 API,restful风格,需要配合后台；</li><li>HashRouter: 使用hash方式进行路由,路径后均有#；</li><li>MemoryRouter: 在内存中管理history，地址栏不会变化。在reactNative中使用。</li></ul><blockquote><p>在开发时我们一般使用HashRouter,上线后我们改用BrowserRouter</p></blockquote><h3 id="跑通基本路由"><a href="#跑通基本路由" class="headerlink" title="跑通基本路由"></a>跑通基本路由</h3><p>我们来声明三个组件Home,User,Profile希望访问不同的路径可以实现显示不同的组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter,Route&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> Home = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> Profile = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Profile<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> User = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>User<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">ReactDOM.render(&lt;HashRouter&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/home&quot;</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/profile&quot;</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;User&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/HashRouter&gt;,<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>这里我们使用了HashRouter,代码一目了然,这里用到了Route组件,Route组件上有path和component属性,对应的path会显示对应的component,这里还需注意HashRouter必须只能包含一个根元素,所以我们在所有的Route外层包了一个div标签</p></blockquote><h3 id="路由的匹配"><a href="#路由的匹配" class="headerlink" title="路由的匹配"></a>路由的匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们稍作了下更改当访问/profile/user时你会发现/profile路由也会命中。所以说明只要路径开头匹配成功既会显示对应的组件,假如你希望不管访问任何路径时都能显示某一个组件你可以将path写成’/‘</p></blockquote><h3 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h3><p>我们先来引入bootstrap,将刚才的代码逻辑进行拆分,增加导航条点击不同的导航显示不同的组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123;HashRouter,Route&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">import &#39;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import Home from &#39;.&#x2F;components&#x2F;Home&#39;;</span><br><span class="line">import Profile from &#39;.&#x2F;components&#x2F;Profile&#39;;</span><br><span class="line">import User from &#39;.&#x2F;components&#x2F;User&#39;;</span><br><span class="line">ReactDOM.render(&lt;HashRouter&gt;</span><br><span class="line">    &lt;App&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;App&gt;</span><br><span class="line">&lt;&#x2F;HashRouter&gt;,document.querySelector(&#39;#root&#39;));</span><br></pre></td></tr></table></figure><blockquote><p>这里我们增加了App组件,为什么这样做呢?原因是我们并不希望将所有的逻辑都写在index中,这并不方便我们的管理,还记得children属性吗？我们可以直接在App中通过children的方式引入</p></blockquote><h3 id="增加导航"><a href="#增加导航" class="headerlink" title="增加导航"></a>增加导航</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Link&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">export default class App extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;navbar-inverse navbar&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;container-fluid&quot;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&quot;navbar-header&quot;&gt;</span><br><span class="line">                            &lt;div className&#x3D;&quot;navbar-brand&quot;&gt;</span><br><span class="line">                                用户管理系统</span><br><span class="line">                            &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;ul className&#x3D;&quot;navbar-nav nav&quot;&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;home&#39;&#125;&gt;首页&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;user&#39;&#125;&gt;用户管理&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;profile&#39;&#125;&gt;个人中心&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                        &lt;&#x2F;ul&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;row&quot;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&quot;col-md-12&quot;&gt;</span><br><span class="line">                            &#123;this.props.children&#125;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用Link组件它可以替代我们自己写的a标签,因为后面我们可能会用到browserHistory，跳转可能需要用到H5的api进行跳转,Link组件是react路由中提供的声明式组件,可以帮我们区分路由的模式来实现路由的跳转。</p></blockquote><h3 id="页面级组件"><a href="#页面级组件" class="headerlink" title="页面级组件"></a>页面级组件</h3><p>这里我们先将对应的组件代码代码贴出来,后面我们来完善对用的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Home.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class Home extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Home&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Profile.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class Profile extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Profile&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; User.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class User extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;User&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h3><p>刚才我们实现了一级导航,但是一般情况下管理系统都会拥有二级导航,比如说我们希望用户管理中包含用户列表和添加用户,这两个菜单应该属于用户列表下的子导航,我们先来看下效果</p><h4 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h4><p>二级导航就是在某个一级路由中继续嵌套路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">import UserList from &#39;.&#x2F;UserList&#39;</span><br><span class="line">import UserAdd from &#39;.&#x2F;UserAdd&#39;</span><br><span class="line">export default class User extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className&#x3D;&quot;row&quot;&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;col-md-2&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;nav nav-stacked&quot;&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to&#x3D;&#39;&#x2F;user&#x2F;list&#39;&gt;用户列表&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to&#x3D;&#39;&#x2F;user&#x2F;add&#39;&gt;增加用户&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;col-md-10&quot;&gt;</span><br><span class="line">                    &lt;Route path&#x3D;&quot;&#x2F;user&#x2F;list&quot; component&#x3D;&#123;UserList&#125;&#x2F;&gt;</span><br><span class="line">                    &lt;Route path&#x3D;&quot;&#x2F;user&#x2F;add&quot; component&#x3D;&#123;UserAdd&#125;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里并没有什么需要注意的新用法,只是路径要特殊处理一下因为是二级路由,要保证一级路由也同时显示所以开头要和一级路由路径相同。如果多次点击相同路由时会触发<code>Hash history cannot PUSH the same path;</code>这样的一个警告,这个是无法去除的但是改成BrowserHistory就不会触发此警告了。所有不用担心.</p></blockquote><h4 id="UserList和Add组件"><a href="#UserList和Add组件" class="headerlink" title="UserList和Add组件"></a>UserList和Add组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; UserList.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserList extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;UserList&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; UserAdd.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserAdd extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;UserAdd&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里我们先不写任何逻辑，先将具体的功能实现出来。这样我们就实现了二级路。</p></blockquote><h3 id="路由跳转和路径参数"><a href="#路由跳转和路径参数" class="headerlink" title="路由跳转和路径参数"></a>路由跳转和路径参数</h3><p>本节我们完善一下内部的逻辑,进入到添加列表页可以实现用户的添加并且可以跳转到列表页面渲染出添加的用户列表,页面间的通信我们采用localStorage。并且点击某个用户可以进入到用户详情页。</p><h4 id="实现添加用户"><a href="#实现添加用户" class="headerlink" title="实现添加用户"></a>实现添加用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserAdd extends React.Component&#123;</span><br><span class="line">    handleSubmit &#x3D; (e) &#x3D;&gt;&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        let localStr &#x3D; localStorage.getItem(&#39;lists&#39;);</span><br><span class="line">        let list &#x3D; JSON.parse(localStr)|| [];</span><br><span class="line">        list.push(&#123;id:Math.random(),name:this.name.value&#125;);</span><br><span class="line">        localStorage.setItem(&#39;lists&#39;,JSON.stringify(list));</span><br><span class="line">        this.props.history.push(&#39;&#x2F;user&#x2F;list&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;label htmlFor&#x3D;&quot;name&quot; className&#x3D;&quot;control-label&quot;&gt;</span><br><span class="line">                            用户名:</span><br><span class="line">                        &lt;&#x2F;label&gt;</span><br><span class="line">                        &lt;input type&#x3D;&quot;text&quot; className&#x3D;&quot;form-control&quot; ref&#x3D;&#123;x&#x3D;&gt;this.name &#x3D; x&#125;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;button className&#x3D;&quot;btn btn-primary&quot;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;form&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们在props中使用了history的API,所有通过路由渲染的组件都拥有一些路由的属性后面我们会一一介绍到。这里我们采用编程式的方式跳转了路径。</p></blockquote><h4 id="列表页展示"><a href="#列表页展示" class="headerlink" title="列表页展示"></a>列表页展示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default class UserList extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state &#x3D; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        let userList &#x3D; JSON.parse(localStorage.getItem(&#39;lists&#39;));</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            userList</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ul className&#x3D;&quot;list-group&quot;&gt;</span><br><span class="line">                    &#123;this.state.userList.map((user,index)&#x3D;&gt;(</span><br><span class="line">                        &lt;li className&#x3D;&quot;list-group-item&quot; key&#x3D;&#123;index&#125;&gt;</span><br><span class="line">                            &lt;Link to&#x3D;&#123;&quot;&#x2F;user&#x2F;detail&#x2F;&quot;+user.id&#125;&gt;&#123;user.name&#125;&lt;&#x2F;Link&gt;</span><br><span class="line">                        &lt;&#x2F;li&gt;</span><br><span class="line">                    ))&#125;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的逻辑比较简单,我们又添加了一个detail路径同样也是一个二级路由，点击用户名可以显示具体的用户id和用户名。</p></blockquote><h4 id="引入UserDetail组件"><a href="#引入UserDetail组件" class="headerlink" title="引入UserDetail组件"></a>引入UserDetail组件</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ import UserDetail from &#x27;./UserDetail&#x27;;</span></span><br><span class="line">  &lt;Route path=&quot;/user/list&quot; component=&#123;UserList&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/user/add&quot; component=&#123;UserAdd&#125;/&gt;</span><br><span class="line"><span class="addition">+ &lt;Route path=&quot;/user/detail/:id&quot; component=&#123;UserDetail&#125;/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里我们采用了模糊匹配的方式,这就是我们常说的路径参数。也就是说id可以代表任何值，我们可以在详情页中通过this.props.match.params.id获取到真实传入的id</p></blockquote><h4 id="UserDetail详情页"><a href="#UserDetail详情页" class="headerlink" title="UserDetail详情页"></a>UserDetail详情页</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserDetail extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123;id &#125; &#x3D; this.props.match.params;</span><br><span class="line">        let &#123;name&#125; &#x3D; JSON.parse(localStorage.getItem(&#39;lists&#39;)).find(item&#x3D;&gt;item.id &#x3D;&#x3D; id);</span><br><span class="line">        return (</span><br><span class="line">            &lt;table className&#x3D;&quot;table table-bordered&quot;&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;th&gt;id号&lt;&#x2F;th&gt;</span><br><span class="line">                        &lt;th&gt;标题&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;&#123;id&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;name&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;tbody&gt;</span><br><span class="line">            &lt;&#x2F;table&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里要注意通过params取出的结果都是字符串类型,所有匹配到的参数都会放在match.params的属性上。</p></blockquote><h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>有的时候我们希望对路由匹配有些限制,比如说严格对某个路径进行匹配,或者匹配到某个路径时就不在匹配</p><h4 id="新增路由匹配"><a href="#新增路由匹配" class="headerlink" title="新增路由匹配"></a>新增路由匹配</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line"><span class="addition">+       &lt;Route path=&quot;/&quot; render=&#123;()=&gt;&lt;h1&gt;首页&lt;/h1&gt;&#125;/&gt;</span></span><br><span class="line"><span class="addition">+       &lt;Route path=&quot;/:name&quot; render=&#123;()=&gt;&lt;h1&gt;zfpx&lt;/h1&gt;&#125;/&gt;</span></span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;/App&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在此我们会发现当访问/home时以上<code>首页</code>和<code>zfpx</code>和<code>home组件</code>都会访问到,而我们只希望在访问/时才会显示首页,我们可以在某个Route上增加exact属性</p></blockquote><h4 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;&quot; exact render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>你会发现这样就实现啦~,只会当访问/时才可以匹配到。</p></blockquote><h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p>但是现在访问/home时我们依然有两个组件会被匹配到，我们希望匹配到一个后就停止匹配，不在继续匹配下一个路由，我们可以使用Switch组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter,Route,Switch&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;&quot; exact render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;:name&quot; render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Switch&gt;</span><br></pre></td></tr></table></figure><blockquote><p>现在访问/home你会发现Home组件永远都不会显示出来啦！</p></blockquote><h3 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h3><p>我们想对一些路由进行屏蔽,例如登录后才能访问,这里我们在本地存一个变量来表示是否登录,增加一个登录路由，点击登录按钮将本地变量改为登录成功状态,即可以访问用户列表页面</p><h3 id="受保护路由"><a href="#受保护路由" class="headerlink" title="受保护路由"></a>受保护路由</h3><p>我们匹配到/user路由时要根据状态判断是否有权限，如果没权限需要跳转到登录页面，主要靠的是高阶组件的思想来实现:</p><h4 id="Protected组件"><a href="#Protected组件" class="headerlink" title="Protected组件"></a>Protected组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Redirect&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default (&#123;component:Component,...others&#125;)&#x3D;&gt;&#123;</span><br><span class="line">   return &lt;Route &#123;...others&#125; render&#x3D;&#123;(props)&#x3D;&gt;&#123;</span><br><span class="line">       return localStorage.getItem(&#39;loginSystem&#39;)?&lt;Component &#123;...props&#125;&#x2F;&gt;:&lt;Redirect to&#x3D;&#123;&#123;</span><br><span class="line">           pathname:&#39;&#x2F;login&#39;,</span><br><span class="line">           from:props.match.url</span><br><span class="line">       &#125;&#125;&#x2F;&gt;</span><br><span class="line">   &#125;&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Redirect组件是用来重定向的，我们新增from属性来记录当前匹配的url,为了保证登录后可以在跳回到当前匹配的路径</p></blockquote><h4 id="新增Login组件"><a href="#新增Login组件" class="headerlink" title="新增Login组件"></a>新增Login组件</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line"><span class="deletion">-   &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span></span><br><span class="line"><span class="addition">+   &lt;PrivateRoute path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span></span><br><span class="line">    &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line"><span class="addition">+   &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Login.js</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">export default class Login extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button className=&quot;btn btn-primary&quot; onClick=&#123;()=&gt;&#123;</span><br><span class="line">                    window.localStorage.setItem(&#x27;loginSystem&#x27;,true);</span><br><span class="line">                   this.props.history.push(this.props.location.from)</span><br><span class="line">                &#125;&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们发现默认点击profile会默认跳转到login组件中，点击登录可以再次跳回profile。这样我们就实现了受保护的路由。</p></blockquote><h3 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h3><p>我们想给点击后的菜单增加激活样式，同样依然采用高阶组件的方式进行包装</p><h4 id="实现MenuLink组件"><a href="#实现MenuLink组件" class="headerlink" title="实现MenuLink组件"></a>实现MenuLink组件</h4><p>此组件是用来替换掉原有的Link组件，并且在内部进行判断是否增加激活状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default (&#123;to,label&#125;)&#x3D;&gt;&#123;</span><br><span class="line">    return &lt;Route children&#x3D;&#123;(props)&#x3D;&gt;&#123;</span><br><span class="line">        return &lt;li className&#x3D;&#123;props.match?&#39;active&#39;:&#39;&#39;&#125;&gt;&lt;Link to&#x3D;&#123;to&#125;&gt;&#123;label&#125;&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &#125;&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个children属性和以前render不同，children无论是否路由匹配到都会执行此函数。而render只要在匹配到后才会执行</p></blockquote><h3 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h3><p>我们希望在添加页的输入框中输入内容后点击其他路由时先询问一下是否需要跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;show:false&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Prompt when&#x3D;&#123;this.state.show&#125; message&#x3D;&#123;location &#x3D;&gt; (</span><br><span class="line">        &#96;Are you sure you want to go to $&#123;location.pathname&#125;?&#96;</span><br><span class="line">    )&#125;&#x2F;&gt;</span><br><span class="line">    &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">            &lt;label htmlFor&#x3D;&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; className&#x3D;&quot;form-control&quot; ref&#x3D;&#123;(x)&#x3D;&gt;this.x&#x3D;x&#125;</span><br><span class="line">               onChange&#x3D;&#123;(e)&#x3D;&gt;&#123;</span><br><span class="line">                   if(e.target.value.length&gt;0)&#123;</span><br><span class="line">                       this.setState(&#123;show:true&#125;)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">            &lt;button className&#x3D;&quot;btn btn-primary&quot; &gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>监听输入框中的内容,当有内容时将状态show变为true,当需要跳转路由时Prompt的组件when属性为true就会提示对应的message,当然我们点击添加时不需要弹出,所以先将状态改为false在进行跳转即可。</p></blockquote><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit=(e)=&gt;&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    let list = JSON.parse(localStorage.getItem(&#x27;lists&#x27;))||[];</span><br><span class="line">    list.push(&#123;id:Math.random(),name:this.x.value&#125;);</span><br><span class="line">    localStorage.setItem(&#x27;lists&#x27;,JSON.stringify(list));</span><br><span class="line"><span class="addition">+   this.setState(&#123;show:false&#125;,()=&gt;&#123;</span></span><br><span class="line">        this.props.history.push(&#x27;/profile/list&#x27;)</span><br><span class="line"><span class="addition">+   &#125;)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>要等待状态改变后在执行跳转，因为setState是异步的所以要将跳转逻辑放的回调函数中。</p></blockquote><h2 id="NotFound页面"><a href="#NotFound页面" class="headerlink" title="NotFound页面"></a>NotFound页面</h2><p>我们需要当路由都匹配不到时显示一个404页面,增加一个404组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class NotFound extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;NotFound&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增404路由"><a href="#新增404路由" class="headerlink" title="新增404路由"></a>新增404路由</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;PrivateRoute path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span><br><span class="line"><span class="addition">+       &lt;Route component=&#123;NotFound&#125;/&gt;</span></span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们使用switch组件当全部匹配不到时会默认渲染404路由,这样我们就实现了404页面</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 基础</title>
      <link href="2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React?"></a>什么是React?</h2><ul><li>React 是一个用于构建用户界面的JavaScript库</li><li>核心专注于视图,目的实现组件化开发</li></ul><h2 id="组件化的概念"><a href="#组件化的概念" class="headerlink" title="组件化的概念"></a>组件化的概念</h2><p>我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用</p><ul><li>可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部</li><li>可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中</li><li>可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</li></ul><p><em><a href="https://pan.baidu.com/s/1hsivfN2">https://pan.baidu.com/s/1hsivfN2</a></em></p><h2 id="跑通react开发环境"><a href="#跑通react开发环境" class="headerlink" title="跑通react开发环境"></a>跑通react开发环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install create-react-app -g</span><br><span class="line">create-react-app &lt;project-name&gt;</span><br><span class="line">cd &lt;project-name&gt; &amp;&amp; npm start</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>默认会自动安装React,react由两部分组成,分别是:</p></blockquote><ul><li>react.js 是 React 的核心库</li><li>react-dom.js 是提供与DOM相关的功能,会在window下增加ReactDOM属性,内部比较重要的方法是render,将react元素或者react组件插入到页面中。</li></ul><h2 id="简介JSX"><a href="#简介JSX" class="headerlink" title="简介JSX"></a>简介JSX</h2><ul><li>是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。</li></ul><blockquote><p>需要注意的是JSX并不是html,在JSX中属性不能包含关键字，像class需要写成className,for需要写成htmlFor,并且属性名需要采用驼峰命名法！</p></blockquote><h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p>JSX其实只是一种语法糖,最终会通过<a href="https://babeljs.io/repl/">babel</a>转译成createElement语法,以下代码等价</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;div&gt;姜,&lt;span&gt;帅哥&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;);</span><br><span class="line">ReactDOM.render(React.createElement(&quot;div&quot;,null,&quot;姜,&quot;,React.createElement(&quot;span&quot;,null,&quot;帅哥&quot;)));</span><br></pre></td></tr></table></figure><blockquote><p>我们一般使用React.createElement来创建一个虚拟dom元素。</p></blockquote><h2 id="react元素-JSX元素"><a href="#react元素-JSX元素" class="headerlink" title="react元素/JSX元素"></a>react元素/JSX元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span>(<span class="params">type,props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> React = &#123;</span><br><span class="line">    <span class="function"><span class="title">createElement</span>(<span class="params">type,props=&#123;&#125;,...childrens</span>)</span>&#123;</span><br><span class="line">        childrens.length===<span class="number">1</span>?childrens = childrens[<span class="number">0</span>]:<span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type,&#123;...props,<span class="attr">children</span>:childrens&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ReactElement就是虚拟dom的概念，具有一个type属性代表当前的节点类型，还有节点的属性props</p></blockquote><h2 id="模拟render实现"><a href="#模拟render实现" class="headerlink" title="模拟render实现"></a>模拟render实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> render = <span class="function">(<span class="params">eleObj,container</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 先取出第一层 进行创建真实dom</span></span><br><span class="line">    <span class="keyword">let</span> &#123;type,props&#125; = eleObj;</span><br><span class="line">    <span class="keyword">let</span> elementNode = <span class="built_in">document</span>.createElement(type); <span class="comment">// 创建第一个元素</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> attr <span class="keyword">in</span> props</span>)</span>&#123; <span class="comment">// 循环所有属性</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">attr === <span class="string">&#x27;children&#x27;</span></span>)</span>&#123; <span class="comment">// 如果是children表示有嵌套关系</span></span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> props[attr] == <span class="string">&#x27;object&#x27;</span></span>)</span>&#123; <span class="comment">// 看是否是只有一个文本节点</span></span><br><span class="line">                props[attr].forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123; <span class="comment">// 多个的话循环判断 如果是对象再次调用render方法</span></span><br><span class="line">                    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> item === <span class="string">&#x27;object&#x27;</span></span>)</span>&#123;</span><br><span class="line">                        render(item,elementNode)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123; <span class="comment">//是文本节点 直接创建即可</span></span><br><span class="line">                        elementNode.appendChild(<span class="built_in">document</span>.createTextNode(item));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 只有一个文本节点直接创建即可</span></span><br><span class="line">                elementNode.appendChild(<span class="built_in">document</span>.createTextNode(props[attr]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">attr === <span class="string">&#x27;className&#x27;</span></span>)</span>&#123; <span class="comment">// 是不是class属性 class 属性特殊处理</span></span><br><span class="line">            elementNode.setAttribute(<span class="string">&#x27;class&#x27;</span>,props[attr]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            elementNode.setAttribute(attr,props[attr]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    container.appendChild(elementNode)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JSX表达式的用法"><a href="#JSX表达式的用法" class="headerlink" title="JSX表达式的用法"></a>JSX表达式的用法</h2><ul><li><ol><li>可以放JS的执行结果</li></ol></li><li><ol start="2"><li>如果换行需要用()包裹jsx代码</li></ol></li><li><ol start="3"><li>可以把JSX元素当作函数的返回值</li></ol></li><li><ol start="4"><li>&lt;{来判断是表达式还是js</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toResult</span>(<span class="params">&#123;name,age&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>今年&#123;name&#125;,&#123;age&#125;岁了!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrs =  [&#123;<span class="attr">name</span>:<span class="string">&#x27;zfpx&#x27;</span>,<span class="attr">age</span>:<span class="number">8</span>&#125;,,&#123;<span class="attr">name</span>:<span class="string">&#x27;姜文&#x27;</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;];</span><br><span class="line">ReactDOM.render(&lt;div&gt;</span><br><span class="line">    &#123;arrs.map((<span class="function">(<span class="params">item,index</span>)=&gt;</span>(</span><br><span class="line">        <span class="keyword">typeof</span> item===<span class="string">&#x27;object&#x27;</span>?<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;toResult(item)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>:<span class="literal">null</span></span><br><span class="line">    )))&#125;</span><br><span class="line">&lt;/div&gt;,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>null也是合法元素,循环时需要带key属性</p></blockquote><h2 id="JSX属性"><a href="#JSX属性" class="headerlink" title="JSX属性"></a>JSX属性</h2><ul><li>在JSX中分为普通属性和特殊属性，像class要写成className,for要写成htmlFor</li><li>style要采用对象的方式</li><li>dangerouslyInnerHTML插入html</li></ul><h2 id="组件的特点声明方式"><a href="#组件的特点声明方式" class="headerlink" title="组件的特点声明方式"></a>组件的特点声明方式</h2><p>react元素是是组件组成的基本单位</p><ul><li>首字母必须大写,目的是为了和JSX元素进行区分</li><li>组件定义后可以像JSX元素一样进行使用</li><li>每个组件必须返回唯一的顶级JSX元素</li><li>可以通过render方法将组件渲染成真实DOM</li></ul><h2 id="组件的两种定义方式"><a href="#组件的两种定义方式" class="headerlink" title="组件的两种定义方式"></a>组件的两种定义方式</h2><p>react怎么区分是组件还是jsx元素？组件名需要开头大写，react组件当作jsx来进行使用</p><ul><li>第一种方式是函数声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Build</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125; &#123;props.age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">render(&lt;div&gt;</span><br><span class="line">    &lt;Build name=&#123;school1.name&#125; age=&#123;school1.age&#125;/&gt;</span><br><span class="line">    &lt;Build &#123;...school2&#125; /&gt;</span><br><span class="line">&lt;/div&gt;,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><ul><li>第二种方式是类声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;name,age&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name&#125; &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类声明有状态，this，和声明周期</p></blockquote><h2 id="组件中属性和状态的区别"><a href="#组件中属性和状态的区别" class="headerlink" title="组件中属性和状态的区别"></a>组件中属性和状态的区别</h2><ul><li>组件的数据来源有两个地方<ul><li>props 外界传递过来的(默认属性，属性校验)</li><li>state 状态是自己的,改变状态唯一的方式就是setState</li></ul></li></ul><blockquote><p>属性和状态的变化都会影响视图更新</p></blockquote><h2 id="setState-使用"><a href="#setState-使用" class="headerlink" title="setState 使用"></a>setState 使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setState(partialState, callback)</span><br><span class="line"><span class="number">1.</span> partialState : object|<span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">⽤于产⽣与当前<span class="title">state</span>合并的⼦集。</span></span><br><span class="line"><span class="function">2. <span class="title">callback</span> : <span class="function"><span class="keyword">function</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">state</span>更新之后被调⽤。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SetStatePage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            counter: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line">    &#125;;</span><br><span class="line">    setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            counter</span><br><span class="line">        &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">                &lt;h3&gt;SetStatePage&lt;/h3&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.setCounter&#125;&gt;&#123;counter&#125;&lt;/button&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>setState只有在合成事件和⽣命周期函数中是异步的，在原⽣事件和setTimeout中都是同步<br>的，这⾥的异步其实是批量更新。<br>要获取到最新状态值有以下⽅式</p><ul><li><p>在回调中获取状态值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(</span><br><span class="line">  &#123;</span><br><span class="line">  counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line">  &#125;,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line">  &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使⽤定时器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setCounter();</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>原⽣事件中修改状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.changeValue, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>传入对象 setState 的更新会被合并 执行最后一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>传入函数实现链式更新state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state,props</span>) =&gt;</span> (&#123; <span class="attr">counter</span>: state.counter + v &#125;));</span><br><span class="line">&#125;;</span><br><span class="line">setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><ul><li>给元素绑定事件，事件绑定方式<br><code>react 的事件对象是经过封装 后的 遵循为w3c</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this.destroy = this.destroy.bind(this)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123; <span class="comment">//组件渲染完成，当渲染后会自动触发此函数</span></span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 箭头函数 否则this 指向的是window</span></span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;)</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123; <span class="comment">//组件将要卸载，当组件移除时会调用</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer); <span class="comment">//一般在这个方法中 清除定时器和绑定的事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    destroy=<span class="function">(<span class="params">p1,p2,p3,e</span>)=&gt;</span>&#123; <span class="comment">//es7 箭头函数</span></span><br><span class="line">      e =&gt; 事件对象</span><br><span class="line">        <span class="comment">// 删除某个组件</span></span><br><span class="line">        ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// destroy()&#123; //es7 箭头函数</span></span><br><span class="line">    <span class="comment">//     // 删除某个组件</span></span><br><span class="line">    <span class="comment">//     ReactDOM.unmountComponentAtNode(window.root);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 给react元素绑定事件默认this是undefined,bind方式 在就是箭头函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.destroy(1,2,3)&#125;</span>&gt;</span>&#123;this.state.date&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行顺序 constructor -&gt; render -&gt; componentDidMount -&gt; setState-&gt; render - onClick-&gt; unmountComponentAtNode -&gt; componentWillUnmount -&gt; clearInterval</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>给jsx元素绑定事件要注意事件中的this指向，事件名采用 on+”开头大写事件名”的方式<br>bind 事件对象默认传入在最后  ——–  回掉需要显示传入 e 在最后</p></blockquote><h2 id="属性校验-默认属性"><a href="#属性校验-默认属性" class="headerlink" title="属性校验,默认属性"></a>属性校验,默认属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>; <span class="comment">//引入属性校验的模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123; <span class="comment">// 类上的属性就叫静态属性</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123; <span class="comment">// 校验属性的类型和是否必填</span></span><br><span class="line">        age:PropTypes.number.isRequired, <span class="comment">// 支持的类型可以参考prop-types的readme文件</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123; <span class="comment">// 先默认调用defaultProps</span></span><br><span class="line">        name:<span class="string">&#x27;珠峰&#x27;</span>,</span><br><span class="line">        age:<span class="number">1</span></span><br><span class="line">    &#125;; <span class="comment">// 默认属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123; <span class="comment">//如果想在构造函数中拿到属性需要通过参数的方式</span></span><br><span class="line">         <span class="comment">//不能在组件中更改属性 不能修改属性*</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.name&#125; &#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>propTypes和defaultProps名字不能更改，这是react规定好的名称</p></blockquote><h2 id="setState-状态的使用"><a href="#setState-状态的使用" class="headerlink" title="setState 状态的使用"></a>setState 状态的使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    handleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// setState方法会进行合并 setState有两种写法 一种是对象一种是函数</span></span><br><span class="line">        <span class="comment">/*this.setState(&#123;count:this.state.count+1&#125;);</span></span><br><span class="line"><span class="comment">          this.setState(&#123;count:this.state.count+1&#125;);*/</span></span><br><span class="line">        <span class="comment">//this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;)); //如果返回的就是一个对象可以用小括号包裹</span></span><br><span class="line">        <span class="comment">//this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;));</span></span><br><span class="line">        <span class="comment">// 下一个状态是依赖于上一个状态时需要写成函数的方式</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;); <span class="comment">// 这个写法等同于 this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;));</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><blockquote><p>如果设置多个状态setState会合并，如果下一个状态依赖于上一个状态，需要写成函数的方式</p></blockquote><h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><p>复合组件就是将多个组件进行组合，结构非常复杂时可以把组件分离开</p><h3 id="不具名"><a href="#不具名" class="headerlink" title="不具名"></a>不具名</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> TopBar <span class="keyword">from</span> <span class="string">&quot;../components/TopBar&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> BottomBar <span class="keyword">from</span> <span class="string">&quot;../components/BottomBar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title = <span class="string">&quot;商城&quot;</span> &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="built_in">document</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children, showTopBar, showBottomBar &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;children&quot;</span>, children);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;showTopBar &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">TopBar</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;children.content&#125;</span><br><span class="line">        &#123;children.txt&#125;</span><br><span class="line">        &lt;button onClick=&#123;children.btnClick&#125;&gt;button&lt;/button&gt;</span><br><span class="line">        &#123;showBottomBar &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">BottomBar</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&quot;./Layout&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout showTopBar=&#123;<span class="literal">true</span>&#125; showBottomBar=&#123;<span class="literal">true</span>&#125; title=<span class="string">&quot;⽤用户中⼼心&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;UserPage&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/Layout&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="具名（传个对象进去）"><a href="#具名（传个对象进去）" class="headerlink" title="具名（传个对象进去）"></a>具名（传个对象进去）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&quot;./Layout&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout showTopBar=&#123;<span class="literal">false</span>&#125; showBottomBar=&#123;<span class="literal">true</span>&#125; title=<span class="string">&quot;商城⾸首⻚页&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;</span><br><span class="line">          content: (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;h3&gt;HomePage&lt;/h3&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          ),</span><br><span class="line">          txt: <span class="string">&quot;这是个⽂文本&quot;</span>,</span><br><span class="line">          btnClick: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;btnClick&quot;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;/Layout&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panel</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;header,body&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;panel-default panel&quot;</span>&gt;</span><br><span class="line">                    &lt;Header head=&#123;header&#125;&gt;&lt;/Header&gt;</span><br><span class="line">                    &lt;Body b=&#123;body&#125;/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// react种需要将属性一层层向下传递 单向数据流</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span>&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>&#123;this.props.head&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">header</span>:<span class="string">&#x27;我非常帅&#x27;</span>,<span class="attr">body</span>:<span class="string">&#x27;长的帅&#x27;</span>&#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Panel</span> &#123;<span class="attr">...data</span>&#125;/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure><h3 id="子父组件的通信"><a href="#子父组件的通信" class="headerlink" title="子父组件的通信"></a>子父组件的通信</h3><p>通过父亲传递给儿子一个函数，儿子调用父亲的函数将值传递给父亲,父亲更新值，刷新视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panel</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">color</span>:<span class="string">&#x27;primary&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    changeColor=<span class="function">(<span class="params">color</span>)=&gt;</span>&#123; <span class="comment">//到时候儿子传递一个颜色</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;color&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div className=&#123;<span class="string">&quot;panel-&quot;</span>+<span class="built_in">this</span>.state.color+<span class="string">&quot; panel&quot;</span>&#125;&gt;</span><br><span class="line">                    &lt;Header head=&#123;<span class="built_in">this</span>.props.header&#125;</span><br><span class="line">                            change=&#123;<span class="built_in">this</span>.changeColor&#125;</span><br><span class="line">                    &gt;&lt;/Header&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    handleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props.change(<span class="string">&#x27;danger&#x27;</span>); <span class="comment">//调用父亲的方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;panel-heading&quot;</span>&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.head&#125; &lt;button className=<span class="string">&quot;btn btn-danger&quot;</span> onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;改颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h2><ul><li>受状态控制的组件，必须要有onChange方法，否则不能使用</li><li>受控组件可以赋予默认值（官方推荐使用 受控组件）</li></ul><h3 id="实现双向数据绑定"><a href="#实现双向数据绑定" class="headerlink" title="实现双向数据绑定"></a>实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">val</span>:<span class="string">&#x27;100&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123; <span class="comment">//e是事件源</span></span><br><span class="line">        <span class="keyword">let</span> val = e.target.value;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;val&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;<span class="built_in">this</span>.state.val&#125; onChange=&#123;<span class="built_in">this</span>.handleChange&#125;/&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.val&#125;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key表示的就是当前状态改的是哪一个</span></span><br><span class="line">    <span class="comment">// e表示的是事件源</span></span><br><span class="line">    <span class="function"><span class="title">handleChange</span>(<span class="params">key,e</span>)</span>&#123; <span class="comment">//处理多个输入框的值映射到状态的方法</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            [key]:<span class="built_in">parseInt</span>(e.target.value) || <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> value=&#123;<span class="built_in">this</span>.state.a&#125; onChange=&#123;<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">this</span>.handleChange(<span class="string">&#x27;a&#x27;</span>,e)&#125;&#125;/&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> value=&#123;<span class="built_in">this</span>.state.b&#125; onChange=&#123;<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">this</span>.handleChange(<span class="string">&#x27;b&#x27;</span>,e)&#125;&#125;/&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.a+<span class="built_in">this</span>.state.b&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state =  &#123;<span class="attr">result</span>:<span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.inputRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过ref设置的属性 可以通过this.refs获取到对应的dom元素</span></span><br><span class="line">    <span class="comment">// 推荐使用 React.createRef()  获取到对应的dom元素</span></span><br><span class="line">    handleChange = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="built_in">this</span>.refs.a.value + <span class="built_in">this</span>.b.value + <span class="built_in">this</span>.inputRef.current.value;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;result&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div onChange=&#123;<span class="built_in">this</span>.handleChange&#125;&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> ref=<span class="string">&quot;a&quot;</span>/&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number1&quot;</span> ref=&#123;<span class="built_in">this</span>.inputRef&#125;/&gt;</span><br><span class="line">                &#123;<span class="comment">/*x代表的真实的dom,把元素挂载在了当前实例上*/</span>&#125;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> ref=&#123;<span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.b = x;</span><br><span class="line">                &#125;&#125;/&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.result&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123; <span class="comment">// 他会比较两个状态相等就不会刷新视图 PureComponent是浅比较</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name:<span class="string">&#x27;珠峰培训&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1.constructor构造函数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取本地的数据 同步的方式：采用渲染之前获取数据，只渲染一次</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2.组件将要加载 componentWillMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4.组件挂载完成 componentDidMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:<span class="built_in">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// react可以shouldComponentUpdate方法中优化 PureComponent 可以帮我们做这件事</span></span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123; <span class="comment">// 代表的是下一次的属性 和 下一次的状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5.组件是否更新 shouldComponentUpdate&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> nextState.number%<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// return nextState.number!==this.state.number; //如果此函数种返回了false 就不会调用render方法了</span></span><br><span class="line">  &#125; <span class="comment">//不要随便用setState 可能会死循环</span></span><br><span class="line">  <span class="function"><span class="title">componentWillUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6.组件将要更新 componentWillUpdate&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7.组件完成更新 componentDidUpdate&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3.render&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.number&gt;<span class="number">3</span>?<span class="literal">null</span>:<span class="xml"><span class="tag">&lt;<span class="name">ChildCounter</span> <span class="attr">n</span>=<span class="string">&#123;this.state.number&#125;/</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;组件将要卸载componentWillUnmount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentWillMount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child-render&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">this</span>.props.n&#125;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentDidMount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">newProps</span>)</span>&#123; <span class="comment">// 第一次不会执行，之后属性更新时才会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentWillReceiveProps&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextProps.n%<span class="number">3</span>; <span class="comment">//子组件判断接收的属性 是否满足更新条件 为true则更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defaultProps</span></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br><span class="line"><span class="comment">// 状态更新会触发的</span></span><br><span class="line"><span class="comment">// shouldComponentUpdate nextProps,nextState=&gt;boolean</span></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// 属性更新</span></span><br><span class="line"><span class="comment">// componentWillReceiveProps newProps</span></span><br><span class="line"><span class="comment">// 卸载</span></span><br><span class="line"><span class="comment">// componentWillUnmount</span></span><br></pre></td></tr></table></figure><h3 id="16-3-之前的"><a href="#16-3-之前的" class="headerlink" title="16.3 之前的"></a>16.3 之前的</h3><p><img src="/2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/react15.png" alt="lifeCycle"></p><h3 id="16-3-之后的"><a href="#16-3-之后的" class="headerlink" title="16.3 之后的"></a>16.3 之后的</h3><p><img src="/2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/react16.3.png" alt="lifeCycle"></p><p><img src="/2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/react.png" alt="react生命周期"></p><p>V17可能会废弃的三个⽣生命周期函数⽤用getDerivedStateFromProps替代，⽬目前使⽤用的话加上UNSAFE_：</p><ul><li><p>componentWillMount</p></li><li><p>componentWillReceiveProps</p></li><li><p>componentWillUpdate<br>引⼊入两个新的⽣生命周期函数：</p></li><li><p>static getDerivedStateFromProps<br>  getDerivedStateFromProps 会在调⽤用 render ⽅方法之前调⽤用，并且在初始挂载及后续更更新时都会被<br>  调⽤用。它应返回⼀一个对象来更更新 state，如果返回 null 则不不更更新任何内容。<br>  请注意，不不管原因是什什么，都会在 每次 渲染前触发此⽅方法。这与UNSAFE_componentWillReceiveProps 形成对⽐比，后者仅在⽗父组件重新渲染时触发，而不不是在内部调⽤用  setState 时。</p></li><li><p>getSnapshotBeforeUpdate<br>  getSnapshotBeforeUpdate(prevProps, prevState)<br>  在render之后，在componentDidUpdate之前<br>  getSnapshotBeforeUpdate() 在最近⼀一次渲染输出（提交到 DOM 节点）之前调⽤用。它使得组件能<br>在发⽣生更更改之前从 DOM 中捕获⼀一些信息（例例如，滚动位置）。此⽣生命周期的任何返回值将作为参数传<br>递给  componentDidUpdate(prevProps, prevState, snapshot)</p></li></ul><p>如果不不想⼿手动给将要废弃的⽣生命周期添加  UNSAFE_ 前缀，可以⽤用下⾯面的命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx react-codemod <span class="built_in">rename</span>-unsafe-lifecycles &lt;<span class="built_in">path</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="react-列表具备唯一的-key-值"><a href="#react-列表具备唯一的-key-值" class="headerlink" title="react 列表具备唯一的 key 值"></a>react 列表具备唯一的 key 值</h2><ul><li>不建议（禁止）使用index 做key 值</li><li>尽量使用数据id</li><li>使用动态生成的静态ID nanoid</li><li><code>key 值不会当属性被传递  防止开发者在逻辑中对key操作</code></li></ul><h2 id="react-错误边界"><a href="#react-错误边界" class="headerlink" title="react 错误边界"></a>react 错误边界</h2><p>防止某个组件的UI渲染出错导致整个应用崩溃<br>子组件发生js的错误  有备用的UI组件<br>错误边界 <code>只能用 class 组件来写</code><br>错误捕获时机： 渲染时  生命周期 组件树的构造函数错误时触发<br><a href="https://zh-hans.reactjs.org/docs/error-boundaries.html">错误边界</a></p><h2 id="react的dangerouslySetInnerHTML使用"><a href="#react的dangerouslySetInnerHTML使用" class="headerlink" title="react的dangerouslySetInnerHTML使用"></a>react的dangerouslySetInnerHTML使用</h2><p>在Vue中有个v-html属性可以处理这个问题，而在React中，就需要用到dangerouslySetInnerHTML属性，它会将字符串中的html标签正常发挥作用。（当然你如果用js的innerHTML）<br>dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML的替换方案。<br>dangerouslySetInnerHTML 是react的一个属性，可以直接使用<br><code>有两个&quot;&#123;&#123;&#125;&#125;&quot;，第一个表示jsx语法，第二个表示一个键值对</code><br>dangerouslySetInnerHTML可以插入Dom，也可以插入字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./css/01-index.css&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">app</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">      myhtml:<span class="string">`&lt;div class=&quot;bili-bangumi-card&quot;&gt;更新至第11话&lt;/div&gt;`</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">                &lt;div dangerouslySetInnerHTML=&#123;&#123;</span><br><span class="line">                    __html: <span class="built_in">this</span>.state.myhtml</span><br><span class="line">                &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref-获取dom"><a href="#ref-获取dom" class="headerlink" title="ref 获取dom"></a>ref 获取dom</h2><p>可以通过 createRef() useRef()  或者 ref 回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = (props)&#123;</span><br><span class="line">  <span class="keyword">let</span> inputRef;</span><br><span class="line">  <span class="keyword">let</span> clickFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(inputRef);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> ref = &#123; <span class="function">(<span class="params">dom</span>) =&gt;</span>&#123;</span><br><span class="line">      inputRef = dom</span><br><span class="line">     &#125;&#125;/&gt;</span><br><span class="line">     &lt;button onClick = &#123;clickFn&#125;&gt;</span><br><span class="line">     add</span><br><span class="line">     &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="react-createContext"><a href="#react-createContext" class="headerlink" title="react createContext"></a>react createContext</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> GlobalContext = React.createContext()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;GlobalContext.Provider</span><br><span class="line"> value=&#123;&#123;</span><br><span class="line">    name:<span class="string">&quot;kerwin&quot;</span>,</span><br><span class="line">    age:<span class="number">100</span>,</span><br><span class="line">    content:<span class="built_in">this</span>.state.content,</span><br><span class="line">   show:<span class="built_in">this</span>.show.bind(<span class="built_in">this</span>),</span><br><span class="line">   hide:<span class="built_in">this</span>.hide.bind(<span class="built_in">this</span>)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;Test/&gt;</span><br><span class="line">&lt;/GlobalContext.Provider&gt;</span><br><span class="line"></span><br><span class="line">使用GlobalContext.Consumer（消费者）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">calss Test <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="comment">/* consumer -&gt; 使用provider -&gt; value </span></span><br><span class="line"><span class="comment">  订阅context 内部的变化</span></span><br><span class="line"><span class="comment">  consumer 使用函数作为子组件</span></span><br><span class="line"><span class="comment">  context 就近原则接受provider 的value</span></span><br><span class="line"><span class="comment">  provider 没有设置value 使用默认值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;GlobalContext.Consumer&gt;</span><br><span class="line">         &#123;</span><br><span class="line">           context =&gt; &#123;</span><br><span class="line">             <span class="built_in">this</span>.myshow = context.show; <span class="comment">//可以在当前组件任意函数触发</span></span><br><span class="line">            <span class="built_in">this</span>.myhide = context.hide;<span class="comment">//可以在当前组件任意函数触发 </span></span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">             &lt;div&gt;</span><br><span class="line">              &#123;context.name&#125;-&#123;context.age&#125;-&#123;context.content&#125;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">           )</span><br><span class="line">          &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &lt;/GlobalContext.Consumer&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* 基于这个值进行渲染工作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* 基于 MyContext 组件的值进行渲染 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType = MyContext;</span><br></pre></td></tr></table></figure><h2 id="react-JSX-使用和组件"><a href="#react-JSX-使用和组件" class="headerlink" title="react JSX 使用和组件"></a>react JSX 使用和组件</h2><h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。<br>在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码<br>更加直观并易于维护。 编译过程由Babel 的 JSX 编译器实现。<br><a href="https://reactjs.org/docs/hello-world.html">https://reactjs.org/docs/hello-world.html</a><br> JavaScript 对象来表现一个 DOM 元素的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;app&#x27;</span> id=<span class="string">&#x27;appRoot&#x27;</span>&gt;</span><br><span class="line"> &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;title&#x27;</span>&gt;欢迎进入React的世界&lt;/h1&gt;</span><br><span class="line"> &lt;p&gt;</span><br><span class="line"> React.js 是一个帮助你构建页面 UI 的库</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// js 对象描述DOM</span></span><br><span class="line">&#123;</span><br><span class="line"> tag: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"> attrs: &#123; <span class="attr">className</span>: <span class="string">&#x27;app&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;appRoot&#x27;</span>&#125;,</span><br><span class="line"> children: [</span><br><span class="line"> &#123;</span><br><span class="line">   tag: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">   attrs: &#123; <span class="attr">className</span>: <span class="string">&#x27;title&#x27;</span> &#125;,</span><br><span class="line">   children: [<span class="string">&#x27;欢迎进入React的世界&#x27;</span>]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   tag: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">   attrs: <span class="literal">null</span>,</span><br><span class="line">   children: [<span class="string">&#x27;React.js 是一个构建页面 UI 的库&#x27;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">     <span class="string">&quot;p&quot;</span>,</span><br><span class="line">     <span class="literal">null</span>,</span><br><span class="line">     <span class="string">&quot;React.js 是一个构建页面 UI 的库&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>React.createElement 会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、<br>还有子元素等, 语法为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line"> type,</span><br><span class="line">[props],</span><br><span class="line">[...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="组件样式"><a href="#组件样式" class="headerlink" title="组件样式"></a>组件样式</h3><ul><li><p>行内样式<br>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的两个括号，第一个表示我们在要JSX里插入JS了，第二个是对象的括号</span></span><br><span class="line"></span><br><span class="line">  &lt;p style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>, <span class="attr">fontSize</span>:<span class="string">&#x27;14px&#x27;</span>&#125;&#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如 render 函数里、组件原型上、外链js文件中</p></li><li><p>class<br>其实我们大多数情况下还是大量的在为元素添加类名，但是需要注意的是， class 需要写成className （因为毕竟是在写类js代码，会收到js规则的现在，而 class 是关键字）<br><code>class ==&gt; className , for ==&gt; htmlFor(label)</code></p></li></ul><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>采用on+事件名的方式来绑定一个事件，注意，这里和原生的事件是有区别的，原生的事件全是小写<br>onclick , React里的事件是驼峰 onClick ，React的事件并不是原生事件，而是合成事件。</p><ul><li>直接在render里写行内的箭头函数(不推荐)</li><li>在组件内使用箭头函数定义一个方法(推荐)</li><li>直接在组件内定义一个非箭头函数的方法，然后在render里直接使用 onClick={this.handleClick.bind(this)} (不推荐)</li><li>直接在组件内定义一个非箭头函数的方法，然后在constructor里bind(this)(推荐)</li></ul><p>和普通浏览器一样，事件handler会被自动传入一个  event 对象，这个对象和普通的浏览器  event 对<br>象所包含的方法和属性都基本一致。不同的是 React中的  event 对象并不是浏览器提供的，而是它自<br>己内部所构建的。它同样具有 event.stopPropagation 、 event.preventDefault 这种常用的方法<code>event对象在参数最后</code></p><h3 id="JSX中的children"><a href="#JSX中的children" class="headerlink" title="JSX中的children"></a>JSX中的children</h3><ul><li><p>children中的function<br>函数返回值中自定义模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//Repeat组件的定义中可以看出来，children中的方法按此定义会一直执行10次</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ListOfTenThings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Repeat numTimes=&#123;<span class="number">10</span>&#125;&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">index</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>This is item &#123;index&#125; in the list<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">    &lt;/Repeat&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Repeat</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.numTimes; i++) &#123;</span><br><span class="line">    items.push(props.children(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;items&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>忽略Boolean，Null以及Undefined<br>false,null,undefined以及true是不能通过render()方法，呈现在页面上的，下面的这些div块的样式 相同，都是空白块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">false</span>&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">null</span>&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">true</span>&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>如何显示Null，Undefined和Boolean ===&gt; 通过String的转化后就能在页面上显示了。</p></li></ul><h2 id="react-dom-diff-fiber"><a href="#react-dom-diff-fiber" class="headerlink" title="react dom diff fiber"></a>react dom diff fiber</h2><p><a href="react_diff.png">diff</a></p><p><a href="react_fiber.png">fiber</a></p><h2 id="react-资源"><a href="#react-资源" class="headerlink" title="react 资源"></a>react 资源</h2><ul><li><p><a href="https://juejin.cn/post/6950063294270930980">React全部api解读</a></p></li><li><p><a href="https://github.com/carlleton/reactjs101/tree/zh-CN">react从0学习</a></p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2代码简单解析</title>
      <link href="2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/"/>
      <url>2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/</url>
      
        <content type="html"><![CDATA[<h2 id="谈一下你对MVVM-原理的理解"><a href="#谈一下你对MVVM-原理的理解" class="headerlink" title="谈一下你对MVVM 原理的理解"></a>谈一下你对<code>MVVM </code>原理的理解</h2><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/MVVM.jpg" alt="MVVM" style="zoom: 50%;"><ul><li>传统的<code>MVC</code>指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染</li><li><code>MVVM</code>:传统的前端会将数据手动渲染到页面上,<code>MVVM</code>模式不需要用户收到操作<code>dom</code>元素,将数据绑定到<code>viewModel</code>层上，会自动将数据渲染到页面中，视图变化会通知<code>viewModel层</code>更新数据。<code>ViewModel</code>就是我们<code>MVVM</code>模式中的桥梁.<a id="more"></a><h2 id="请说一下响应式数据的原理？"><a href="#请说一下响应式数据的原理？" class="headerlink" title="请说一下响应式数据的原理？"></a>请说一下响应式数据的原理？</h2></li></ul><h3 id="理解"><a href="#理解" class="headerlink" title="理解:"></a>理解:</h3><ul><li>核心点:<code>Object.defineProperty</code></li><li>默认<code>Vue</code>在初始化数据时，会给<code>data</code>中的属性使用<code>Object.defineProperty</code>重新定义所有属性,当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher） 如果属性发生变化会通知相关依赖进行更新操作。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend() <span class="comment">// ** 收集依赖 ** /</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify() <span class="comment">/**通知相关依赖进行更新**/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue中是如何检测数组变化"><a href="#Vue中是如何检测数组变化" class="headerlink" title="Vue中是如何检测数组变化?"></a><code>Vue</code>中是如何检测数组变化?</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解:"></a>理解:</h3><ul><li>使用函数劫持的方式，重写了数组的方法</li><li><code>Vue</code>将<code>data</code>中的数组，进行了原型链重写。指向了自己定义的数组原型方法，这样当调用数组<code>api</code>时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控。</li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123; <span class="comment">// 重写原型方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method] <span class="comment">// 调用原数组的方法</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify() <span class="comment">// 当调用数组方法后，手动通知视图更新</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.observeArray(value) <span class="comment">// 进行深度监控</span></span><br></pre></td></tr></table></figure><h2 id="为何Vue采用异步渲染"><a href="#为何Vue采用异步渲染" class="headerlink" title="为何Vue采用异步渲染?"></a>为何<code>Vue</code>采用异步渲染?</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染.所以为了性能考虑。<code>Vue</code>会在本轮数据更新后，再去异步更新视图!</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E4%B8%BA%E4%BD%95%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="built_in">this</span>); <span class="comment">// 当数据发生变化时会将watcher放到一个队列中批量更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id <span class="comment">// 会对相同的watcher进行过滤</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue) <span class="comment">// 调用nextTick方法 批量的进行更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理?"></a><code>nextTick</code>实现原理?</h2><h3 id="理解-宏任务和微任务-异步方法"><a href="#理解-宏任务和微任务-异步方法" class="headerlink" title="理解:(宏任务和微任务) 异步方法"></a>理解:(<strong>宏任务</strong>和<strong>微任务</strong>) 异步方法</h3><p><code>nextTick</code>方法主要是使用了<strong>宏任务</strong>和<strong>微任务</strong>,定义了一个异步方法.多次调用<code>nextTick</code> 会将方法存入队列中，通过这个异步方法清空当前队列。 所以这个<code>nextTick</code>方法就是异步方法</p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/nextTick%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc  <span class="comment">// 会定义一个异步方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;  <span class="comment">// promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; ( <span class="comment">// MutationObserver</span></span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> ) &#123; <span class="comment">// setImmediate</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;   <span class="comment">// setTimeout</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nextTick实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue中Computed的特点"><a href="#Vue中Computed的特点" class="headerlink" title="Vue中Computed的特点"></a><code>Vue</code>中<code>Computed</code>的特点</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解:"></a>理解:</h3><ul><li>默认<code>computed</code>也是一个<code>watcher</code>是具备缓存的，只要当依赖的属性发生变化时才会更新视图</li></ul><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123; <span class="comment">// 如果依赖的值没发生变化,就不会重新求值</span></span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Watch中的deep-true-是如何实现的"><a href="#Watch中的deep-true-是如何实现的" class="headerlink" title="Watch中的deep:true 是如何实现的"></a><code>Watch</code>中的<code>deep:true</code> 是如何实现的</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><ul><li>当用户指定了<code>watch</code>中的deep属性为<code>true</code>时，如果当前监控的值是数组类型。会对对象中的每一项进行求值，此时会将当前<code>watcher</code>存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新</li></ul><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>) <span class="comment">// 先将当前依赖放到 Dep.target上</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123; <span class="comment">// 如果需要深度监控</span></span><br><span class="line">        traverse(value) <span class="comment">// 会对对象中的每一项取值,取值时会执行对应的get方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val: any, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue组件的生命周期"><a href="#Vue组件的生命周期" class="headerlink" title="Vue组件的生命周期"></a><code>Vue</code>组件的生命周期</h2><h3 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h3><h4 id="要掌握每个生命周期什么时候被调用"><a href="#要掌握每个生命周期什么时候被调用" class="headerlink" title="要掌握每个生命周期什么时候被调用"></a>要掌握每个生命周期什么时候被调用</h4><ul><li><code>beforeCreate</code> 在实例初始化之后，数据观测(data observer) 之前被调用。</li><li><code>created</code> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el</li><li><code>beforeMount</code> 在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li><code>mounted</code> el 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。</li><li><code>beforeUpdate</code> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li><li><code>updated</code> 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li><li><code>beforeDestroy</code> 实例销毁之前调用。在这一步，实例仍然完全可用。</li><li><code>destroyed</code> <code>Vue</code> 实例销毁后调用。调用后，<code>Vue</code> 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li></ul><h4 id="要掌握每个生命周期内部可以做什么事"><a href="#要掌握每个生命周期内部可以做什么事" class="headerlink" title="要掌握每个生命周期内部可以做什么事"></a>要掌握每个生命周期内部可以做什么事</h4><ul><li><code>created</code> 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。</li><li><code>mounted</code> 实例已经挂载完成，可以进行一些DOM操作</li><li><code>beforeUpdate</code> 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li><li><code>updated</code> 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。</li><li><code>destroyed</code> 可以执行一些优化操作,清空定时器，解除绑定事件</li></ul><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/lifecycle.png" alt="lifecycle"></p><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p><h2 id="ajax请求放在哪个生命周期中"><a href="#ajax请求放在哪个生命周期中" class="headerlink" title="ajax请求放在哪个生命周期中"></a><code>ajax</code>请求放在哪个生命周期中</h2><h3 id="理解-5"><a href="#理解-5" class="headerlink" title="理解:"></a>理解:</h3><ul><li>在created的时候，视图中的<code>dom</code>并没有渲染出来，所以此时如果直接去操<code>dom</code>节点，无法找到相关的元素 </li><li>在mounted中，由于此时<code>dom</code>已经渲染出来了，所以可以直接操作<code>dom</code>节点 </li></ul><p>一般情况下都放到<code>mounted</code>中,保证逻辑的统一性,因为生命周期是同步执行的，<code>ajax</code>是异步执行的</p><blockquote><p>服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中</p></blockquote><h2 id="何时需要使用beforeDestroy"><a href="#何时需要使用beforeDestroy" class="headerlink" title="何时需要使用beforeDestroy"></a>何时需要使用<code>beforeDestroy</code></h2><h3 id="理解-6"><a href="#理解-6" class="headerlink" title="理解:"></a>理解:</h3><ul><li>可能在当前页面中使用了<code>$on</code>方法，那需要在组件销毁前解绑。</li><li>清除自己定义的定时器</li><li>解除事件的绑定 <code>scroll mousemove ....</code></li></ul><h2 id="Vue中模板编译原理"><a href="#Vue中模板编译原理" class="headerlink" title="Vue中模板编译原理"></a><code>Vue</code>中模板编译原理</h2><ul><li>将<code>template</code>转化成<code>render</code>函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options) <span class="comment">// 将模板转化成ast语法树</span></span><br><span class="line">  <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;           <span class="comment">// 优化树</span></span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)         <span class="comment">// 生成树</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>; </span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span>;</span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>); <span class="comment">// 标签开头的正则 捕获的内容是标签名</span></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;\\/<span class="subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>); <span class="comment">// 匹配标签结尾的  &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>; <span class="comment">// 匹配属性的</span></span><br><span class="line"><span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>; <span class="comment">// 匹配标签结束的  &gt;</span></span><br><span class="line"><span class="keyword">let</span> root;</span><br><span class="line"><span class="keyword">let</span> currentParent;</span><br><span class="line"><span class="keyword">let</span> stack = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createASTElement</span>(<span class="params">tagName,attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag:tagName,</span><br><span class="line">        type:<span class="number">1</span>,</span><br><span class="line">        children:[],</span><br><span class="line">        attrs,</span><br><span class="line">        parent:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">tagName,attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> element = createASTElement(tagName,attrs);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!root</span>)</span>&#123;</span><br><span class="line">        root = element;</span><br><span class="line">    &#125;</span><br><span class="line">    currentParent = element;</span><br><span class="line">    stack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chars</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        type:<span class="number">3</span>,</span><br><span class="line">        text</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">tagName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = stack[stack.length-<span class="number">1</span>];</span><br><span class="line">    stack.length --; </span><br><span class="line">    currentParent = stack[stack.length-<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">currentParent</span>)</span>&#123;</span><br><span class="line">        element.parent = currentParent;</span><br><span class="line">        currentParent.children.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">textEnd == <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">startTagMatch</span>)</span>&#123;</span><br><span class="line">                start(startTagMatch.tagName,startTagMatch.attrs);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> endTagMatch = html.match(endTag);</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">endTagMatch</span>)</span>&#123;</span><br><span class="line">                advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">                end(endTagMatch[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> text;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">textEnd &gt;=<span class="number">0</span> </span>)</span>&#123;</span><br><span class="line">            text = html.substring(<span class="number">0</span>,textEnd)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">            advance(text.length);</span><br><span class="line">            chars(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">advance</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        html = html.substring(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> start = html.match(startTagOpen);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">start</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> match = &#123;</span><br><span class="line">                tagName:start[<span class="number">1</span>],</span><br><span class="line">                attrs:[]</span><br><span class="line">            &#125;</span><br><span class="line">            advance(start[<span class="number">0</span>].length);</span><br><span class="line">            <span class="keyword">let</span> attr,end</span><br><span class="line">            <span class="keyword">while</span>(!(end = html.match(startTagClose)) &amp;&amp; (attr=html.match(attribute)))&#123;</span><br><span class="line">                advance(attr[<span class="number">0</span>].length);</span><br><span class="line">                match.attrs.push(&#123;<span class="attr">name</span>:attr[<span class="number">1</span>],<span class="attr">value</span>:attr[<span class="number">3</span>]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">end</span>)</span>&#123;</span><br><span class="line">                advance(end[<span class="number">0</span>].length);</span><br><span class="line">                <span class="keyword">return</span> match</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成语法树</span></span><br><span class="line">parseHTML(<span class="string">`&lt;div id=&quot;container&quot;&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">node.type == <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generate(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(node.text)&#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genChildren</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> children = el.children;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">el.children</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;children.map(c=&gt;gen(c)).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>]`</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genProps</span>(<span class="params">attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length;i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> attr = attrs[i];</span><br><span class="line">        str+= <span class="string">`<span class="subst">$&#123;attr.name&#125;</span>:<span class="subst">$&#123;attr.value&#125;</span>,`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;attrs:&#123;<span class="subst">$&#123;str.slice(<span class="number">0</span>,-<span class="number">1</span>)&#125;</span>&#125;&#125;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> children = genChildren(el);</span><br><span class="line">    <span class="keyword">let</span> code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        el.attrs.length? <span class="string">`,<span class="subst">$&#123;genProps(el.attrs)&#125;</span>`</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        children? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据语法树生成新的代码</span></span><br><span class="line"><span class="keyword">let</span> code = generate(root);</span><br><span class="line"><span class="keyword">let</span> render = <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装成函数</span></span><br><span class="line"><span class="keyword">let</span> renderFn = <span class="keyword">new</span> <span class="built_in">Function</span>(render);</span><br><span class="line"><span class="built_in">console</span>.log(renderFn.toString());</span><br></pre></td></tr></table></figure><h2 id="Vue中v-if和v-show的区别"><a href="#Vue中v-if和v-show的区别" class="headerlink" title="Vue中v-if和v-show的区别"></a><code>Vue</code>中<code>v-if</code>和<code>v-show</code>的区别</h2><h3 id="理解-7"><a href="#理解-7" class="headerlink" title="理解:"></a>理解:</h3><ul><li><code>v-if</code>如果条件不成立不会渲染当前指令所在节点的<code>dom</code>元素</li><li><code>v-show</code>只是切换当前<code>dom</code>的显示或者隐藏</li></ul><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-if=&quot;true&quot;&gt;&lt;span v-for=&quot;i in 3&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return (true) ? _c(&#x27;div&#x27;, _l((3), function (i) &#123;</span></span><br><span class="line"><span class="comment">        return _c(&#x27;span&#x27;, [_v(&quot;hello&quot;)])</span></span><br><span class="line"><span class="comment">    &#125;), 0) : _e()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-show=&quot;true&quot;&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        directives: [&#123;</span></span><br><span class="line"><span class="comment">            name: &quot;show&quot;,</span></span><br><span class="line"><span class="comment">            rawName: &quot;v-show&quot;,</span></span><br><span class="line"><span class="comment">            value: (true),</span></span><br><span class="line"><span class="comment">            expression: &quot;true&quot;</span></span><br><span class="line"><span class="comment">        &#125;]</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v-show 操作的是样式  定义在platforms/web/runtime/directives/show.js</span></span><br><span class="line">bind (el: any, &#123; value &#125;: VNodeDirective, <span class="attr">vnode</span>: VNodeWithData) &#123;</span><br><span class="line">    vnode = locateNode(vnode)</span><br><span class="line">    <span class="keyword">const</span> transition = vnode.data &amp;&amp; vnode.data.transition</span><br><span class="line">    <span class="keyword">const</span> originalDisplay = el.__vOriginalDisplay =</span><br><span class="line">      el.style.display === <span class="string">&#x27;none&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : el.style.display</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; transition) &#123;</span><br><span class="line">      vnode.data.show = <span class="literal">true</span></span><br><span class="line">      enter(vnode, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        el.style.display = originalDisplay</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.style.display = value ? originalDisplay : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么V-for和v-if不能连用"><a href="#为什么V-for和v-if不能连用" class="headerlink" title="为什么V-for和v-if不能连用"></a>为什么<code>V-for</code>和<code>v-if</code>不能连用</h2><h3 id="理解-8"><a href="#理解-8" class="headerlink" title="理解:"></a>理解:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-if=&quot;false&quot; v-for=&quot;i in 3&quot;&gt;hello&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _l((3), function (i) &#123;</span></span><br><span class="line"><span class="comment">        return (false) ? _c(&#x27;div&#x27;, [_v(&quot;hello&quot;)]) : _e()</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(r1.render);</span><br></pre></td></tr></table></figure><ul><li><code>v-for</code>会比<code>v-if</code>的优先级高一些,如果连用的话会把<code>v-if</code>给每个元素都添加一下,会造成性能问题</li></ul><h2 id="用vnode来描述一个DOM结构"><a href="#用vnode来描述一个DOM结构" class="headerlink" title="用vnode来描述一个DOM结构"></a>用<code>vnode</code>来描述一个<code>DOM</code>结构</h2><ul><li>虚拟节点就是用一个对象来描述真实的<code>dom</code>元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$createElement</span>(<span class="params">tag,data,...children</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = data.key;</span><br><span class="line">    <span class="keyword">delete</span> data.key;</span><br><span class="line">    children = children.map(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> child === <span class="string">&#x27;object&#x27;</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> child</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vnode(<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> vnode(tag,props,key,children);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span>(<span class="params">tag,data,key,children,text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag, <span class="comment">// 表示的是当前的标签名</span></span><br><span class="line">        data, <span class="comment">// 表示的是当前标签上的属性</span></span><br><span class="line">        key, <span class="comment">// 唯一表示用户可能传递</span></span><br><span class="line">        children,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="diff算法的时间复杂度"><a href="#diff算法的时间复杂度" class="headerlink" title="diff算法的时间复杂度"></a><code>diff</code>算法的时间复杂度</h2><p> 两个树的完全的<code>diff</code>算法是一个时间复杂度为 <code>O(n3) </code>,<code>Vue</code>进行了优化·<em>O(n3)</em> <em>复杂度</em>的问题转换成 O(n) <em>复杂度</em>的问题(只比较同级不考虑跨级问题)  在前端当中， 你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比。 </p><h2 id="简述Vue中diff算法原理"><a href="#简述Vue中diff算法原理" class="headerlink" title="简述Vue中diff算法原理"></a>简述<code>Vue</code>中<code>diff</code>算法原理</h2><h3 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h3><ul><li>先同级比较，在比较子节点</li><li>先判断一方有儿子一方没儿子的情况 </li><li>比较都有儿子的情况</li><li>递归比较子节点</li></ul><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/vue-diff.jpg"></p><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理:"></a>原理:</h3><blockquote><p><code>core/vdom/patch.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldCh = oldVnode.children <span class="comment">// 老的儿子 </span></span><br><span class="line"><span class="keyword">const</span> ch = vnode.children  <span class="comment">// 新的儿子</span></span><br><span class="line"><span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// 比较孩子</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123; <span class="comment">// 新的儿子有 老的没有</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123; <span class="comment">// 如果老的有新的没有 就删除</span></span><br><span class="line">        removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;  <span class="comment">// 老的有文本 新的没文本</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 将老的清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123; <span class="comment">// 文本不相同替换</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="v-for中为什么要用key-图解"><a href="#v-for中为什么要用key-图解" class="headerlink" title="v-for中为什么要用key (图解)"></a><code>v-for</code>中为什么要用<code>key</code> (图解)</h2><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/diff-key.jpg"></p><h2 id="描述组件渲染和更新过程"><a href="#描述组件渲染和更新过程" class="headerlink" title="描述组件渲染和更新过程"></a>描述组件渲染和更新过程</h2><h3 id="理解：-2"><a href="#理解：-2" class="headerlink" title="理解："></a>理解：</h3><ul><li>渲染组件时，会通过<code>Vue.extend</code>方法构建子组件的构造函数，并进行实例化。最终手动调用<code>$mount()</code>进行挂载。更新组件时会进行<code>patchVnode</code>流程.核心就是diff算法</li></ul><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png"></p><h2 id="组件中的-data为什么是一个函数"><a href="#组件中的-data为什么是一个函数" class="headerlink" title="组件中的 data为什么是一个函数?"></a>组件中的 <code>data</code>为什么是一个函数?</h2><h3 id="理解：-3"><a href="#理解：-3" class="headerlink" title="理解："></a>理解：</h3><p>同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果<code>data</code>是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过<code>data</code>函数返回一个对象作为组件的状态。</p><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理:"></a>原理:</h3><blockquote><p><code>core/global-api/extend.js line:33</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">        options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">strats.data = <span class="function"><span class="keyword">function</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123; <span class="comment">// 合并是会判断子类的data必须是一个函数</span></span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">&#x27;The &quot;data&quot; option should be a function &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;that returns a per-instance value in component &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;definitions.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个组件被使用多次，用的都是同一个构造函数。为了保证组件的不同的实例data不冲突，要求data必须是一个函数，这样组件间不会相互影响</li></ul><h2 id="Vue中事件绑定的原理"><a href="#Vue中事件绑定的原理" class="headerlink" title="Vue中事件绑定的原理"></a><code>Vue</code>中事件绑定的原理</h2><h3 id="理解-9"><a href="#理解-9" class="headerlink" title="理解:"></a>理解:</h3><ul><li>原生<code>dom</code>事件的绑定,采用的是<code>addEventListener</code>实现</li><li>组件绑定事件采用的是<code>$on</code>方法</li></ul><h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理:"></a>原理:</h3><ul><li>事件的编译：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = compiler.compile(<span class="string">&#x27;&lt;div @click=&quot;fn()&quot;&gt;&lt;/div&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = compiler.compile(<span class="string">&#x27;&lt;my-component @click.native=&quot;fn&quot; @click=&quot;fn1&quot;&gt;&lt;/my-component&gt;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r1); <span class="comment">// &#123;on:&#123;click&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r2); <span class="comment">// &#123;nativeOnOn:&#123;click&#125;,on:&#123;click&#125;&#125;  </span></span><br></pre></td></tr></table></figure><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E4%BA%8B%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p><h4 id="原生dom的绑定"><a href="#原生dom的绑定" class="headerlink" title="原生dom的绑定"></a>原生<code>dom</code>的绑定</h4><ul><li><code>Vue</code>在创建真是<code>dom</code>时会调用<code>createElm</code>,默认会调用<code>invokeCreateHooks</code></li><li>会遍历当前平台下相对的属性处理代码,其中就有<code>updateDOMListeners</code>方法,内部会传入<code>add</code>方法</li></ul><p>yuan</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMListeners</span> (<span class="params">oldVnode: VNodeWithData, vnode: VNodeWithData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> on = vnode.data.on || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> oldOn = oldVnode.data.on || &#123;&#125;</span><br><span class="line">  target = vnode.elm</span><br><span class="line">  normalizeEvents(on)</span><br><span class="line">  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context)</span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  capture: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  passive: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  target.addEventListener( <span class="comment">// 给当前的dom添加事件</span></span><br><span class="line">    name,</span><br><span class="line">    handler,</span><br><span class="line">    supportsPassive</span><br><span class="line">      ? &#123; capture, passive &#125;</span><br><span class="line">      : capture</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <code>vue</code>中绑定事件是直接绑定给真实<code>dom</code>元素的</p></blockquote><ul><li>组件中绑定事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateComponentListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldListeners: ?<span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  target = vm</span><br><span class="line">  updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, createOnceHandler, vm)</span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">  target.$on(event, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>组件绑定事件是通过<code>vue</code>中自定义的<code>$on</code>方法来实现的</p></blockquote><h2 id="v-model中的实现原理及如何自定义v-model"><a href="#v-model中的实现原理及如何自定义v-model" class="headerlink" title="v-model中的实现原理及如何自定义v-model"></a><code>v-model</code>中的实现原理及如何自定义<code>v-model</code></h2><h3 id="理解-10"><a href="#理解-10" class="headerlink" title="理解:"></a>理解:</h3><p>组件的<code>v-model</code>是<code>value+input方法</code>的语法糖</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">:value</span>=<span class="string">&quot;&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;check&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以自己重新定义<code>v-model</code>的含义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;el-checkbox&#x27;</span>,&#123;</span><br><span class="line">    template:<span class="string">`&lt;input type=&quot;checkbox&quot; :checked=&quot;check&quot; @change=&quot;$emit(&#x27;change&#x27;,$event.target.checked)&quot;&gt;`</span>,</span><br><span class="line">    model:&#123;</span><br><span class="line">        prop:<span class="string">&#x27;check&#x27;</span>, <span class="comment">// 更改默认的value的名字</span></span><br><span class="line">        event:<span class="string">&#x27;change&#x27;</span> <span class="comment">// 更改默认的方法名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        check: <span class="built_in">Boolean</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="原理-11"><a href="#原理-11" class="headerlink" title="原理:"></a>原理:</h3><ul><li>会将组件的<code>v-model</code>默认转化成value+input</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ele = VueTemplateCompiler.compile(<span class="string">&#x27;&lt;el-checkbox v-model=&quot;check&quot;&gt;&lt;/el-checkbox&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// with(this) &#123;</span></span><br><span class="line"><span class="comment">//     return _c(&#x27;el-checkbox&#x27;, &#123;</span></span><br><span class="line"><span class="comment">//         model: &#123;</span></span><br><span class="line"><span class="comment">//             value: (check),</span></span><br><span class="line"><span class="comment">//             callback: function ($$v) &#123;</span></span><br><span class="line"><span class="comment">//                 check = $$v</span></span><br><span class="line"><span class="comment">//             &#125;,</span></span><br><span class="line"><span class="comment">//             expression: &quot;check&quot;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>core/vdom/create-component.js  line:155</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformModel</span> (<span class="params">options, data: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prop = (options.model &amp;&amp; options.model.prop) || <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> event = (options.model &amp;&amp; options.model.event) || <span class="string">&#x27;input&#x27;</span></span><br><span class="line">  ;(data.attrs || (data.attrs = &#123;&#125;))[prop] = data.model.value</span><br><span class="line">  <span class="keyword">const</span> on = data.on || (data.on = &#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> existing = on[event]</span><br><span class="line">  <span class="keyword">const</span> callback = data.model.callback</span><br><span class="line">  <span class="keyword">if</span> (isDef(existing)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">Array</span>.isArray(existing)</span><br><span class="line">        ? existing.indexOf(callback) === -<span class="number">1</span></span><br><span class="line">        : existing !== callback</span><br><span class="line">    ) &#123;</span><br><span class="line">      on[event] = [callback].concat(existing)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    on[event] = callback</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原生的 <code>v-model</code>，会根据标签的不同生成不同的事件和属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ele = VueTemplateCompiler.compile(<span class="string">&#x27;&lt;input v-model=&quot;value&quot;/&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;input&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        directives: [&#123;</span></span><br><span class="line"><span class="comment">            name: &quot;model&quot;,</span></span><br><span class="line"><span class="comment">            rawName: &quot;v-model&quot;,</span></span><br><span class="line"><span class="comment">            value: (value),</span></span><br><span class="line"><span class="comment">            expression: &quot;value&quot;</span></span><br><span class="line"><span class="comment">        &#125;],</span></span><br><span class="line"><span class="comment">        domProps: &#123;</span></span><br><span class="line"><span class="comment">            &quot;value&quot;: (value)</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        on: &#123;</span></span><br><span class="line"><span class="comment">            &quot;input&quot;: function ($event) &#123;</span></span><br><span class="line"><span class="comment">                if ($event.target.composing) return;</span></span><br><span class="line"><span class="comment">                value = $event.target.value</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>编译时：不同的标签解析出的内容不一样 <code>platforms/web/compiler/directives/model.js</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">    genComponentModel(el, value, modifiers)</span><br><span class="line">    <span class="comment">// component v-model doesn&#x27;t need extra runtime</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">    genSelect(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> &amp;&amp; type === <span class="string">&#x27;checkbox&#x27;</span>) &#123;</span><br><span class="line">    genCheckboxModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> &amp;&amp; type === <span class="string">&#x27;radio&#x27;</span>) &#123;</span><br><span class="line">    genRadioModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> || tag === <span class="string">&#x27;textarea&#x27;</span>) &#123;</span><br><span class="line">    genDefaultModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!config.isReservedTag(tag)) &#123;</span><br><span class="line">    genComponentModel(el, value, modifiers)</span><br><span class="line">    <span class="comment">// component v-model doesn&#x27;t need extra runtime</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行时：会对元素处理一些关于输入法的问题 <code>platforms/web/runtime/directives/model.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">inserted (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.tag === <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// #6903</span></span><br><span class="line">      <span class="keyword">if</span> (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) &#123;</span><br><span class="line">        mergeVNodeHook(vnode, <span class="string">&#x27;postpatch&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          directive.componentUpdated(el, binding, vnode)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setSelected(el, binding, vnode.context)</span><br><span class="line">      &#125;</span><br><span class="line">      el._vOptions = [].map.call(el.options, getValue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vnode.tag === <span class="string">&#x27;textarea&#x27;</span> || isTextInputType(el.type)) &#123;</span><br><span class="line">      el._vModifiers = binding.modifiers</span><br><span class="line">      <span class="keyword">if</span> (!binding.modifiers.lazy) &#123;</span><br><span class="line">        el.addEventListener(<span class="string">&#x27;compositionstart&#x27;</span>, onCompositionStart)</span><br><span class="line">        el.addEventListener(<span class="string">&#x27;compositionend&#x27;</span>, onCompositionEnd)</span><br><span class="line">        <span class="comment">// Safari &lt; 10.2 &amp; UIWebView doesn&#x27;t fire compositionend when</span></span><br><span class="line">        <span class="comment">// switching focus before confirming composition choice</span></span><br><span class="line">        <span class="comment">// this also fixes the issue where some browsers e.g. iOS Chrome</span></span><br><span class="line">        <span class="comment">// fires &quot;change&quot; instead of &quot;input&quot; on autocomplete.</span></span><br><span class="line">        el.addEventListener(<span class="string">&#x27;change&#x27;</span>, onCompositionEnd)</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (isIE9) &#123;</span><br><span class="line">          el.vmodel = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Vue中v-html会导致哪些问题"><a href="#Vue中v-html会导致哪些问题" class="headerlink" title="Vue中v-html会导致哪些问题?"></a><code>Vue</code>中<code>v-html</code>会导致哪些问题?</h2><h3 id="理解-11"><a href="#理解-11" class="headerlink" title="理解:"></a>理解:</h3><ul><li>可能会导致<code>xss</code>攻击</li><li><code>v-html</code>会替换掉标签内部的子元素</li></ul><h3 id="原理-12"><a href="#原理-12" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r = template.compile(<span class="string">`&lt;div v-html=&quot;&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;&quot;&gt;&lt;/div&gt;`</span>)</span><br><span class="line"><span class="comment">// with(this)&#123;return _c(&#x27;div&#x27;,&#123;domProps:&#123;&quot;innerHTML&quot;:_s(&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;)&#125;&#125;)&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r.render);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _c 定义在core/instance/render.js</span></span><br><span class="line"><span class="comment">// _s 定义在core/instance/render-helpers/index,js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key === <span class="string">&#x27;textContent&#x27;</span> || key === <span class="string">&#x27;innerHTML&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vnode.children) vnode.children.length = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (cur === oldProps[key]) <span class="keyword">continue</span></span><br><span class="line">      <span class="comment">// #6601 work around Chrome version &lt;= 55 bug where single textNode</span></span><br><span class="line">      <span class="comment">// replaced by innerHTML/textContent retains its parentNode property</span></span><br><span class="line">      <span class="keyword">if</span> (elm.childNodes.length === <span class="number">1</span>) &#123;</span><br><span class="line">        elm.removeChild(elm.childNodes[<span class="number">0</span>])</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue父子组件生命周期调用顺序"><a href="#Vue父子组件生命周期调用顺序" class="headerlink" title="Vue父子组件生命周期调用顺序"></a><code>Vue</code>父子组件生命周期调用顺序</h2><h3 id="理解-12"><a href="#理解-12" class="headerlink" title="理解:"></a>理解:</h3><p>组件的调用顺序都是先父后子,渲染完成的顺序肯定是先子后父</p><p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父</p><h3 id="原理-13"><a href="#原理-13" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1582263422513.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = [] <span class="comment">// 定义收集所有组件的insert hook方法的数组</span></span><br><span class="line">    <span class="comment">// somthing ...</span></span><br><span class="line">    createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">    )</span><br><span class="line">  <span class="comment">// somthing...</span></span><br><span class="line">    <span class="comment">// 最终会依次调用收集的insert hook</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">    insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    nested,</span></span></span><br><span class="line"><span class="function"><span class="params">    ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">    index</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// createChildren会递归创建儿子组件</span></span><br><span class="line">        createChildren(vnode, children, insertedVnodeQueue) </span><br><span class="line">        <span class="comment">// something...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将组件的vnode插入到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">      cbs.create[i](emptyNode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    i = vnode.data.hook <span class="comment">// Reuse variable</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i.create)) i.create(emptyNode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (isDef(i.insert)) insertedVnodeQueue.push(vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// insert方法中会依次调用mounted方法</span></span><br><span class="line">insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// delay insert hooks for component root nodes, invoke them after the</span></span><br><span class="line">     <span class="comment">// element is really inserted</span></span><br><span class="line">     <span class="keyword">if</span> (isTrue(initial) &amp;&amp; isDef(vnode.parent)) &#123;</span><br><span class="line">         vnode.parent.data.pendingInsert = queue</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">             queue[i].data.hook.insert(queue[i]); <span class="comment">// 调用insert方法</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>) <span class="comment">// </span></span><br><span class="line">    <span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line">    vm.__patch__(vm._vnode, <span class="literal">null</span>) <span class="comment">// 先销毁儿子 </span></span><br><span class="line">    <span class="comment">// fire destroyed hook</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue组件如何通信"><a href="#Vue组件如何通信" class="headerlink" title="Vue组件如何通信?"></a><code>Vue</code>组件如何通信?</h2><ul><li>父子间通信  父-&gt;子通过<code>props</code>、子-&gt; 父<code>$on、$emit</code></li><li>获取父子组件实例的方式<code>$parent、$children</code></li><li>在父组件中提供数据子组件进行消费 <code>Provide、inject</code></li><li><code>Ref</code>获取实例的方式调用组件的属性或者方法</li><li><code>Event Bus</code> 实现跨组件通信</li><li><code>Vuex </code>状态管理实现通信</li></ul><h2 id="Vue中相同逻辑如何抽离？"><a href="#Vue中相同逻辑如何抽离？" class="headerlink" title="Vue中相同逻辑如何抽离？"></a><code>Vue</code>中相同逻辑如何抽离？</h2><ul><li><code>Vue.mixin</code>用法 给组件每个生命周期，函数等都混入一些公共逻辑</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.options = mergeOptions(<span class="built_in">this</span>.options, mixin); <span class="comment">// 将当前定义的属性合并到每个组件中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parent: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  child: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.extends) &#123; <span class="comment">// 递归合并extends</span></span><br><span class="line">      parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.mixins) &#123; <span class="comment">// 递归合并mixin</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125; <span class="comment">// 属性及生命周期的合并</span></span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">      mergeField(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    <span class="comment">// 调用不同属性合并策略进行合并</span></span><br><span class="line">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><h3 id="理解-13"><a href="#理解-13" class="headerlink" title="理解:"></a>理解:</h3><ul><li><p>如果组件功能多打包出的结果会变大，我可以采用异步的方式来加载组件。主要依赖<code>import()</code>这个语法，可以实现文件的分割加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">  <span class="function"><span class="title">AddCustomerSchedule</span>(<span class="params">resolve</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>([<span class="string">&quot;../components/AddCustomer&quot;</span>], resolve);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="原理-14"><a href="#原理-14" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resolveAsyncComponent(asyncFactory, baseCtor) <span class="comment">// 默认调用此函数时返回undefiend</span></span><br><span class="line">    <span class="comment">// 第二次渲染时Ctor不为undefined</span></span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder( <span class="comment">// 渲染占位符 空虚拟节点</span></span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  factory: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.resolved)) &#123; <span class="comment">// 在次渲染时可以拿到获取的最新组件</span></span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">      <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        forceRender(<span class="literal">true</span>) <span class="comment">// 强制更新视图重新渲染</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">          factory.error = <span class="literal">true</span></span><br><span class="line">          forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> res = factory(resolve, reject)<span class="comment">// 将resolve方法和reject方法传入，用户调用resolve方法后</span></span><br><span class="line">  sync = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> factory.resolved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是作用域插槽"><a href="#什么是作用域插槽" class="headerlink" title="什么是作用域插槽?"></a>什么是作用域插槽?</h2><h3 id="理解-14"><a href="#理解-14" class="headerlink" title="理解:"></a>理解:</h3><h4 id="插槽："><a href="#插槽：" class="headerlink" title="插槽："></a>插槽：</h4><ul><li>创建组件虚拟节点时，会将组件的儿子的虚拟节点保存起来。当初始化组件时,通过插槽属性将儿子进行分类 <code>&#123;a:[vnode],b[vnode]&#125;</code></li><li>渲染组件时会拿对应的slot属性的节点进行替换操作。（插槽的作用域为父组件）</li></ul><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽:"></a>作用域插槽:</h4><ul><li>作用域插槽在解析的时候，不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。（插槽的作用域为子组件）</li></ul><h3 id="原理-15"><a href="#原理-15" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E6%8F%92%E6%A7%BD.png"></p><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽:"></a>插槽:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;my-component&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot=&quot;header&quot;&gt;node&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;react&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot=&quot;footer&quot;&gt;vue&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/my-component&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;my-component&#x27;, [_c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        attrs: &#123;</span></span><br><span class="line"><span class="comment">            &quot;slot&quot;: &quot;header&quot;</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        slot: &quot;header&quot;</span></span><br><span class="line"><span class="comment">    &#125;, [_v(&quot;node&quot;)]), _v(&quot; &quot;), _c(&#x27;div&#x27;, [_v(&quot;react&quot;)]), _v(&quot; &quot;), _c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        attrs: &#123;</span></span><br><span class="line"><span class="comment">            &quot;slot&quot;: &quot;footer&quot;</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        slot: &quot;footer&quot;</span></span><br><span class="line"><span class="comment">    &#125;, [_v(&quot;vue&quot;)])])</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, [_t(&quot;header&quot;), _v(&quot; &quot;), _t(&quot;footer&quot;), _v(&quot; &quot;), _t(&quot;default&quot;)], 2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// _t定义在 core/instance/render-helpers/index.js</span></span><br></pre></td></tr></table></figure><h3 id="作用域插槽-1"><a href="#作用域插槽-1" class="headerlink" title="作用域插槽:"></a>作用域插槽:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;app&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot-scope=&quot;msg&quot; slot=&quot;footer&quot;&gt;&#123;&#123;msg.a&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/app&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;app&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        scopedSlots: _u([&#123; // 作用域插槽的内容会被渲染成一个函数</span></span><br><span class="line"><span class="comment">            key: &quot;footer&quot;,</span></span><br><span class="line"><span class="comment">            fn: function (msg) &#123;</span></span><br><span class="line"><span class="comment">                return _c(&#x27;div&#x27;, &#123;&#125;, [_v(_s(msg.a))])</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;])</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"></span><br><span class="line">VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;footer&quot; a=&quot;1&quot; b=&quot;2&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, [_t(&quot;footer&quot;, null, &#123;</span></span><br><span class="line"><span class="comment">        &quot;a&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="comment">        &quot;b&quot;: &quot;2&quot;</span></span><br><span class="line"><span class="comment">    &#125;)], 2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h2><h3 id="理解-15"><a href="#理解-15" class="headerlink" title="理解:"></a>理解:</h3><p><code>keep-alive</code>可以实现组件的缓存，当组件切换时不会对当前组件进行卸载,常用的2个属性<code>include</code>/<code>exclude</code>,2个生命周期<code>activated</code>,<code>deactivated</code></p><h3 id="原理-16"><a href="#原理-16" class="headerlink" title="原理:"></a>原理:</h3><blockquote><p><code>core/components/keep-alive.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>, <span class="comment">// 抽象组件</span></span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 创建缓存列表</span></span><br><span class="line">    <span class="built_in">this</span>.keys = [] <span class="comment">// 创建缓存组件的key列表</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123; <span class="comment">// keep-alive销毁时 会清空所有的缓存和key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.cache) &#123; <span class="comment">// 循环销毁</span></span><br><span class="line">      pruneCacheEntry(<span class="built_in">this</span>.cache, key, <span class="built_in">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted () &#123; <span class="comment">// 会监控include 和 include属性 进行组件的缓存处理</span></span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default <span class="comment">// 会默认拿插槽</span></span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot) <span class="comment">// 只缓存第一个组件</span></span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="comment">// 取出组件的名字</span></span><br><span class="line">      <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="comment">// 判断是否缓存</span></span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        : vnode.key <span class="comment">// 如果组件没key 就自己通过 组件的标签和key和cid 拼接一个key</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance <span class="comment">//  直接拿到组件实例</span></span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key) <span class="comment">// 删除当前的  [b,c,d,e,a]   // LRU 最近最久未使用法</span></span><br><span class="line">        keys.push(key) <span class="comment">// 并将key放到后面[b,a]</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[key] = vnode <span class="comment">// 缓存vnode</span></span><br><span class="line">        keys.push(key) <span class="comment">// 将key 存入</span></span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123; <span class="comment">// 缓存的太多超过了max 就需要删除掉</span></span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode) <span class="comment">// 要删除第0个 但是现在渲染的就是第0个</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span> <span class="comment">// 并且标准keep-alive下的组件是一个缓存组件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>]) <span class="comment">// 返回当前的虚拟节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue中常见性能优化"><a href="#Vue中常见性能优化" class="headerlink" title="Vue中常见性能优化"></a><code>Vue</code>中常见性能优化</h2><h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化:"></a>编码优化:</h3><ul><li><p>不要将所有的数据都放在data中，data中的数据都会增加getter和setter，会收集对应的watcher </p></li><li><p><code>vue</code> 在 v-for 时给每项元素绑定事件需要用事件代理</p></li><li><p><code>SPA</code>页面采用keep-alive缓存组件</p></li><li><p>拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染  )</p></li><li><p><code>v-if</code> 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show </p></li><li><p><code>key</code>保证唯一性 ( 默认<code>vue</code>会采用就地复用策略 )</p></li><li><p><code>Object.freeze</code> 冻结数据 </p></li><li><p>合理使用路由懒加载、异步组件</p></li><li><p>尽量采用runtime运行时版本</p></li><li><p>数据持久化的问题 （防抖、节流）</p></li></ul><h3 id="Vue加载性能优化"><a href="#Vue加载性能优化" class="headerlink" title="Vue加载性能优化:"></a><code>Vue</code>加载性能优化:</h3><ul><li><p>第三方模块按需导入 (<code>babel-plugin-component</code>) </p></li><li><p>滚动到可视区域动态加载  ( <a href="https://tangbc.github.io/vue-virtual-scroll-list">https://tangbc.github.io/vue-virtual-scroll-list</a> )</p></li><li><p>图片懒加载  (<a href="https://github.com/hilongjw/vue-lazyload.git">https://github.com/hilongjw/vue-lazyload.git</a>)</p></li></ul><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验:"></a>用户体验:</h3><ul><li><code>app-skeleton</code>骨架屏</li><li><code>app-shell</code>app壳</li><li><code>pwa</code></li></ul><h3 id="SEO优化："><a href="#SEO优化：" class="headerlink" title="SEO优化："></a><code>SEO</code>优化：</h3><ul><li>预渲染插件 <code>prerender-spa-plugin</code></li><li>服务端渲染<code>ssr</code></li></ul><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化:"></a>打包优化:</h3><ul><li>使用<code>cdn</code>的方式加载第三方模块 </li><li>多线程打包 <code>happypack </code></li><li><code>splitChunks</code> 抽离公共文件 </li><li><code>sourceMap</code>生成 </li></ul><h3 id="缓存，压缩"><a href="#缓存，压缩" class="headerlink" title="缓存，压缩"></a>缓存，压缩</h3><ul><li>客户端缓存、服务端缓存</li><li>服务端<code>gzip</code>压缩</li></ul><h2 id="Vue3-0你知道有哪些改进"><a href="#Vue3-0你知道有哪些改进" class="headerlink" title="Vue3.0你知道有哪些改进?"></a><code>Vue3.0</code>你知道有哪些改进?</h2><ul><li><p><code>Vue3</code>采用了TS来编写</p></li><li><p>支持 <code>Composition API </code></p></li><li><p><code>Vue3</code>中响应式数据原理改成<code>proxy</code></p></li><li><p><code> vdom</code>的对比算法更新，只更新<code>vdom</code>的绑定了动态数据的部分</p></li></ul><h2 id="实现hash路由和history路由"><a href="#实现hash路由和history路由" class="headerlink" title="实现hash路由和history路由"></a>实现<code>hash</code>路由和<code>history</code>路由</h2><ul><li><code>onhashchange</code></li><li><code>history.pushState</code></li></ul><h2 id="Vue-Router中导航守卫有哪些？"><a href="#Vue-Router中导航守卫有哪些？" class="headerlink" title="Vue-Router中导航守卫有哪些？"></a><code>Vue-Router</code>中导航守卫有哪些？</h2><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ul><li>导航被触发。</li><li>在失活的组件里调用离开守卫 <code>beforeRouteLeave</code>。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ul><h2 id="action-和-mutation区别"><a href="#action-和-mutation区别" class="headerlink" title="action 和 mutation区别"></a><code>action</code> 和 <code>mutation</code>区别</h2><ul><li><code>mutation</code>是同步更新数据(内部会进行是否为异步方式更新数据的检测)</li><li><code>action</code> 异步操作，可以获取数据后调佣<code>mutation</code>提交最终数据</li></ul><h2 id="简述Vuex工作原理"><a href="#简述Vuex工作原理" class="headerlink" title="简述Vuex工作原理"></a>简述<code>Vuex</code>工作原理</h2><p><img src="https://vuex.vuejs.org/vuex.png"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> vue代码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue代码解析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>react-redux</title>
    <url>./2020/10/25/React-Redux/</url>
    <content><![CDATA[<h2 id="React-Redux应用"><a href="#React-Redux应用" class="headerlink" title="React-Redux应用"></a>React-Redux应用</h2><h3 id="1-为什么需要高阶组件"><a href="#1-为什么需要高阶组件" class="headerlink" title="1.为什么需要高阶组件"></a>1.为什么需要高阶组件</h3><p>我们先看一个非常常见的例子，一个输入框需要从本地获取数据将获取的数据放到输入框内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Username extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;val:&#39;&#39;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    let username &#x3D; localStorage.getItem(&#39;username&#39;)||&#39;&#39;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      val:username</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.val&#125; onChange&#x3D;&#123;()&#x3D;&gt;&#123;&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段逻辑可能在Password组件中也要使用，那么从本地存储中获取数据放到输入框内的逻辑应该就是公用逻辑。这时我们就要使用高阶组件，也就是将组件在原有的基础上进行包装。</p>
</blockquote>
<a id="more"></a>
<h3 id="2-实现高阶组件"><a href="#2-实现高阶组件" class="headerlink" title="2.实现高阶组件"></a>2.实现高阶组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">let local &#x3D; (key)&#x3D;&gt;(Component)&#x3D;&gt;&#123;</span><br><span class="line">  return class HighOrderComponent extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state &#x3D; &#123;val:&#39;&#39;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      let username &#x3D; localStorage.getItem(key)||&#39;&#39;;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        val:username</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return &lt;Component &#123;...this.state&#125;&#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default local;</span><br><span class="line"></span><br><span class="line">import Local from &#39;.&#x2F;Local&#39;</span><br><span class="line">class Username extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.props.val&#125; onChange&#x3D;&#123;()&#x3D;&gt;&#123;&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Local(&#39;username&#39;)(Username);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们将公共的逻辑拿到外层组件，处理好后以属性的方式传递给原本的组件，为此高阶组件就是一个 React 组件包裹着另外一个 React 组件</p>
</blockquote>
<h3 id="3-context的用法"><a href="#3-context的用法" class="headerlink" title="3.context的用法"></a>3.context的用法</h3><p>react是单向数据流，我们想传递数据需要一层层向下传递，数据传递变得非常麻烦,我们可以用context实现数据的交互</p>
<ol>
<li><p>父 childContextTypes getChildContext函数</p>
</li>
<li><p>子 contextTypes</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App |-&gt; header -&gt; title</span><br></pre></td></tr></table></figure>

<h4 id="跨组件交互"><a href="#跨组件交互" class="headerlink" title="跨组件交互"></a>跨组件交互</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;</span><br><span class="line">import Header from &quot;.&#x2F;Header&quot;;</span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;color:&#39;red&#39;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static childContextTypes &#x3D; &#123; &#x2F;&#x2F;定义子组件上下文的类型</span><br><span class="line">    color:PropTypes.string,</span><br><span class="line">    setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  setColor &#x3D; (color) &#x3D;&gt;&#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        color</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123; &#x2F;&#x2F; 定义子组件上下文的数据</span><br><span class="line">    return &#123;color:this.state.color,setColor:this.setColor&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;Header&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Header extends React.Component &#123;</span><br><span class="line">  static contextTypes &#x3D; &#123;</span><br><span class="line">     setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;</span><br><span class="line">        this.context.setColor(&#39;green&#39;);</span><br><span class="line">      &#125;&#125;&gt;变绿&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;Title&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Title extends React.Component &#123;</span><br><span class="line">  static contextTypes &#x3D; &#123;</span><br><span class="line">    color:PropTypes.string</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123; &#x2F;&#x2F; 通过context获取父组件定义的数据</span><br><span class="line">    return &lt;div style&#x3D;&#123;&#123;color:this.context.color&#125;&#125;&gt;Title&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-使用react-redux实现todo"><a href="#4-使用react-redux实现todo" class="headerlink" title="4.使用react-redux实现todo"></a>4.使用react-redux实现todo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Todos |-&gt; TodoHeader</span><br><span class="line">      |-&gt; TodoItems</span><br><span class="line">      |-&gt; TodoFooter</span><br></pre></td></tr></table></figure>


<h3 id="5-实现react-redux库"><a href="#5-实现react-redux库" class="headerlink" title="5.实现react-redux库"></a>5.实现react-redux库</h3><h4 id="react-redux计数器"><a href="#react-redux计数器" class="headerlink" title="react-redux计数器"></a>react-redux计数器</h4><p>和以前写过的逻辑一致,这回加上react-redux的逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import Counter from &quot;.&#x2F;components&#x2F;Counter&quot;;</span><br><span class="line">import store from &#39;.&#x2F;store&#x2F;index&#39;;</span><br><span class="line">import &#123;Provider&#125; from &#39;react-redux&#39;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    &lt;Counter&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;,window.root);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; counter组件</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      数量:&#123;this.props.number&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.props.add(1)&#125;&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button  onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.props.minus(1)&#125;&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),dispatch&#x3D;&gt;(&#123;</span><br><span class="line">  add:(amount)&#x3D;&gt;&#123;dispatch(actions.add(amount))&#125;,</span><br><span class="line">  minus:(amount)&#x3D;&gt;&#123;dispatch(actions.minus(amount))&#125;</span><br><span class="line">&#125;))(Counter)</span><br></pre></td></tr></table></figure>

<h4 id="编写react-redux库"><a href="#编写react-redux库" class="headerlink" title="编写react-redux库"></a>编写react-redux库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line">class Provider extends React.Component&#123;</span><br><span class="line">  static childContextTypes &#x3D; &#123;</span><br><span class="line">    store:PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123;</span><br><span class="line">    return &#123;store:this.props.store&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let connect &#x3D; (mapStateToProps,mapDispatchToProps) &#x3D;&gt; (Component) &#x3D;&gt;&#123;</span><br><span class="line">  return class Proxy extends React.Component&#123;</span><br><span class="line">    static contextTypes &#x3D; &#123;</span><br><span class="line">      store:PropTypes.object</span><br><span class="line">    &#125;;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      this.unsubscribe &#x3D; this.context.store.subscribe(()&#x3D;&gt;&#123;</span><br><span class="line">        this.setState(mapStateToProps(this.context.store.getState()))</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">      this.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(props,context)&#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state &#x3D; mapStateToProps(context.store.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return &lt;Component &#123;...this.state&#125; &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;&#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;Provider,connect&#125;</span><br></pre></td></tr></table></figure>


<h4 id="bindActionCreators方法"><a href="#bindActionCreators方法" class="headerlink" title="bindActionCreators方法"></a>bindActionCreators方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let bindActionCreators &#x3D; (actions,dispatch) &#x3D;&gt; &#123;</span><br><span class="line">  let obj &#x3D; &#123;&#125;</span><br><span class="line">  for(let key in actions)&#123;</span><br><span class="line">    obj[key] &#x3D; (...args)&#x3D;&gt;&#123;</span><br><span class="line">      dispatch(actions[key](...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),dispatch&#x3D;&gt;bindActionCreators(actions,dispatch))(Counter)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bindActionCreators是redux中的一个方法，并且这样的逻辑过于复杂，我们依旧希望可以在react-redux中内部可以简化操作</p>
</blockquote>
<h4 id="简化mapDispatchToProps"><a href="#简化mapDispatchToProps" class="headerlink" title="简化mapDispatchToProps"></a>简化mapDispatchToProps</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),actions)(Counter);</span><br><span class="line"></span><br><span class="line">import &#123;bindActionCreators&#125; from &#39;.&#x2F;redux&#39;</span><br><span class="line">render()&#123;</span><br><span class="line">  let r &#x3D;&#123;&#125;</span><br><span class="line">  if(typeof mapDispatchToProps &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">    r &#x3D; bindActionCreators(mapDispatchToProps,this.context.store.dispatch)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    r &#x3D; mapDispatchToProps(this.context.store.dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;Component &#123;...this.state&#125; &#123;...r&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样我们在组件中更改状态时可以直接传入actionCreator对象。</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react  redux中间件</title>
    <url>./2020/10/26/MiddleWare%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MiddleWare的使用"><a href="#MiddleWare的使用" class="headerlink" title="MiddleWare的使用"></a>MiddleWare的使用</h2><h3 id="1-logger中间件"><a href="#1-logger中间件" class="headerlink" title="1.logger中间件"></a>1.logger中间件</h3><p>我们改写了，dispatch方法实现了在更改状态时打印前后的状态,但是这种方案并不好。所以我们可以采用中间的方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"><span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number);</span><br><span class="line">  dispatch(action);</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="实现logger中间件"><a href="#实现logger中间件" class="headerlink" title="实现logger中间件"></a>实现logger中间件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number);</span><br><span class="line">  dispatch(action);</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> applyMiddleWare = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function"><span class="params">reducer</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="keyword">let</span> middle = middleware(store);</span><br><span class="line">  <span class="keyword">let</span> dispatch = middle(store.dispatch);</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="comment">//将中间返回的dispatch方法覆盖掉原有store中的dispatch</span></span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> applyMiddleWare(logger)(createStore)(reducer);</span><br></pre></td></tr></table></figure>

<h3 id="2-实现redux-thunk中间件"><a href="#2-实现redux-thunk中间件" class="headerlink" title="2.实现redux-thunk中间件"></a>2.实现redux-thunk中间件</h3><p>实现派发异步动作,actionCreator可以返回函数，可以把dispatch的权限交给此函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch,getState</span>) </span>&#123;</span><br><span class="line">      dispatch(&#123;<span class="attr">type</span>:Types.ADD,amount&#125;);</span><br><span class="line">      dispatch(&#123;<span class="attr">type</span>:Types.ADD,amount&#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(getState().number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">minus</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:Types.MINUS,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">let</span> reduxThunk = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span></span>)</span>&#123; <span class="comment">//如果是函数将派发的权限传递给函数</span></span><br><span class="line">    <span class="keyword">return</span> action(dispatch,store.getState);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现redux-promise中间件"><a href="#3-实现redux-promise中间件" class="headerlink" title="3.实现redux-promise中间件"></a>3.实现redux-promise中间件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; action</span><br><span class="line">minus(amount)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      type:Types.MINUS,</span><br><span class="line">      payload:new Promise(function (resolve,reject) &#123;</span><br><span class="line">        reject(&#123;amount:2&#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;store&#x2F;index.js</span><br><span class="line">let reduxPromise &#x3D; store &#x3D;&gt; dispatch &#x3D;&gt; action&#x3D;&gt;&#123;</span><br><span class="line">  if(action.then)&#123;</span><br><span class="line">    return action.then(dispatch); &#x2F;&#x2F;只支持成功</span><br><span class="line">  &#125;else if(action.payload&amp;&amp;action.payload.then)&#123;</span><br><span class="line">    &#x2F;&#x2F; 如果payload是一个promise 会对成功和失败都进行捕获并且将成功或失败的数据放到payload中进行派发</span><br><span class="line">    return action.payload.then(function (data) &#123;</span><br><span class="line">      dispatch(&#123;...action,payload:data&#125;);</span><br><span class="line">    &#125;,function (data) &#123;</span><br><span class="line">      dispatch(&#123;...action,payload:data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-compose应用"><a href="#4-compose应用" class="headerlink" title="4.compose应用"></a>4.compose应用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function toResult(who,decorator) &#123;</span><br><span class="line">  return who+decorator;</span><br><span class="line">&#125;</span><br><span class="line">function len(str) &#123;</span><br><span class="line">  return str.length</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 我们的目的是将第一个函数的返回结果传递给第二个函数</span><br><span class="line">console.log(len(toResult(&#39;Mrs jiang&#39;, &#39;很帅&#39;)));</span><br></pre></td></tr></table></figure>

<h4 id="实现compose"><a href="#实现compose" class="headerlink" title="实现compose"></a>实现compose</h4><p>这个compose也是redux中的一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let compose &#x3D; (...fns)&#x3D;&gt;(...args)&#x3D;&gt; &#123;</span><br><span class="line">  let last &#x3D; fns.pop();</span><br><span class="line">  return fns.reduceRight(function (prev,next) &#123;</span><br><span class="line">      return next(prev);</span><br><span class="line">  &#125;,last(...args))</span><br><span class="line">&#125;;</span><br><span class="line">console.log(compose(len, toResult)(&#39;Mrs jiang&#39;, &#39;很帅&#39;));</span><br></pre></td></tr></table></figure>

<h3 id="5-applyMiddleware实现"><a href="#5-applyMiddleware实现" class="headerlink" title="5.applyMiddleware实现"></a>5.applyMiddleware实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let applyMiddleWare &#x3D; (...middlewares) &#x3D;&gt; createStore &#x3D;&gt; reducer &#x3D;&gt;&#123;</span><br><span class="line">  let store &#x3D; createStore(reducer);</span><br><span class="line">  let middles &#x3D; middlewares.map(middleware&#x3D;&gt;middleware(store))</span><br><span class="line">  let dispatch &#x3D; compose(...middles)(store.dispatch);</span><br><span class="line">  return &#123;</span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-简化applyMiddleWare应用"><a href="#6-简化applyMiddleWare应用" class="headerlink" title="6.简化applyMiddleWare应用"></a>6.简化applyMiddleWare应用</h3><p>最终实现效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default createStore(reducer,applyMiddleware(reduxThunk,reduxPromise));</span><br></pre></td></tr></table></figure>
<p>最终版redux库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let createStore &#x3D; (reducer, fn) &#x3D;&gt; &#123;</span><br><span class="line">    let state;</span><br><span class="line">    let listeners &#x3D; [];</span><br><span class="line">    let getState &#x3D; () &#x3D;&gt; state;</span><br><span class="line">    let dispatch &#x3D; (action) &#x3D;&gt; &#123;</span><br><span class="line">        state &#x3D; reducer(state, action);</span><br><span class="line">        listeners.forEach(item &#x3D;&gt; item());</span><br><span class="line">    &#125;;</span><br><span class="line">    dispatch(&#123;&#125;);</span><br><span class="line">    let subscribe &#x3D; (l) &#x3D;&gt; &#123;</span><br><span class="line">        listeners.push(l);</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            listeners &#x3D; listeners.filter(item &#x3D;&gt; item !&#x3D;&#x3D; l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    if (typeof fn &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return fn(createStore, reducer);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        createStore,</span><br><span class="line">        dispatch,</span><br><span class="line">        getState,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let combineReducers &#x3D; (reducers) &#x3D;&gt; (newState &#x3D; &#123;&#125;, action) &#x3D;&gt; &#123;</span><br><span class="line">    for (let key in reducers) &#123;</span><br><span class="line">        newState[key] &#x3D; reducers[key](newState[key], action)</span><br><span class="line">    &#125;</span><br><span class="line">    return newState;</span><br><span class="line">&#125;;</span><br><span class="line">let bindActionCreators &#x3D; (actions, dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    let obj &#x3D; &#123;&#125;;</span><br><span class="line">    for (let key in actions) &#123;</span><br><span class="line">        obj[key] &#x3D; (...args) &#x3D;&gt; dispatch(actions[key](...args))</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;;</span><br><span class="line">let applyMiddleware &#x3D; (...middlewares) &#x3D;&gt; (createStore, reducer) &#x3D;&gt; &#123;</span><br><span class="line">    let store &#x3D; createStore(reducer);</span><br><span class="line">    let middles &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(store));</span><br><span class="line">    let dispatch &#x3D; compose(...middles)(store.dispatch);</span><br><span class="line">    return &#123;</span><br><span class="line">        ...store,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let compose &#x3D; (...fns) &#x3D;&gt; &#123;</span><br><span class="line">    return (...args) &#x3D;&gt; &#123;</span><br><span class="line">        let fn &#x3D; fns.pop();</span><br><span class="line">        return fns.reduceRight((prev, next) &#x3D;&gt; &#123;</span><br><span class="line">            return next(prev);</span><br><span class="line">        &#125;, fn(...args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125;</span><br></pre></td></tr></table></figure>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react redux中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器原理</title>
    <url>./2021/05/14/browersRander/</url>
    <content><![CDATA[<h2 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h2><ul>
<li><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html">浏览器原理</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>浏览器原理</category>
      </categories>
      <tags>
        <tag>浏览器原理</tag>
      </tags>
  </entry>
  <entry>
    <title>react Redux深入</title>
    <url>./2020/10/24/Redux%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Redux深入"><a href="#Redux深入" class="headerlink" title="Redux深入"></a>Redux深入</h2><h3 id="1-redux文件拆分"><a href="#1-redux文件拆分" class="headerlink" title="1.redux文件拆分"></a>1.redux文件拆分</h3><p>我们将计数器的案例进行文件拆分,使代码更加容易维护和阅读,我们来增加一个store文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store</span><br><span class="line">    │  action-types.js</span><br><span class="line">    │  index.js</span><br><span class="line">    │</span><br><span class="line">    ├─actions</span><br><span class="line">    │      counter.js</span><br><span class="line">    │</span><br><span class="line">    └─reducer</span><br><span class="line">            counter.js</span><br></pre></td></tr></table></figure>

<ul>
<li><p>action-types用来存放需要的常量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const ADD &#x3D; &#39;ADD&#39;;</span><br><span class="line">export const MINUS &#x3D; &#39;MINUS&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>counter中存放reducer的逻辑</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default function reducer(state&#x3D;&#123;number:0&#125;,action) &#123;</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case Types.ADD:</span><br><span class="line">      return &#123;number:state.number + action.amount&#125;;</span><br><span class="line">    case Types.MINUS:</span><br><span class="line">      return &#123;number:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>store中的index文件用来创建store</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createStore&#125; from &#39;..&#x2F;redux&#39;;</span><br><span class="line">import reducer from &#39;.&#x2F;reducer&#x2F;counter&#39;;</span><br><span class="line">export default createStore(reducer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中的内容可更改为</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class="line">import ReactDOM,&#123;render&#125; from &#39;react-dom&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line">import * as Types from &#39;.&#x2F;store&#x2F;action-types&#39;</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;number:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    store.subscribe( () &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;number:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(&#123;type:Types.ADD,amount:1&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(&#123;type:Types.MINUS,amount:1&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;this.state.number&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleAddClick&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleMinusClick&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Counter&#x2F;&gt;,window.root);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>此时我们发现在redux和组件中都应用了action-types所以我们希望继续进行拆分,在store下创建action文件夹,用来生成action对象,我们管action文件中的方法称之为actionCreator</p>
</blockquote>
<ul>
<li><p>action文件夹中的counter,用来生成对应组件的action对象</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  add(amount)&#123;</span><br><span class="line">    return &#123;type:Types.ADD,amount&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minus(amount)&#123;</span><br><span class="line">    return &#123;type:Types.MINUS,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次更改组件代码</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class="line">import ReactDOM,&#123;render&#125; from &#39;react-dom&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line">import actions from &#39;.&#x2F;store&#x2F;actions&#x2F;counter&#39;</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;number:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    store.subscribe( () &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;number:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(actions.add(1));</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(actions.minus(1));</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;this.state.number&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleAddClick&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleMinusClick&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Counter&#x2F;&gt;,window.root);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>我们已经将redux的流程进行了详细的拆分,让我们来总结一下redux的流程吧：</p>
</blockquote>
<p><img src="http://son.fullstackjavascript.cn/redux.png"></p>
<h3 id="2-实现多个counter"><a href="#2-实现多个counter" class="headerlink" title="2.实现多个counter"></a>2.实现多个counter</h3><p>在redux中只能拥有一个store所以我们需要将多个状态进行合并,状态是通过reducer返回的，所以我们可以将多个reducer进行合并达到合并状态的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│  index.js</span><br><span class="line">│  redux.js</span><br><span class="line">│</span><br><span class="line">├─components</span><br><span class="line">│      counter1.js</span><br><span class="line">│      counter2.js</span><br><span class="line">│</span><br><span class="line">└─store</span><br><span class="line">    │  action-types.js</span><br><span class="line">    │  index.js</span><br><span class="line">    │</span><br><span class="line">    ├─actions</span><br><span class="line">    │      counter1.js</span><br><span class="line">    │      counter2.js</span><br><span class="line">    │</span><br><span class="line">    └─reducer</span><br><span class="line">            counter1.js</span><br><span class="line">            counter2.js</span><br><span class="line">            index.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们将counter1的逻辑进行拷贝，粘贴出counter2</p>
</blockquote>
<ul>
<li><p>action-types新增counter2处理的常量</p>
  <figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export const ADD = &#x27;ADD&#x27;;</span><br><span class="line">export const MINUS = &#x27;MINUS&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ export const INCREMENT = &#x27;INCREMENT&#x27;;</span></span><br><span class="line"><span class="addition">+ export const DECREMENT = &#x27;DECREMENT&#x27;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对应的counter2中的action也进行更改</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  add(amount)&#123;</span><br><span class="line">    return &#123;type:Types.INCREMENT,amount&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minus(amount)&#123;</span><br><span class="line">    return &#123;type:Types.DECREMENT,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样reducer中处理也是一样的</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default function reducer(state&#x3D;&#123;number:0&#125;,action) &#123;</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case Types.INCREMENT:</span><br><span class="line">      return &#123;number:state.number + action.amount&#125;;</span><br><span class="line">    case Types.DECREMENT:</span><br><span class="line">      return &#123;number:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在问题出现了我们拥有了两个reducer,我们要将两个reducer进行合并,合并成一个新的reducer</p>
</blockquote>
</li>
<li><p>combineReducers</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import counter1 from &#39;.&#x2F;counter1&#39;;</span><br><span class="line">import counter2 from &#39;.&#x2F;counter2&#39;;</span><br><span class="line">let combineReducers &#x3D; (reducers) &#x3D;&gt; &#123;</span><br><span class="line">  return (state&#x3D;&#123;&#125;,action)&#x3D;&gt;&#123;</span><br><span class="line">    let obj &#x3D; &#123;&#125;;</span><br><span class="line">    for(let key in reducers)&#123;</span><br><span class="line">      obj[key] &#x3D; reducers[key](state[key],action); &#x2F;&#x2F;调用原有的reducer将返回的结果放到对象上</span><br><span class="line">    &#125;</span><br><span class="line">    return obj; &#x2F;&#x2F; 将合并后的对象进行返回即可 &#123;counter1:&#123;number:0&#125;,counter2:&#123;number:0&#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default combineReducers(&#123;</span><br><span class="line">  counter1,counter2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后组件中获取状态要增加合并时的命名空间来获取</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;number:store.getState().counter1.number&#125;</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    store.subscribe( () &#x3D;&gt; &#123;</span><br><span class="line">        this.setState(&#123;number:store.getState().counter1.number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>./2021/05/18/TypeScript/</url>
    <content><![CDATA[<h2 id="TypeScript-教程"><a href="#TypeScript-教程" class="headerlink" title="TypeScript 教程"></a>TypeScript 教程</h2><ul>
<li><p><a href="https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json">深入理解Typescript</a></p>
</li>
<li><p><a href="https://typescript.bootcss.com/">typescript</a></p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>googleV8</title>
    <url>./2020/11/27/googleV8/</url>
    <content><![CDATA[<h2 id="如何学习谷歌高性能-JavaScript-引擎V8"><a href="#如何学习谷歌高性能-JavaScript-引擎V8" class="headerlink" title="如何学习谷歌高性能 JavaScript 引擎V8"></a>如何学习谷歌高性能 JavaScript 引擎V8</h2><ul>
<li><p>什么是 V8？<br>V8 是 JavaScript 虚拟机的一种。我们可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的编程语言 JavaScript，翻译成机器能够理解的机器语言。如下图所示：<br><img src="./2020/11/27/googleV8/v8_01.jpg" alt="JavaScript引擎"></p>
<p>上图中，中间的“黑盒”就是 JavaScript 引擎 V8。目前市面上有很多种 JavaScript 引擎，诸如 SpiderMonkey、V8、JavaScriptCore 等。而由谷歌开发的开源项目 V8 是当下使用最广泛的 JavaScript 虚拟机，全球有超过 25 亿台安卓设备，而这些设备中都使用了 Chrome 浏览器，所以我们写的 JavaScript 应用，大都跑在 V8 上。<br>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升</p>
<a id="more"></a>
<p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。</p>
<p>V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以你会看到目前市面上 JavaScript 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率</p>
<p>V8 的主要功能，就是结合 JavaScript 语言的特性和本质来编译执行它</p>
</li>
<li><p>学习V8</p>
<p>V8 的编译流水线，其完整流程<br><img src="./2020/11/27/googleV8/v8_02.jpg" alt="v8编译流水线"><br>编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等等。这些技术决定着一段 JavaScript 代码能否正常执行，以及代码的执行效率。</p>
<p>V8 中使用的隐藏类（Hide Class），这是将 JavaScript 中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果你熟悉 V8 的工作机制，在你编写 JavaScript 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码</p>
<p>V8 实现了 JavaScript 代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，你可以优化你的代码更加适应这个机制，从而提高程序性能</p>
<p>除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是 <strong><em>事件循环系统</em></strong> 和 <strong><em>垃圾回收机制</em></strong>。</p>
<p>事件循环系统和 JavaScript 中的难点——异步编程特性紧密相关。JavaScript 是单线程的，JavaScript 代码都是在一个线程上执行，如果同一时间发送了多个 JavaScript 执行的请求，就需要排队，也就是进行异步编程。<br>V8 的事件循环系统会调度这些排队任务，保证 JavaScript 代码被 V8 有序地执行。因此也可以说，事件循环系统就是 V8 的心脏，它驱动了 V8 的持续工作。</p>
<p>JavaScript 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是我们经常会遇到的一个问题。你需要知道 V8 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了<br><img src="./2020/11/27/googleV8/all_v8.jpg" alt="v8"></p>
</li>
</ul>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>googlV8<ul>
<li>v8的基础环境<ul>
<li>堆空间<ul>
<li>树状存储结构</li>
<li>存储对象</li>
<li>存储闭包函数引用的原生类型</li>
</ul>
</li>
<li>栈空间<ul>
<li>先进后出</li>
<li>存储原生类型</li>
</ul>
</li>
<li>全局执行上下文<ul>
<li>初始化this</li>
<li>全局作用域</li>
<li>全局对象</li>
</ul>
</li>
<li>宿主环境<ul>
<li>宿主类型<ul>
<li>浏览器</li>
<li>node</li>
<li>其他宿主</li>
</ul>
</li>
<li>内置<ul>
<li>内置函数</li>
<li>内置对象<ul>
<li>浏览器 window</li>
<li>node.global</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>事件循环系统<ul>
<li>消息队列</li>
<li>任务调度系统</li>
</ul>
</li>
</ul>
</li>
<li>v8执行流程<ul>
<li>词法分析<ul>
<li>扫描源码</li>
<li>分割源码中的字符</li>
<li>输出Token</li>
</ul>
</li>
<li>语法分析<ul>
<li>基于词法分析出来的Token分析语法错误，给出提示</li>
<li>输出AST</li>
<li>输出作用域<ul>
<li>词法作用域规则</li>
<li>包含当前域中的对象和函数</li>
</ul>
</li>
<li>惰性编译<ul>
<li>推迟解析函数中的代码</li>
<li>到执行函数时再解析</li>
<li>默认只解析顶层代码</li>
</ul>
</li>
<li>预解析器<ul>
<li>快速查看函数</li>
<li>检查函数的语法是否正确</li>
<li>检查是否有闭包函数<ul>
<li>如果函数引用了父函数中的变量，那么必须将引用的变量分配到堆中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>字节码<ul>
<li>v8执行javascript过程中的中间代码</li>
<li>根据作用域和AST生成</li>
<li>机器代码的抽象</li>
<li>v8虚拟机的指令集</li>
<li>字节码缓存<ul>
<li>降低内存</li>
<li>提升执行速度</li>
</ul>
</li>
</ul>
</li>
<li>解释执行字节码<ul>
<li>两种经典的虚拟机架构<ul>
<li>寄存器的虚拟机<ul>
<li>累加器<ul>
<li>计算过程中临时变量存放在累加器中</li>
</ul>
</li>
<li>寄存器<ul>
<li>PC寄存器—— 用来存放下一条字节码指令<ul>
<li>通用寄存器—— 用来存放数据</li>
</ul>
</li>
</ul>
</li>
<li>堆和栈<ul>
<li>堆存放对象等数据<ul>
<li>栈管理函数调用关系</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基于栈架构的虚拟机<ul>
<li>寄存器<ul>
<li>pc寄存器</li>
<li>通用寄存器</li>
</ul>
</li>
<li>栈<ul>
<li>管理函数调用</li>
<li>存放临时变量</li>
</ul>
</li>
<li>堆<ul>
<li>存放对象等数据</li>
</ul>
</li>
</ul>
</li>
<li>v8才用的是寄存器的虚拟机<ul>
<li>充分使用累加器</li>
<li>字节码指令集的编程风格和基于栈的有差异</li>
<li>顺序执行字节码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优化字节码执行速度<ul>
<li>为什么解释执行慢<ul>
<li>javascript 是动态语言</li>
<li>v8事先不知道类型的形状</li>
<li>动态查找属性</li>
<li>执行之前需要编译</li>
</ul>
</li>
<li>内联缓存<ul>
<li>缓存对象形状</li>
<li>下次执行相同类型时，直接使用该形态来快速定位属性</li>
</ul>
</li>
</ul>
</li>
<li>即时编译<ul>
<li>监视器<ul>
<li>监视解释器的执行过程</li>
<li>发现热点代码</li>
<li>将热点代码提交给编辑器优化</li>
</ul>
</li>
<li>编译器<ul>
<li>编译器会编译热点代码</li>
<li>并优化编译后的二进制机器代码</li>
<li>二进制代码能够被高效执行</li>
</ul>
</li>
<li>隐藏类<ul>
<li>提取代码中的对象的形状</li>
<li>并记录具体形状</li>
<li>通过形状快速定位对象属性</li>
</ul>
</li>
<li>反优化<ul>
<li>对象的形状被动态修改了</li>
<li>隐藏类失效</li>
<li>触发反优化机制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>事件循环系统<ul>
<li>什么是事件循环系统<ul>
<li>javascript是单线程模式</li>
<li>单线程同时只能执行一个任务</li>
<li>有新的任务就需要排队执行</li>
<li>引入消息队列</li>
<li>消息队列中的任务是宏任务</li>
<li>任务调度器<ul>
<li>循环读取消息队列中的任务</li>
<li>分派给指定的任务处理器</li>
</ul>
</li>
</ul>
</li>
<li>异步编程<ul>
<li>回掉函数模式<ul>
<li>以回掉函数的方式编写异步代码</li>
<li>可读性差</li>
<li>代码难维护</li>
<li>回掉地狱</li>
</ul>
</li>
<li>Promise 模式<ul>
<li>半同步的方式编写异步代码</li>
<li>使用微任务</li>
<li>改造了回调函数</li>
<li>可读性提升</li>
</ul>
</li>
<li>async/await 模式<ul>
<li>同步的方式编写异步代码</li>
<li>使用微任务</li>
<li>使用了协程</li>
<li>可读性大幅提升</li>
<li>原理复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>javascript设计思想<ul>
<li>函数一等公民<ul>
<li>函数拥有普通类型的特性<ul>
<li>可以作为参数</li>
<li>可以作为返回值</li>
<li>可以赋值给一个变量</li>
</ul>
</li>
<li>基于对象设计<ul>
<li>基本类型<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Symbol</li>
<li>BigInt</li>
</ul>
</li>
<li>对象类型<ul>
<li>普通对象</li>
<li>函数</li>
<li>数组</li>
</ul>
</li>
</ul>
</li>
<li>对象是动态的<ul>
<li>可以在运行时改变对象属性</li>
</ul>
</li>
<li>支持闭包<ul>
<li>函数即对象</li>
<li>函数可以作为返回值</li>
<li>子函数可以引用父函数内部的变量</li>
<li>父函数返回子函数，子函数引用父函数的变量需要一同打包带走</li>
</ul>
</li>
<li>函数表达式<ul>
<li>函数声明<ul>
<li>在编译阶段，会将声明的函数转换成函数对象</li>
<li>函数声明会被变量提升</li>
</ul>
</li>
<li>函数表达式<ul>
<li>在编译阶段，不会对函数表达式做任何操作</li>
<li>立即调用函数表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>类型系统和垃圾回收<ul>
<li>类型系统<ul>
<li>什么是类型系统<ul>
<li>内存中的二进制是没有类型的</li>
<li>我们可以强制给一组二进制赋予类型信息</li>
<li>类型信息为许多操作提供隐含的上下文<ul>
<li>两个整数类型相加</li>
<li>两个字符串类型相加</li>
</ul>
</li>
<li>类型系统限制了不合法的类型操作<ul>
<li>1+ ‘2’ js 中合法</li>
<li>1+ ‘2’ Python 中不合法</li>
</ul>
</li>
</ul>
</li>
<li>不同的类型如何存储<ul>
<li>对象存储在堆中</li>
<li>基本类型存储在栈中</li>
</ul>
</li>
<li>传值和传引用<ul>
<li>原生类型一律传值</li>
<li>对象类型一律传引用</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收<ul>
<li>采用自动垃圾回收策略</li>
</ul>
</li>
</ul>
</li>
<li>作用域<ul>
<li>源代码中定义变量的区域</li>
<li>静态作用域（写代码的时候静态确认下来的）</li>
<li>动态作用域 （和函数调用的位置有关）</li>
<li>javascript 是基于静态作用域</li>
<li>作用域链(沿着多个作用域，查找变量的链路)<ul>
<li>函数级作用域</li>
<li>函数内声明的变量生成周期和函数绑定</li>
<li>块级作用域</li>
<li>变量和函数声明</li>
</ul>
</li>
</ul>
</li>
<li>原型链继承<ul>
<li>原型<ul>
<li>每个对象都有一个原型属性</li>
<li>原型也是一个对象</li>
<li>通过__proto__指向原型对象</li>
</ul>
</li>
<li>原型链(查找对象属性的链路)<ul>
<li>先在当前的属性中查找</li>
<li>再在原型对象中查找</li>
<li>再在原型的原型对象中查找直到 顶层Object的原型对象</li>
</ul>
</li>
<li>new 关键字</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收系统<ul>
<li>什么是自动垃圾回收系统<ul>
<li>自动跟踪正在使用的对象并回收不再使用的对象</li>
</ul>
</li>
<li>回收方式<ul>
<li>手动分配和回收<ul>
<li>显示分配内存</li>
<li>手动回收内存</li>
</ul>
</li>
<li>智能指针<ul>
<li>记住每个对象被引用的次数</li>
<li>当引用计数为0 时，便自动回收该对象</li>
</ul>
</li>
<li>自动内存管理<ul>
<li>所有被引用的元素都用一个根元素</li>
<li>每次从根向下遍历，没有被遍历到的数据视为垃圾数据</li>
</ul>
</li>
</ul>
</li>
<li>代记假说<ul>
<li>大部分对象在内存中存活的时间短</li>
<li>不死的对象会会活的更久</li>
</ul>
</li>
<li>分代收集<ul>
<li>新生代存放新对象那</li>
<li>老生代存放老对象</li>
</ul>
</li>
<li>垃圾回收器<ul>
<li>副垃圾回收器(负责新生代的垃圾回收)</li>
<li>主垃圾回收器（负责老生代的代码回收）</li>
</ul>
</li>
<li>垃圾回收流程<ul>
<li>通用流程<ul>
<li>回收非活动对象占用的内存</li>
<li>整理内存碎片</li>
</ul>
</li>
<li>副垃圾回收器<ul>
<li>Scavenge 算法</li>
<li>新生代的对象和空闲区域</li>
<li>对象晋升策略</li>
</ul>
</li>
<li>主垃圾回收器<ul>
<li>标记清除算法</li>
<li>标记整理算法</li>
<li>大对象</li>
<li>晋升的对象</li>
</ul>
</li>
<li>全停顿<ul>
<li>垃圾回收操作会占用主线程</li>
<li>会阻塞主线程<ul>
<li>引发问题<ul>
<li>代码不规范，触发频繁的垃圾回收，主业务被阻塞</li>
</ul>
</li>
<li>优化方法<ul>
<li>优化代码<ul>
<li>减少触发垃圾回收次数</li>
<li>采用增量垃圾回收</li>
</ul>
</li>
<li>v8 采用并行垃圾回收策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>googleV8</category>
      </categories>
      <tags>
        <tag>googleV8</tag>
      </tags>
  </entry>
  <entry>
    <title>react Redux</title>
    <url>./2020/10/23/Redux%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><p>我们一直通过属性来进行组件中的数据传递,这种模式是非常脆弱的。在日常的开发中经常会遇到非父子组件传递的场景。原来的方式是找到共同的父级进行数据交互，这时通信就变得比较麻烦<br>我们先通过一个简单的例子实现一下redux的工作模式:</p>
<h3 id="1-统一数据管理"><a href="#1-统一数据管理" class="headerlink" title="1).统一数据管理"></a>1).统一数据管理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">  content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.content&#x27;</span>);</span><br><span class="line">  content.innerHTML = state.content.text;</span><br><span class="line">  content.style.color = state.content.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.title&#x27;</span>);</span><br><span class="line">  title.innerHTML = state.title.text;</span><br><span class="line">  title.style.color = state.title.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line">renderApp();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们可以将renderContent,renderTitle看成两个组件将所需的数据提取到state中统一进行管理。当渲染后我们希望更改状态，封装更改状态的方法(dispatch)</p>
</blockquote>
<a id="more"></a>
<h3 id="2-实现dispatch"><a href="#2-实现dispatch" class="headerlink" title="2).实现dispatch"></a>2).实现dispatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">      state = &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要直接更改状态而是使用dispatch方法进行状态的更改,派发一个带有type的属性来进行状态的更改，但是依然无法阻止用户更改状态.</p>
</blockquote>
<h3 id="3-createStore的实现"><a href="#3-createStore的实现" class="headerlink" title="3).createStore的实现"></a>3).createStore的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = &#123;</span><br><span class="line">    title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">    content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)); <span class="comment">// 创造一份和状态同样的对象给外界来用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">      <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">        state = &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = createStore(); <span class="comment">// 拿到createStore中返回的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.content&#x27;</span>);</span><br><span class="line">  content.innerHTML = store.getState().content.text;</span><br><span class="line">  content.style.color = store.getState().content.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.title&#x27;</span>);</span><br><span class="line">  title.innerHTML = store.getState().title.text;</span><br><span class="line">  title.style.color = store.getState().title.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line">renderApp();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<!-- more -->
<blockquote>
<p>我们将状态放到了createStore函数中，目的是隔离作用域，并且再内部返回深度克隆的对象，这样用户无法再通过外界更改状态。但是状态应该由我们自身来控制，应该是外界传入的，所以要将状态拿出createStore。并且判断的逻辑也应该由我们自己来编写</p>
</blockquote>
<h3 id="4-reducer的实现"><a href="#4-reducer的实现" class="headerlink" title="4).reducer的实现"></a>4).reducer的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123; </span><br><span class="line">    state  = reducer(state,action);<span class="comment">//获取对应的状态覆盖掉store中的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;&#125;); <span class="comment">// 默认传入空对象获取reducer返回的默认结果</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> initState = &#123;</span><br><span class="line">  title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">  content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// reducer应该具有默认状态,当更改状态后使用最新的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=initState,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时我们已将需要自己处理的逻辑提取出来，但是我们每次dispatch时都需要自己触发视图的更新,我们希望采用发布订阅来实现。</p>
</blockquote>
<h3 id="5-订阅函数"><a href="#5-订阅函数" class="headerlink" title="5).订阅函数"></a>5).订阅函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = []; <span class="comment">// 放置所有订阅的函数</span></span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span>=&gt;</span>item());<span class="comment">//每次派发后执行订阅的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">fn</span>)=&gt;</span>&#123; <span class="comment">//主要用于订阅事件</span></span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123; <span class="comment">//返回一个移除监听的方法</span></span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span>=&gt;</span>l!==fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(renderApp); <span class="comment">//通过suscribe订阅派发时需要触发的函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时我们redux中常用的方法已经封装完成！^_^,我们将封装好的逻辑抽离成redux.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = []; <span class="comment">// 放置所有订阅的函数</span></span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span>=&gt;</span>item());<span class="comment">//每次派发后执行订阅的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">fn</span>)=&gt;</span>&#123; <span class="comment">//主要用于订阅事件</span></span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123; <span class="comment">//返回一个移除监听的方法</span></span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span>=&gt;</span>l!==fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-应用redux-js实现counter"><a href="#2-应用redux-js实现counter" class="headerlink" title="2.应用redux+js实现counter"></a>2.应用redux+js实现counter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;container&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;add&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;minus&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;redux.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> MINUS = <span class="string">&#x27;MINUS&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=&#123;number:<span class="number">0</span>&#125;,action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">      <span class="keyword">case</span> ADD:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number + action.amount&#125;;</span><br><span class="line">      <span class="keyword">case</span> MINUS:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number - action.amount&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = store.getState().number</span><br><span class="line">  &#125;</span><br><span class="line">  render();</span><br><span class="line">  store.subscribe(render);</span><br><span class="line">  add.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:ADD,<span class="attr">amount</span>:<span class="number">1</span>&#125;)</span><br><span class="line">  &#125;,<span class="literal">false</span>);</span><br><span class="line">  minus.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:MINUS,<span class="attr">amount</span>:<span class="number">2</span>&#125;)</span><br><span class="line">  &#125;,<span class="literal">false</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>由此我们使用了自己的redux库链接了原生js进行使用。</p>
</blockquote>
<h2 id="3-应用redux-react实现counter"><a href="#3-应用redux-react实现counter" class="headerlink" title="3.应用redux+react实现counter"></a>3.应用redux+react实现counter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM,&#123;render&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;./redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> MINUS = <span class="string">&#x27;MINUS&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=&#123;number:<span class="number">0</span>&#125;,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> ADD:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number + action.amount&#125;;</span><br><span class="line">    <span class="keyword">case</span> MINUS:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    store.subscribe( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:ADD,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:MINUS,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleAddClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleMinusClick&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们将redux数据映射到了组件自己的状态，并且订阅了setState事件。每次状态更新时都会重新刷新组件</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>js 代码片段实现</title>
    <url>./2020/10/29/js-codeSnippet/</url>
    <content><![CDATA[<h2 id="做一个PC端的网页，设计图是1920X1080，要在常见屏上显示正常-，比如：1280X720-1366X768-1440X900-1920X1080。就要使用REM，width、height、margin、padding、left、top都采用了REM"><a href="#做一个PC端的网页，设计图是1920X1080，要在常见屏上显示正常-，比如：1280X720-1366X768-1440X900-1920X1080。就要使用REM，width、height、margin、padding、left、top都采用了REM" class="headerlink" title="做一个PC端的网页，设计图是1920X1080，要在常见屏上显示正常 ，比如：1280X720 1366X768 1440X900 1920X1080。就要使用REM，width、height、margin、padding、left、top都采用了REM"></a>做一个PC端的网页，设计图是1920X1080，要在常见屏上显示正常 ，比如：1280X720 1366X768 1440X900 1920X1080。就要使用REM，width、height、margin、padding、left、top都采用了REM</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tid;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> designSize = <span class="number">1920</span>; <span class="comment">// 设计图尺寸</span></span><br><span class="line">    <span class="keyword">let</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">    <span class="keyword">let</span> wW = html.clientWidth; <span class="comment">// 窗口宽度</span></span><br><span class="line">    <span class="keyword">let</span> rem = (wW * <span class="number">100</span>) / designSize;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontSize = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;resize&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">      tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;pageshow&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">        tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>计算font-size的逻辑是：<br>当设计图是1920时,规定HTML的FONT-SIZE的值是100. 也就是,当浏览器窗口调整到1920PX时,1REM=100PX,如果要设定一个160PX(1920设计图时)的margin-top,那么REM设置值是1.6rem.</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin, hashMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (origin == <span class="literal">undefined</span> || <span class="keyword">typeof</span> origin !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> origin</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(origin)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(origin)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> hashKey = hashMap.get(origin);</span><br><span class="line">    <span class="keyword">if</span> (hashKey) &#123;</span><br><span class="line">        <span class="keyword">return</span> hashKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="keyword">new</span> origin.constructor()</span><br><span class="line">    hashMap.set(origin, target)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> origin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.hasOwnProperty(k)) &#123;</span><br><span class="line">            target[k] = deepClone(origin[k])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="js-原有的-toFixed-函数得到结果并非-想要的-需要自己重新定义"><a href="#js-原有的-toFixed-函数得到结果并非-想要的-需要自己重新定义" class="headerlink" title="js 原有的 toFixed 函数得到结果并非 想要的 需要自己重新定义"></a>js 原有的 toFixed 函数得到结果并非 想要的 需要自己重新定义</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFixed</span>(<span class="params">number, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;number不是数字&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.pow(<span class="number">10</span>, m) * number) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, m);</span><br><span class="line">    result = <span class="built_in">String</span>(result);</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(<span class="string">&quot;.&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">m != <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">            result += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            result += <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).join(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = result.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">1</span>].length &lt; m) &#123;</span><br><span class="line">            arr[<span class="number">1</span>] += <span class="keyword">new</span> <span class="built_in">Array</span>(m - arr[<span class="number">1</span>].length + <span class="number">1</span>).join(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result = arr.join(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind 实现"></a>bind 实现</h2><ul>
<li><p>箭头函数的 this 永远指向它所在的作用域，函数作为构造函数用 new 关键字调用时，不应该改变其 this 指向，因为 new绑定 的优先级高于 显示绑定 和 硬绑定</p>
</li>
<li><p>返回⼀个函数，绑定this，传递预置参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拿到参数，为了传给调用者</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">let</span>  self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> nop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;  <span class="comment">// 构建一个干净的函数，用于保存原函数的原型</span></span><br><span class="line">    <span class="comment">// 绑定的函数</span></span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// this instanceof nop, 判断是否使用 new 来调用 bound</span></span><br><span class="line">      <span class="comment">// 如果是 new 来调用的话，this的指向就是其实例，</span></span><br><span class="line">      <span class="comment">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span></span><br><span class="line">      <span class="keyword">return</span> self.apply(</span><br><span class="line">        <span class="built_in">this</span> <span class="keyword">instanceof</span> nop ? <span class="built_in">this</span> : thisArg,</span><br><span class="line">        args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.prototype) &#123;</span><br><span class="line">    nop.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改绑定函数的原型指向</span></span><br><span class="line">  bound.prototype = <span class="keyword">new</span> nop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="call实现"><a href="#call实现" class="headerlink" title="call实现"></a>call实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this指向调用call的对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用call的若不是函数则报错</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  thisArg = thisArg || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将调用call函数的对象添加到thisArg的属性中</span></span><br><span class="line">  thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 执行该属性</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.fn(...arg);</span><br><span class="line">  <span class="comment">// 删除该属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">  <span class="comment">// 返回函数执行结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply 实现"></a>apply 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.fn(...arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简单的防抖-函数"><a href="#简单的防抖-函数" class="headerlink" title="简单的防抖 函数"></a>简单的防抖 函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">300</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">timer</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,args)</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn();</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>js 代码片段实现</category>
      </categories>
      <tags>
        <tag>js 代码片段实现</tag>
      </tags>
  </entry>
  <entry>
    <title>node</title>
    <url>./2021/05/14/node/</url>
    <content><![CDATA[<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><ul>
<li><a href="https://blog.poetries.top/node-learning-notes/notes/base/01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">node</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>react-hooks</title>
    <url>./2020/10/25/react-hooks/</url>
    <content><![CDATA[<h2 id="认识hooks"><a href="#认识hooks" class="headerlink" title="认识hooks"></a>认识hooks</h2><ul>
<li><p>Hook 是⼀一个特殊的函数，它可以让你“钩⼊入” React 的特性。例例如， useState 是允许你在 React 函数组件中添加 state 的 Hook</p>
</li>
<li><p>如果你在编写函数组件并意识到需要向其添加⼀一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使⽤用 Hook</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">    &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使⽤-Effect-Hook"><a href="#使⽤-Effect-Hook" class="headerlink" title="使⽤ Effect Hook"></a>使⽤ Effect Hook</h2><ul>
<li>Effect Hook 可以让你在函数组件中执⾏行行副作⽤用操作。<br>数据获取，设置订阅以及⼿手动更更改 React 组件中的 DOM 都属于副作⽤用。不不管你知不不知道这些操作，或<br>是“副作⽤用”这个名字，应该都在组件中使⽤用过它们。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 与 componentDidMount 和 componentDidUpdate相似</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 更更新 title</span></span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">&lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 在函数组件主体内（这⾥里里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器器、记录⽇日志以及执<br> ⾏行行其他包含副作⽤用的操作都是不不被允许的，因为这可能会产⽣生莫名其妙的 bug 并破坏 UI 的⼀一致性。<br> 使⽤用  useEffect 完成副作⽤用操作。赋值给  useEffect 的函数会在组件渲染到屏幕之后执⾏行行。你可以<br> 把 effect 看作从 React 的纯函数式世界通往命令式世界的逃⽣生通道。</p>
<h2 id="effect-的条件执⾏"><a href="#effect-的条件执⾏" class="headerlink" title="effect 的条件执⾏"></a>effect 的条件执⾏</h2><p>默认情况下，effect 会在每轮组件渲染完成后执⾏行行。这样的话，⼀一旦 effect 的依赖发⽣生变化，它就会被<br>重新创建。<br>然⽽而，在某些场景下这么做可能会矫枉过正。⽐比如，在上⼀一章节的订阅示例例中，我们不不需要在每次组件<br>更更新时都创建新的订阅，⽽而是仅需要在  source props 改变时重新创建。<br>要实现这⼀一点，可以给  useEffect 传递第⼆二个参数，它是 effect 所依赖的值数组。更更新后的示例例如<br>下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="comment">// 与 componentDidMount 和 componentDidUpdate相似</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 更更新 title</span></span><br><span class="line"> <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line"> &#125;, [count]);</span><br><span class="line"> useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;, []);</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line"> &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line"> &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line"> &lt;p&gt;&#123;date.toLocaleTimeString()&#125;&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，只有当 useEffect第⼆二个参数数组⾥里里的数值 改变后才会重新创建订阅</p>
<h2 id="清除-effect"><a href="#清除-effect" class="headerlink" title="清除 effect"></a>清除 effect</h2><p>组件卸载时需要清除 effect 创建的诸如订阅或计时器器 ID 等资源。要实现这⼀一点， useEffect<br>函数需返回⼀一个清除函数，以防⽌止内存泄漏漏，清除函数会在组件卸载前执⾏行行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h2 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h2><p>自定义 Hook 是⼀一个函数，其名称以 “use” 开头，函数内部可以调⽤用其他的 Hook。<br><code>&lt;p&gt;&#123;useClock().toLocaleTimeString()&#125;&lt;/p&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//⾃自定义hook，命名必须以use开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useClock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;date effect&quot;</span>);</span><br><span class="line">    <span class="comment">//只需要在didMount时候执⾏行行就可以了了</span></span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//清除定时器器，类似willUnmount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hooks-使用规则"><a href="#hooks-使用规则" class="headerlink" title="hooks 使用规则"></a>hooks 使用规则</h2><ul>
<li>只能在函数最外层调⽤用 Hook。不不要在循环、条件判断或者⼦子函数中调⽤用。</li>
<li>只能在 React 的函数组件中调⽤用 Hook。不不要在其他 JavaScript 函数中调⽤用。（还有⼀一个地⽅方可<br>以调⽤用 Hook —— 就是⾃自定义的 Hook 中。）</li>
</ul>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>把“创建”函数和依赖项数组作为参数传⼊入  useMemo ，它仅会在某个依赖项改变时才重新计算memoized 值。这种优化有助于避免在每次渲染时都进⾏行行⾼高开销的计算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseMemoPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> expensive = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;compute&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="comment">//只有count变化，这⾥里里才重新执⾏行行</span></span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;UseMemoPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;expensive:&#123;expensive&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;input value=&#123;value&#125; onChange=&#123;<span class="function"><span class="params">event</span> =&gt;</span> setValue(event.target.value)&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>把内联回调函数及依赖项数组作为参数传⼊入  useCallback ，它将返回该回调函数的 memoized 版本，<br>该回调函数仅在某个依赖项改变时才会更更新。当你把回调函数传递给经过优化的并使⽤用引⽤用相等性去避<br>免⾮非必要渲染（例例如  shouldComponentUpdate ）的⼦子组件时，它将⾮非常有⽤用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback, PureComponent &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseCallbackPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> addClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;h3&gt;UseCallbackPage&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;input value=&#123;value&#125; onChange=&#123;<span class="function"><span class="params">event</span> =&gt;</span> setValue(event.target.value)&#125; /&gt;</span><br><span class="line">  &lt;Child addClick=&#123;addClick&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;child render&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; addClick &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;h3&gt;Child&lt;/h3&gt;</span><br><span class="line">  &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(addClick())&#125;&gt;add&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>useCallback(fn, deps) 相当于  useMemo(() =&gt; fn, deps) 。</code><br>依赖项数组不不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引⽤用的<br>值都应该出现在依赖项数组中。未来编译器器会更更加智能，届时⾃自动创建数组将成为可能</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react-hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>react文档</title>
    <url>./2021/10/08/react%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<ul>
<li><a href="https://github.com/sxfad/react-admin/">基于 Ant Design React 的管理系统架构</a></li>
<li><a href="https://react.jokcy.me/">React 源码解析</a></li>
<li><a href="https://github.com/KieSun/awesome-frontend-source-interpretation">从源码层面，剖析前端主流技术的底层实现原理</a></li>
<li><a href="https://juejin.cn/post/6844904157829136398">React Hooks 使用详解及实际项目中遇到的坑</a></li>
<li><a href="https://github.com/beichensky/Blog/issues/6">React Hooks 常见问题及解决方案</a></li>
<li><a href="https://react.iamkasong.com/">react 技术揭秘</a></li>
<li><a href="https://github.com/puxiao/react-hook-tutorial/blob/master/03%20useState%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.md">React Hook 系列教程，学习和探索Hooks世界</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react文档</tag>
      </tags>
  </entry>
  <entry>
    <title>在线文档</title>
    <url>./2020/10/27/%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p><a href="https://www.bookstack.cn/">书栈网</a> <a href="https://docschina.org/">印记中文</a> <a href="https://www.javascriptc.com/">JS中文网</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN</a> <a href="https://vue3js.cn/">vue3</a> <a href="https://cn.vuejs.org/">vue</a> <a href="https://react.docschina.org/">react</a> <a href="https://angular.cn/">angular</a> <a href="https://www.yuque.com/dashboard/">语雀</a> <a href="https://www.kancloud.cn/jsfront/month/1897005">看云js月报</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247487217&idx=2&sn=85f731a43b93b57230a7919945a7ae0d&chksm=fa2bee18cd5c670e9d0f2546fff7e579c416aa85fb4bf49223277ffb61624f99f6b50805902b&scene=126&sessionid=1606197281&key=b446d8ff764b323102bbb0c113388de17012eba1572ae079f7de09d4953d2d1bf50d1d2090b81c2dfc588fcff11bf70221158523c35e204a1efb7892811bf190ab4421d811a457fdc3900bfed451eb8448891ba49a6aa823bab680777e2c6eafae438fa434c108f7bf67b1397b3f1dca3dd4c3a5b661ebfefd647f8ebb7179cf&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AbqEAQXqtW+qx3SZA80qofI=&pass_ticket=EgQTrjNMllPeNIVkI9qHCXD/LxBZ2Z/8w6sriw+i2SdOdjARLD0NCMZcPJQLNT7e&wx_header=0">编码规范</a></p>
<p><a href="https://kaiwu.lagou.com/xunlianying/index.html?courseId=25#/course">拉钩教育</a><br><a href="https://time.geekbang.org/">极客时间</a><br><a href="https://appf96umjwe7950.h5.xiaoeknow.com/v1/auth?appId=appF96umJwe7950&redirect_url=https://appF96umJwe7950.h5.xiaoeknow.com/homepage/30">珠峰培训</a><br><a href="https://www.kaikeba.com/">开课吧</a></p>
<h2 id="12-在线工具"><a href="#12-在线工具" class="headerlink" title="12.在线工具"></a>12.在线工具</h2><ul>
<li><a href="https://codepen.io/">CodePen  |  前端在线测试和演示工具  国外站点</a></li>
<li><a href="https://caniuse.com/">Can  I  use |  Web前端兼容性列表</a></li>
<li><a href="https://tinypng.com/">TinyPNG  |  PNG/JPG 图片在线压缩工具</a></li>
<li><a href="https://www.umeng.com/">CNZZ |  老牌站点统计工具  5年前国内站长必上网站</a></li>
<li><a href="https://web.dev/measure/">web.dev  |  评测网站性能  基于Lighthouse</a></li>
<li><a href="https://www.shapedivider.app/">Shape Divider  | 定制各种形状SVG的工具</a></li>
<li><a href="https://gtmetrix.com/">GTmetrix  |  网页性能在线分析工具</a></li>
<li><a href="https://carbon.now.sh/">Carbon  |  代码转图片工具</a></li>
<li><a href="https://www.wappalyzer.com/">Wappalyzer  |  检测某个网站的技术栈</a></li>
<li><a href="https://unbug.github.io/codelf">CODEIF | 变量方法起名工具  人工智能加持</a></li>
<li><a href="https://tool.lu/">tool.lu  |  程序员在线工具大全</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>在线文档</category>
      </categories>
      <tags>
        <tag>在线文档</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器调试技巧</title>
    <url>./2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="debug-函数"><a href="#debug-函数" class="headerlink" title="debug 函数"></a>debug 函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug(test)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="DOM-断点"><a href="#DOM-断点" class="headerlink" title="DOM 断点"></a>DOM 断点</h2><p><img src="./2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/dom%E6%96%AD%E7%82%B9.png" alt="12"></p>
<h2 id="鼠标悬浮样式查看"><a href="#鼠标悬浮样式查看" class="headerlink" title="鼠标悬浮样式查看"></a>鼠标悬浮样式查看</h2><p><img src="./2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/hover.png" alt="12"></p>
<h2 id="控制台内置对象-0"><a href="#控制台内置对象-0" class="headerlink" title="控制台内置对象 $0 $$ $"></a>控制台内置对象 $0 $$ $</h2><ul>
<li><img src="./2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/$0.png" alt="12"></li>
<li>$$ == document.querySelectorAll</li>
<li>$ == document.querySelector</li>
</ul>
<h2 id="常忽略的js操作符"><a href="#常忽略的js操作符" class="headerlink" title="常忽略的js操作符 ?? ??= ?."></a>常忽略的js操作符 <code>?? ??= ?.</code></h2><ul>
<li>??运算符被称为nullish coalescing运算符(零合并操作符)。如果第一个参数不是null/undefined，这个运算符将返回第一个参数，否则，它将返回第二个参数</li>
<li>??=又被称为逻辑空值赋值运算符<code>var x= null; var y = 5; console.log(x ??= y) // 5</code></li>
<li>?. 允许开发人员读取深嵌在对象链中的属性值，而不必显式验证每个引用。当一个引用为空时，表达式停止计算并返回一个未定义的值 <code>travelPlans.tuesday?.location</code></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>浏览器调试技巧</category>
      </categories>
      <tags>
        <tag>浏览器调试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>react 路由的使用</title>
    <url>./2020/10/22/React%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>本章我们来介绍react中路由的使用,现在使用的路由是React-Router-4版本,我们需要下载的包叫react-router-dom</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>这里我们下载好后需要他内部的路由容器组件,主要包含BrowserRouter,HashRouter,MemoryRouter</p>
</blockquote>
<h3 id="容器组件的区别"><a href="#容器组件的区别" class="headerlink" title="容器组件的区别"></a>容器组件的区别</h3><ul>
<li>BrowserRouter: 浏览器自带的H5 API,restful风格,需要配合后台；</li>
<li>HashRouter: 使用hash方式进行路由,路径后均有#；</li>
<li>MemoryRouter: 在内存中管理history，地址栏不会变化。在reactNative中使用。</li>
</ul>
<blockquote>
<p>在开发时我们一般使用HashRouter,上线后我们改用BrowserRouter</p>
</blockquote>
<h3 id="跑通基本路由"><a href="#跑通基本路由" class="headerlink" title="跑通基本路由"></a>跑通基本路由</h3><p>我们来声明三个组件Home,User,Profile希望访问不同的路径可以实现显示不同的组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter,Route&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> Home = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> Profile = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Profile<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> User = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>User<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">ReactDOM.render(&lt;HashRouter&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/home&quot;</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/profile&quot;</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;User&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/HashRouter&gt;,<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们使用了HashRouter,代码一目了然,这里用到了Route组件,Route组件上有path和component属性,对应的path会显示对应的component,这里还需注意HashRouter必须只能包含一个根元素,所以我们在所有的Route外层包了一个div标签</p>
</blockquote>
<h3 id="路由的匹配"><a href="#路由的匹配" class="headerlink" title="路由的匹配"></a>路由的匹配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们稍作了下更改当访问/profile/user时你会发现/profile路由也会命中。所以说明只要路径开头匹配成功既会显示对应的组件,假如你希望不管访问任何路径时都能显示某一个组件你可以将path写成’/‘</p>
</blockquote>
<h3 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h3><p>我们先来引入bootstrap,将刚才的代码逻辑进行拆分,增加导航条点击不同的导航显示不同的组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123;HashRouter,Route&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">import &#39;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import Home from &#39;.&#x2F;components&#x2F;Home&#39;;</span><br><span class="line">import Profile from &#39;.&#x2F;components&#x2F;Profile&#39;;</span><br><span class="line">import User from &#39;.&#x2F;components&#x2F;User&#39;;</span><br><span class="line">ReactDOM.render(&lt;HashRouter&gt;</span><br><span class="line">    &lt;App&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;App&gt;</span><br><span class="line">&lt;&#x2F;HashRouter&gt;,document.querySelector(&#39;#root&#39;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们增加了App组件,为什么这样做呢?原因是我们并不希望将所有的逻辑都写在index中,这并不方便我们的管理,还记得children属性吗？我们可以直接在App中通过children的方式引入</p>
</blockquote>
<h3 id="增加导航"><a href="#增加导航" class="headerlink" title="增加导航"></a>增加导航</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Link&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">export default class App extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;navbar-inverse navbar&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;container-fluid&quot;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&quot;navbar-header&quot;&gt;</span><br><span class="line">                            &lt;div className&#x3D;&quot;navbar-brand&quot;&gt;</span><br><span class="line">                                用户管理系统</span><br><span class="line">                            &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;ul className&#x3D;&quot;navbar-nav nav&quot;&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;home&#39;&#125;&gt;首页&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;user&#39;&#125;&gt;用户管理&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;profile&#39;&#125;&gt;个人中心&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                        &lt;&#x2F;ul&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;row&quot;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&quot;col-md-12&quot;&gt;</span><br><span class="line">                            &#123;this.props.children&#125;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用Link组件它可以替代我们自己写的a标签,因为后面我们可能会用到browserHistory，跳转可能需要用到H5的api进行跳转,Link组件是react路由中提供的声明式组件,可以帮我们区分路由的模式来实现路由的跳转。</p>
</blockquote>
<h3 id="页面级组件"><a href="#页面级组件" class="headerlink" title="页面级组件"></a>页面级组件</h3><p>这里我们先将对应的组件代码代码贴出来,后面我们来完善对用的逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Home.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class Home extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Home&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Profile.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class Profile extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Profile&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; User.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class User extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;User&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h3><p>刚才我们实现了一级导航,但是一般情况下管理系统都会拥有二级导航,比如说我们希望用户管理中包含用户列表和添加用户,这两个菜单应该属于用户列表下的子导航,我们先来看下效果</p>
<h4 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h4><p>二级导航就是在某个一级路由中继续嵌套路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">import UserList from &#39;.&#x2F;UserList&#39;</span><br><span class="line">import UserAdd from &#39;.&#x2F;UserAdd&#39;</span><br><span class="line">export default class User extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className&#x3D;&quot;row&quot;&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;col-md-2&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;nav nav-stacked&quot;&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to&#x3D;&#39;&#x2F;user&#x2F;list&#39;&gt;用户列表&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to&#x3D;&#39;&#x2F;user&#x2F;add&#39;&gt;增加用户&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;col-md-10&quot;&gt;</span><br><span class="line">                    &lt;Route path&#x3D;&quot;&#x2F;user&#x2F;list&quot; component&#x3D;&#123;UserList&#125;&#x2F;&gt;</span><br><span class="line">                    &lt;Route path&#x3D;&quot;&#x2F;user&#x2F;add&quot; component&#x3D;&#123;UserAdd&#125;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里并没有什么需要注意的新用法,只是路径要特殊处理一下因为是二级路由,要保证一级路由也同时显示所以开头要和一级路由路径相同。如果多次点击相同路由时会触发<code>Hash history cannot PUSH the same path;</code>这样的一个警告,这个是无法去除的但是改成BrowserHistory就不会触发此警告了。所有不用担心.</p>
</blockquote>
<h4 id="UserList和Add组件"><a href="#UserList和Add组件" class="headerlink" title="UserList和Add组件"></a>UserList和Add组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; UserList.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserList extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;UserList&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; UserAdd.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserAdd extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;UserAdd&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们先不写任何逻辑，先将具体的功能实现出来。这样我们就实现了二级路。</p>
</blockquote>
<h3 id="路由跳转和路径参数"><a href="#路由跳转和路径参数" class="headerlink" title="路由跳转和路径参数"></a>路由跳转和路径参数</h3><p>本节我们完善一下内部的逻辑,进入到添加列表页可以实现用户的添加并且可以跳转到列表页面渲染出添加的用户列表,页面间的通信我们采用localStorage。并且点击某个用户可以进入到用户详情页。</p>
<h4 id="实现添加用户"><a href="#实现添加用户" class="headerlink" title="实现添加用户"></a>实现添加用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserAdd extends React.Component&#123;</span><br><span class="line">    handleSubmit &#x3D; (e) &#x3D;&gt;&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        let localStr &#x3D; localStorage.getItem(&#39;lists&#39;);</span><br><span class="line">        let list &#x3D; JSON.parse(localStr)|| [];</span><br><span class="line">        list.push(&#123;id:Math.random(),name:this.name.value&#125;);</span><br><span class="line">        localStorage.setItem(&#39;lists&#39;,JSON.stringify(list));</span><br><span class="line">        this.props.history.push(&#39;&#x2F;user&#x2F;list&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;label htmlFor&#x3D;&quot;name&quot; className&#x3D;&quot;control-label&quot;&gt;</span><br><span class="line">                            用户名:</span><br><span class="line">                        &lt;&#x2F;label&gt;</span><br><span class="line">                        &lt;input type&#x3D;&quot;text&quot; className&#x3D;&quot;form-control&quot; ref&#x3D;&#123;x&#x3D;&gt;this.name &#x3D; x&#125;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;button className&#x3D;&quot;btn btn-primary&quot;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;form&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们在props中使用了history的API,所有通过路由渲染的组件都拥有一些路由的属性后面我们会一一介绍到。这里我们采用编程式的方式跳转了路径。</p>
</blockquote>
<h4 id="列表页展示"><a href="#列表页展示" class="headerlink" title="列表页展示"></a>列表页展示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default class UserList extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state &#x3D; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        let userList &#x3D; JSON.parse(localStorage.getItem(&#39;lists&#39;));</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            userList</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ul className&#x3D;&quot;list-group&quot;&gt;</span><br><span class="line">                    &#123;this.state.userList.map((user,index)&#x3D;&gt;(</span><br><span class="line">                        &lt;li className&#x3D;&quot;list-group-item&quot; key&#x3D;&#123;index&#125;&gt;</span><br><span class="line">                            &lt;Link to&#x3D;&#123;&quot;&#x2F;user&#x2F;detail&#x2F;&quot;+user.id&#125;&gt;&#123;user.name&#125;&lt;&#x2F;Link&gt;</span><br><span class="line">                        &lt;&#x2F;li&gt;</span><br><span class="line">                    ))&#125;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的逻辑比较简单,我们又添加了一个detail路径同样也是一个二级路由，点击用户名可以显示具体的用户id和用户名。</p>
</blockquote>
<h4 id="引入UserDetail组件"><a href="#引入UserDetail组件" class="headerlink" title="引入UserDetail组件"></a>引入UserDetail组件</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ import UserDetail from &#x27;./UserDetail&#x27;;</span></span><br><span class="line">  &lt;Route path=&quot;/user/list&quot; component=&#123;UserList&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/user/add&quot; component=&#123;UserAdd&#125;/&gt;</span><br><span class="line"><span class="addition">+ &lt;Route path=&quot;/user/detail/:id&quot; component=&#123;UserDetail&#125;/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们采用了模糊匹配的方式,这就是我们常说的路径参数。也就是说id可以代表任何值，我们可以在详情页中通过this.props.match.params.id获取到真实传入的id</p>
</blockquote>
<h4 id="UserDetail详情页"><a href="#UserDetail详情页" class="headerlink" title="UserDetail详情页"></a>UserDetail详情页</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserDetail extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123;id &#125; &#x3D; this.props.match.params;</span><br><span class="line">        let &#123;name&#125; &#x3D; JSON.parse(localStorage.getItem(&#39;lists&#39;)).find(item&#x3D;&gt;item.id &#x3D;&#x3D; id);</span><br><span class="line">        return (</span><br><span class="line">            &lt;table className&#x3D;&quot;table table-bordered&quot;&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;th&gt;id号&lt;&#x2F;th&gt;</span><br><span class="line">                        &lt;th&gt;标题&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;&#123;id&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;name&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;tbody&gt;</span><br><span class="line">            &lt;&#x2F;table&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要注意通过params取出的结果都是字符串类型,所有匹配到的参数都会放在match.params的属性上。</p>
</blockquote>
<h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>有的时候我们希望对路由匹配有些限制,比如说严格对某个路径进行匹配,或者匹配到某个路径时就不在匹配</p>
<h4 id="新增路由匹配"><a href="#新增路由匹配" class="headerlink" title="新增路由匹配"></a>新增路由匹配</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line"><span class="addition">+       &lt;Route path=&quot;/&quot; render=&#123;()=&gt;&lt;h1&gt;首页&lt;/h1&gt;&#125;/&gt;</span></span><br><span class="line"><span class="addition">+       &lt;Route path=&quot;/:name&quot; render=&#123;()=&gt;&lt;h1&gt;zfpx&lt;/h1&gt;&#125;/&gt;</span></span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;/App&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在此我们会发现当访问/home时以上<code>首页</code>和<code>zfpx</code>和<code>home组件</code>都会访问到,而我们只希望在访问/时才会显示首页,我们可以在某个Route上增加exact属性</p>
</blockquote>
<h4 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;&quot; exact render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你会发现这样就实现啦~,只会当访问/时才可以匹配到。</p>
</blockquote>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p>但是现在访问/home时我们依然有两个组件会被匹配到，我们希望匹配到一个后就停止匹配，不在继续匹配下一个路由，我们可以使用Switch组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;HashRouter,Route,Switch&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;&quot; exact render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;:name&quot; render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Switch&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在访问/home你会发现Home组件永远都不会显示出来啦！</p>
</blockquote>
<h3 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h3><p>我们想对一些路由进行屏蔽,例如登录后才能访问,这里我们在本地存一个变量来表示是否登录,增加一个登录路由，点击登录按钮将本地变量改为登录成功状态,即可以访问用户列表页面</p>
<h3 id="受保护路由"><a href="#受保护路由" class="headerlink" title="受保护路由"></a>受保护路由</h3><p>我们匹配到/user路由时要根据状态判断是否有权限，如果没权限需要跳转到登录页面，主要靠的是高阶组件的思想来实现:</p>
<h4 id="Protected组件"><a href="#Protected组件" class="headerlink" title="Protected组件"></a>Protected组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Redirect&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default (&#123;component:Component,...others&#125;)&#x3D;&gt;&#123;</span><br><span class="line">   return &lt;Route &#123;...others&#125; render&#x3D;&#123;(props)&#x3D;&gt;&#123;</span><br><span class="line">       return localStorage.getItem(&#39;loginSystem&#39;)?&lt;Component &#123;...props&#125;&#x2F;&gt;:&lt;Redirect to&#x3D;&#123;&#123;</span><br><span class="line">           pathname:&#39;&#x2F;login&#39;,</span><br><span class="line">           from:props.match.url</span><br><span class="line">       &#125;&#125;&#x2F;&gt;</span><br><span class="line">   &#125;&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Redirect组件是用来重定向的，我们新增from属性来记录当前匹配的url,为了保证登录后可以在跳回到当前匹配的路径</p>
</blockquote>
<h4 id="新增Login组件"><a href="#新增Login组件" class="headerlink" title="新增Login组件"></a>新增Login组件</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line"><span class="deletion">-   &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span></span><br><span class="line"><span class="addition">+   &lt;PrivateRoute path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span></span><br><span class="line">    &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line"><span class="addition">+   &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Login.js</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">export default class Login extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button className=&quot;btn btn-primary&quot; onClick=&#123;()=&gt;&#123;</span><br><span class="line">                    window.localStorage.setItem(&#x27;loginSystem&#x27;,true);</span><br><span class="line">                   this.props.history.push(this.props.location.from)</span><br><span class="line">                &#125;&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们发现默认点击profile会默认跳转到login组件中，点击登录可以再次跳回profile。这样我们就实现了受保护的路由。</p>
</blockquote>
<h3 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h3><p>我们想给点击后的菜单增加激活样式，同样依然采用高阶组件的方式进行包装</p>
<h4 id="实现MenuLink组件"><a href="#实现MenuLink组件" class="headerlink" title="实现MenuLink组件"></a>实现MenuLink组件</h4><p>此组件是用来替换掉原有的Link组件，并且在内部进行判断是否增加激活状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default (&#123;to,label&#125;)&#x3D;&gt;&#123;</span><br><span class="line">    return &lt;Route children&#x3D;&#123;(props)&#x3D;&gt;&#123;</span><br><span class="line">        return &lt;li className&#x3D;&#123;props.match?&#39;active&#39;:&#39;&#39;&#125;&gt;&lt;Link to&#x3D;&#123;to&#125;&gt;&#123;label&#125;&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &#125;&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有个children属性和以前render不同，children无论是否路由匹配到都会执行此函数。而render只要在匹配到后才会执行</p>
</blockquote>
<h3 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h3><p>我们希望在添加页的输入框中输入内容后点击其他路由时先询问一下是否需要跳转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;show:false&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Prompt when&#x3D;&#123;this.state.show&#125; message&#x3D;&#123;location &#x3D;&gt; (</span><br><span class="line">        &#96;Are you sure you want to go to $&#123;location.pathname&#125;?&#96;</span><br><span class="line">    )&#125;&#x2F;&gt;</span><br><span class="line">    &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">            &lt;label htmlFor&#x3D;&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; className&#x3D;&quot;form-control&quot; ref&#x3D;&#123;(x)&#x3D;&gt;this.x&#x3D;x&#125;</span><br><span class="line">               onChange&#x3D;&#123;(e)&#x3D;&gt;&#123;</span><br><span class="line">                   if(e.target.value.length&gt;0)&#123;</span><br><span class="line">                       this.setState(&#123;show:true&#125;)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">            &lt;button className&#x3D;&quot;btn btn-primary&quot; &gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>监听输入框中的内容,当有内容时将状态show变为true,当需要跳转路由时Prompt的组件when属性为true就会提示对应的message,当然我们点击添加时不需要弹出,所以先将状态改为false在进行跳转即可。</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">handleSubmit=(e)=&gt;&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    let list = JSON.parse(localStorage.getItem(&#x27;lists&#x27;))||[];</span><br><span class="line">    list.push(&#123;id:Math.random(),name:this.x.value&#125;);</span><br><span class="line">    localStorage.setItem(&#x27;lists&#x27;,JSON.stringify(list));</span><br><span class="line"><span class="addition">+   this.setState(&#123;show:false&#125;,()=&gt;&#123;</span></span><br><span class="line">        this.props.history.push(&#x27;/profile/list&#x27;)</span><br><span class="line"><span class="addition">+   &#125;)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要等待状态改变后在执行跳转，因为setState是异步的所以要将跳转逻辑放的回调函数中。</p>
</blockquote>
<h2 id="NotFound页面"><a href="#NotFound页面" class="headerlink" title="NotFound页面"></a>NotFound页面</h2><p>我们需要当路由都匹配不到时显示一个404页面,增加一个404组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class NotFound extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;NotFound&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新增404路由"><a href="#新增404路由" class="headerlink" title="新增404路由"></a>新增404路由</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;PrivateRoute path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span><br><span class="line"><span class="addition">+       &lt;Route component=&#123;NotFound&#125;/&gt;</span></span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们使用switch组件当全部匹配不到时会默认渲染404路由,这样我们就实现了404页面</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>react 基础</title>
    <url>./2020/10/21/React%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React?"></a>什么是React?</h2><ul>
<li>React 是一个用于构建用户界面的JavaScript库</li>
<li>核心专注于视图,目的实现组件化开发</li>
</ul>
<h2 id="组件化的概念"><a href="#组件化的概念" class="headerlink" title="组件化的概念"></a>组件化的概念</h2><p>我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用</p>
<ul>
<li>可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部</li>
<li>可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中</li>
<li>可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</li>
</ul>
<p><em><a href="https://pan.baidu.com/s/1hsivfN2">https://pan.baidu.com/s/1hsivfN2</a></em></p>
<h2 id="跑通react开发环境"><a href="#跑通react开发环境" class="headerlink" title="跑通react开发环境"></a>跑通react开发环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install create-react-app -g</span><br><span class="line">create-react-app &lt;project-name&gt;</span><br><span class="line">cd &lt;project-name&gt; &amp;&amp; npm start</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>默认会自动安装React,react由两部分组成,分别是:</p>
</blockquote>
<ul>
<li>react.js 是 React 的核心库</li>
<li>react-dom.js 是提供与DOM相关的功能,会在window下增加ReactDOM属性,内部比较重要的方法是render,将react元素或者react组件插入到页面中。</li>
</ul>
<h2 id="简介JSX"><a href="#简介JSX" class="headerlink" title="简介JSX"></a>简介JSX</h2><ul>
<li>是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。</li>
</ul>
<blockquote>
<p>需要注意的是JSX并不是html,在JSX中属性不能包含关键字，像class需要写成className,for需要写成htmlFor,并且属性名需要采用驼峰命名法！</p>
</blockquote>
<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p>JSX其实只是一种语法糖,最终会通过<a href="https://babeljs.io/repl/">babel</a>转译成createElement语法,以下代码等价</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(&lt;div&gt;姜,&lt;span&gt;帅哥&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;);</span><br><span class="line">ReactDOM.render(React.createElement(&quot;div&quot;,null,&quot;姜,&quot;,React.createElement(&quot;span&quot;,null,&quot;帅哥&quot;)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们一般使用React.createElement来创建一个虚拟dom元素。</p>
</blockquote>
<h2 id="react元素-JSX元素"><a href="#react元素-JSX元素" class="headerlink" title="react元素/JSX元素"></a>react元素/JSX元素</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span>(<span class="params">type,props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> React = &#123;</span><br><span class="line">    <span class="function"><span class="title">createElement</span>(<span class="params">type,props=&#123;&#125;,...childrens</span>)</span>&#123;</span><br><span class="line">        childrens.length===<span class="number">1</span>?childrens = childrens[<span class="number">0</span>]:<span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type,&#123;...props,<span class="attr">children</span>:childrens&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReactElement就是虚拟dom的概念，具有一个type属性代表当前的节点类型，还有节点的属性props</p>
</blockquote>
<h2 id="模拟render实现"><a href="#模拟render实现" class="headerlink" title="模拟render实现"></a>模拟render实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> render = <span class="function">(<span class="params">eleObj,container</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 先取出第一层 进行创建真实dom</span></span><br><span class="line">    <span class="keyword">let</span> &#123;type,props&#125; = eleObj;</span><br><span class="line">    <span class="keyword">let</span> elementNode = <span class="built_in">document</span>.createElement(type); <span class="comment">// 创建第一个元素</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> attr <span class="keyword">in</span> props</span>)</span>&#123; <span class="comment">// 循环所有属性</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">attr === <span class="string">&#x27;children&#x27;</span></span>)</span>&#123; <span class="comment">// 如果是children表示有嵌套关系</span></span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> props[attr] == <span class="string">&#x27;object&#x27;</span></span>)</span>&#123; <span class="comment">// 看是否是只有一个文本节点</span></span><br><span class="line">                props[attr].forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123; <span class="comment">// 多个的话循环判断 如果是对象再次调用render方法</span></span><br><span class="line">                    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> item === <span class="string">&#x27;object&#x27;</span></span>)</span>&#123;</span><br><span class="line">                        render(item,elementNode)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123; <span class="comment">//是文本节点 直接创建即可</span></span><br><span class="line">                        elementNode.appendChild(<span class="built_in">document</span>.createTextNode(item));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 只有一个文本节点直接创建即可</span></span><br><span class="line">                elementNode.appendChild(<span class="built_in">document</span>.createTextNode(props[attr]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">attr === <span class="string">&#x27;className&#x27;</span></span>)</span>&#123; <span class="comment">// 是不是class属性 class 属性特殊处理</span></span><br><span class="line">            elementNode.setAttribute(<span class="string">&#x27;class&#x27;</span>,props[attr]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            elementNode.setAttribute(attr,props[attr]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    container.appendChild(elementNode)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JSX表达式的用法"><a href="#JSX表达式的用法" class="headerlink" title="JSX表达式的用法"></a>JSX表达式的用法</h2><ul>
<li><ol>
<li>可以放JS的执行结果</li>
</ol>
</li>
<li><ol start="2">
<li>如果换行需要用()包裹jsx代码</li>
</ol>
</li>
<li><ol start="3">
<li>可以把JSX元素当作函数的返回值</li>
</ol>
</li>
<li><ol start="4">
<li>&lt;{来判断是表达式还是js</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toResult</span>(<span class="params">&#123;name,age&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>今年&#123;name&#125;,&#123;age&#125;岁了!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrs =  [&#123;<span class="attr">name</span>:<span class="string">&#x27;zfpx&#x27;</span>,<span class="attr">age</span>:<span class="number">8</span>&#125;,,&#123;<span class="attr">name</span>:<span class="string">&#x27;姜文&#x27;</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;];</span><br><span class="line">ReactDOM.render(&lt;div&gt;</span><br><span class="line">    &#123;arrs.map((<span class="function">(<span class="params">item,index</span>)=&gt;</span>(</span><br><span class="line">        <span class="keyword">typeof</span> item===<span class="string">&#x27;object&#x27;</span>?<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;toResult(item)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>:<span class="literal">null</span></span><br><span class="line">    )))&#125;</span><br><span class="line">&lt;/div&gt;,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>null也是合法元素,循环时需要带key属性</p>
</blockquote>
<h2 id="JSX属性"><a href="#JSX属性" class="headerlink" title="JSX属性"></a>JSX属性</h2><ul>
<li>在JSX中分为普通属性和特殊属性，像class要写成className,for要写成htmlFor</li>
<li>style要采用对象的方式</li>
<li>dangerouslyInnerHTML插入html</li>
</ul>
<h2 id="组件的特点声明方式"><a href="#组件的特点声明方式" class="headerlink" title="组件的特点声明方式"></a>组件的特点声明方式</h2><p>react元素是是组件组成的基本单位</p>
<ul>
<li>首字母必须大写,目的是为了和JSX元素进行区分</li>
<li>组件定义后可以像JSX元素一样进行使用</li>
<li>每个组件必须返回唯一的顶级JSX元素</li>
<li>可以通过render方法将组件渲染成真实DOM</li>
</ul>
<h2 id="组件的两种定义方式"><a href="#组件的两种定义方式" class="headerlink" title="组件的两种定义方式"></a>组件的两种定义方式</h2><p>react怎么区分是组件还是jsx元素？组件名需要开头大写，react组件当作jsx来进行使用</p>
<ul>
<li>第一种方式是函数声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Build</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125; &#123;props.age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">render(&lt;div&gt;</span><br><span class="line">    &lt;Build name=&#123;school1.name&#125; age=&#123;school1.age&#125;/&gt;</span><br><span class="line">    &lt;Build &#123;...school2&#125; /&gt;</span><br><span class="line">&lt;/div&gt;,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方式是类声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;name,age&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name&#125; &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类声明有状态，this，和声明周期</p>
</blockquote>
<h2 id="组件中属性和状态的区别"><a href="#组件中属性和状态的区别" class="headerlink" title="组件中属性和状态的区别"></a>组件中属性和状态的区别</h2><ul>
<li>组件的数据来源有两个地方<ul>
<li>props 外界传递过来的(默认属性，属性校验)</li>
<li>state 状态是自己的,改变状态唯一的方式就是setState</li>
</ul>
</li>
</ul>
<blockquote>
<p>属性和状态的变化都会影响视图更新</p>
</blockquote>
<h2 id="setState-使用"><a href="#setState-使用" class="headerlink" title="setState 使用"></a>setState 使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setState(partialState, callback)</span><br><span class="line"><span class="number">1.</span> partialState : object|<span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">⽤于产⽣与当前<span class="title">state</span>合并的⼦集。</span></span><br><span class="line"><span class="function">2. <span class="title">callback</span> : <span class="function"><span class="keyword">function</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">state</span>更新之后被调⽤。</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SetStatePage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>(props);</span><br><span class="line"> <span class="built_in">this</span>.state = &#123;</span><br><span class="line"> counter: <span class="number">0</span></span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.setState(&#123;</span><br><span class="line"> counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line"> &#125;;</span><br><span class="line"> setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; counter &#125; = <span class="built_in">this</span>.state;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h3&gt;SetStatePage&lt;/h3&gt;</span><br><span class="line"> &lt;button onClick=&#123;<span class="built_in">this</span>.setCounter&#125;&gt;&#123;counter&#125;&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>setState只有在合成事件和⽣命周期函数中是异步的，在原⽣事件和setTimeout中都是同步<br>的，这⾥的异步其实是批量更新。<br>要获取到最新状态值有以下⽅式</p>
<ul>
<li><p>在回调中获取状态值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(</span><br><span class="line">  &#123;</span><br><span class="line">  counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line">  &#125;,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line">  &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使⽤定时器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setCounter();</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>原⽣事件中修改状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.changeValue, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>传入对象 setState 的更新会被合并 执行最后一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入函数实现链式更新state</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">counter</span>: state.counter + v &#125;));</span><br><span class="line">&#125;;</span><br><span class="line">setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><ul>
<li>给元素绑定事件，事件绑定方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123; <span class="comment">//组件渲染完成，当渲染后会自动触发此函数</span></span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 箭头函数 否则this 指向的是window</span></span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;)</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123; <span class="comment">//组件将要卸载，当组件移除时会调用</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer); <span class="comment">//一般在这个方法中 清除定时器和绑定的事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    destroy=<span class="function">()=&gt;</span>&#123; <span class="comment">//es7 箭头函数</span></span><br><span class="line">        <span class="comment">// 删除某个组件</span></span><br><span class="line">        ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 给react元素绑定事件默认this是undefined,bind方式 在就是箭头函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.destroy&#125;</span>&gt;</span>&#123;this.state.date&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行顺序 constructor -&gt; render -&gt; componentDidMount -&gt; setState-&gt; render - onClick-&gt; unmountComponentAtNode -&gt; componentWillUnmount -&gt; clearInterval</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>给jsx元素绑定事件要注意事件中的this指向，事件名采用 on+”开头大写事件名”的方式</p>
</blockquote>
<h2 id="属性校验-默认属性"><a href="#属性校验-默认属性" class="headerlink" title="属性校验,默认属性"></a>属性校验,默认属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>; <span class="comment">//引入属性校验的模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123; <span class="comment">// 类上的属性就叫静态属性</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123; <span class="comment">// 校验属性的类型和是否必填</span></span><br><span class="line">        age:PropTypes.number.isRequired, <span class="comment">// 支持的类型可以参考prop-types的readme文件</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123; <span class="comment">// 先默认调用defaultProps</span></span><br><span class="line">        name:<span class="string">&#x27;珠峰&#x27;</span>,</span><br><span class="line">        age:<span class="number">1</span></span><br><span class="line">    &#125;; <span class="comment">// 默认属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123; <span class="comment">//如果想在构造函数中拿到属性需要通过参数的方式</span></span><br><span class="line">         <span class="comment">//不能在组件中更改属性 不能修改属性*</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.name&#125; &#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>propTypes和defaultProps名字不能更改，这是react规定好的名称</p>
</blockquote>
<h2 id="状态的使用"><a href="#状态的使用" class="headerlink" title="状态的使用"></a>状态的使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    handleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// setState方法会进行合并 setState有两种写法 一种是对象一种是函数</span></span><br><span class="line">        <span class="comment">/*this.setState(&#123;count:this.state.count+1&#125;);</span></span><br><span class="line"><span class="comment">          this.setState(&#123;count:this.state.count+1&#125;);*/</span></span><br><span class="line">        <span class="comment">//this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;)); //如果返回的就是一个对象可以用小括号包裹</span></span><br><span class="line">        <span class="comment">//this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;));</span></span><br><span class="line">        <span class="comment">// 下一个状态是依赖于上一个状态时需要写成函数的方式</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;); <span class="comment">// 这个写法等同于 this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;));</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果设置多个状态setState会合并，如果下一个状态依赖于上一个状态，需要写成函数的方式</p>
</blockquote>
<h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><p>复合组件就是将多个组件进行组合，结构非常复杂时可以把组件分离开</p>
<h3 id="不具名"><a href="#不具名" class="headerlink" title="不具名"></a>不具名</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> TopBar <span class="keyword">from</span> <span class="string">&quot;../components/TopBar&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> BottomBar <span class="keyword">from</span> <span class="string">&quot;../components/BottomBar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title = <span class="string">&quot;商城&quot;</span> &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="built_in">document</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children, showTopBar, showBottomBar &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;children&quot;</span>, children);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;showTopBar &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">TopBar</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;children.content&#125;</span><br><span class="line">        &#123;children.txt&#125;</span><br><span class="line">        &lt;button onClick=&#123;children.btnClick&#125;&gt;button&lt;/button&gt;</span><br><span class="line">        &#123;showBottomBar &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">BottomBar</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&quot;./Layout&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout showTopBar=&#123;<span class="literal">true</span>&#125; showBottomBar=&#123;<span class="literal">true</span>&#125; title=<span class="string">&quot;⽤用户中⼼心&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;UserPage&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/Layout&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="具名（传个对象进去）"><a href="#具名（传个对象进去）" class="headerlink" title="具名（传个对象进去）"></a>具名（传个对象进去）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&quot;./Layout&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout showTopBar=&#123;<span class="literal">false</span>&#125; showBottomBar=&#123;<span class="literal">true</span>&#125; title=<span class="string">&quot;商城⾸首⻚页&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;</span><br><span class="line">          content: (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;h3&gt;HomePage&lt;/h3&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          ),</span><br><span class="line">          txt: <span class="string">&quot;这是个⽂文本&quot;</span>,</span><br><span class="line">          btnClick: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;btnClick&quot;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;/Layout&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panel</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;header,body&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;panel-default panel&quot;</span>&gt;</span><br><span class="line">                    &lt;Header head=&#123;header&#125;&gt;&lt;/Header&gt;</span><br><span class="line">                    &lt;Body b=&#123;body&#125;/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// react种需要将属性一层层向下传递 单向数据流</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span>&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>&#123;this.props.head&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">header</span>:<span class="string">&#x27;我非常帅&#x27;</span>,<span class="attr">body</span>:<span class="string">&#x27;长的帅&#x27;</span>&#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Panel</span> &#123;<span class="attr">...data</span>&#125;/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<h3 id="子父组件的通信"><a href="#子父组件的通信" class="headerlink" title="子父组件的通信"></a>子父组件的通信</h3><p>通过父亲传递给儿子一个函数，儿子调用父亲的函数将值传递给父亲,父亲更新值，刷新视图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panel</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">color</span>:<span class="string">&#x27;primary&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    changeColor=<span class="function">(<span class="params">color</span>)=&gt;</span>&#123; <span class="comment">//到时候儿子传递一个颜色</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;color&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div className=&#123;<span class="string">&quot;panel-&quot;</span>+<span class="built_in">this</span>.state.color+<span class="string">&quot; panel&quot;</span>&#125;&gt;</span><br><span class="line">                    &lt;Header head=&#123;<span class="built_in">this</span>.props.header&#125;</span><br><span class="line">                            change=&#123;<span class="built_in">this</span>.changeColor&#125;</span><br><span class="line">                    &gt;&lt;/Header&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    handleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props.change(<span class="string">&#x27;danger&#x27;</span>); <span class="comment">//调用父亲的方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;panel-heading&quot;</span>&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.head&#125; &lt;button className=<span class="string">&quot;btn btn-danger&quot;</span> onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;改颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h2><ul>
<li>受状态控制的组件，必须要有onChange方法，否则不能使用</li>
<li>受控组件可以赋予默认值（官方推荐使用 受控组件）</li>
</ul>
<h3 id="实现双向数据绑定"><a href="#实现双向数据绑定" class="headerlink" title="实现双向数据绑定"></a>实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">val</span>:<span class="string">&#x27;100&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123; <span class="comment">//e是事件源</span></span><br><span class="line">        <span class="keyword">let</span> val = e.target.value;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;val&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;<span class="built_in">this</span>.state.val&#125; onChange=&#123;<span class="built_in">this</span>.handleChange&#125;/&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.val&#125;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key表示的就是当前状态改的是哪一个</span></span><br><span class="line">    <span class="comment">// e表示的是事件源</span></span><br><span class="line">    <span class="function"><span class="title">handleChange</span>(<span class="params">key,e</span>)</span>&#123; <span class="comment">//处理多个输入框的值映射到状态的方法</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            [key]:<span class="built_in">parseInt</span>(e.target.value) || <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> value=&#123;<span class="built_in">this</span>.state.a&#125; onChange=&#123;<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">this</span>.handleChange(<span class="string">&#x27;a&#x27;</span>,e)&#125;&#125;/&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> value=&#123;<span class="built_in">this</span>.state.b&#125; onChange=&#123;<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">this</span>.handleChange(<span class="string">&#x27;b&#x27;</span>,e)&#125;&#125;/&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.a+<span class="built_in">this</span>.state.b&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state =  &#123;<span class="attr">result</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过ref设置的属性 可以通过this.refs获取到对应的dom元素</span></span><br><span class="line">    handleChange = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="built_in">this</span>.refs.a.value + <span class="built_in">this</span>.b.value;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;result&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div onChange=&#123;<span class="built_in">this</span>.handleChange&#125;&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> ref=<span class="string">&quot;a&quot;</span>/&gt;</span><br><span class="line">                &#123;<span class="comment">/*x代表的真实的dom,把元素挂载在了当前实例上*/</span>&#125;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> ref=&#123;<span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.b = x;</span><br><span class="line">                &#125;&#125;/&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.result&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123; <span class="comment">// 他会比较两个状态相等就不会刷新视图 PureComponent是浅比较</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name:<span class="string">&#x27;珠峰培训&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1.constructor构造函数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取本地的数据 同步的方式：采用渲染之前获取数据，只渲染一次</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2.组件将要加载 componentWillMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4.组件挂载完成 componentDidMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:<span class="built_in">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// react可以shouldComponentUpdate方法中优化 PureComponent 可以帮我们做这件事</span></span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123; <span class="comment">// 代表的是下一次的属性 和 下一次的状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5.组件是否更新 shouldComponentUpdate&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> nextState.number%<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// return nextState.number!==this.state.number; //如果此函数种返回了false 就不会调用render方法了</span></span><br><span class="line">  &#125; <span class="comment">//不要随便用setState 可能会死循环</span></span><br><span class="line">  <span class="function"><span class="title">componentWillUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6.组件将要更新 componentWillUpdate&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7.组件完成更新 componentDidUpdate&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3.render&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.number&gt;<span class="number">3</span>?<span class="literal">null</span>:<span class="xml"><span class="tag">&lt;<span class="name">ChildCounter</span> <span class="attr">n</span>=<span class="string">&#123;this.state.number&#125;/</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;组件将要卸载componentWillUnmount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentWillMount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child-render&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">this</span>.props.n&#125;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentDidMount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">newProps</span>)</span>&#123; <span class="comment">// 第一次不会执行，之后属性更新时才会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentWillReceiveProps&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextProps.n%<span class="number">3</span>; <span class="comment">//子组件判断接收的属性 是否满足更新条件 为true则更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defaultProps</span></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br><span class="line"><span class="comment">// 状态更新会触发的</span></span><br><span class="line"><span class="comment">// shouldComponentUpdate nextProps,nextState=&gt;boolean</span></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// 属性更新</span></span><br><span class="line"><span class="comment">// componentWillReceiveProps newProps</span></span><br><span class="line"><span class="comment">// 卸载</span></span><br><span class="line"><span class="comment">// componentWillUnmount</span></span><br></pre></td></tr></table></figure>

<h3 id="16-3-之前的"><a href="#16-3-之前的" class="headerlink" title="16.3 之前的"></a>16.3 之前的</h3><p><img src="./2020/10/21/React%E5%9F%BA%E7%A1%80%E7%AF%87/react15.png" alt="lifeCycle"></p>
<h3 id="16-3-之后的"><a href="#16-3-之后的" class="headerlink" title="16.3 之后的"></a>16.3 之后的</h3><p><img src="./2020/10/21/React%E5%9F%BA%E7%A1%80%E7%AF%87/react16.3.png" alt="lifeCycle"><br>V17可能会废弃的三个⽣生命周期函数⽤用getDerivedStateFromProps替代，⽬目前使⽤用的话加上UNSAFE_：</p>
<ul>
<li><p>componentWillMount</p>
</li>
<li><p>componentWillReceiveProps</p>
</li>
<li><p>componentWillUpdate<br>引⼊入两个新的⽣生命周期函数：</p>
</li>
<li><p>static getDerivedStateFromProps<br>  getDerivedStateFromProps 会在调⽤用 render ⽅方法之前调⽤用，并且在初始挂载及后续更更新时都会被<br>  调⽤用。它应返回⼀一个对象来更更新 state，如果返回 null 则不不更更新任何内容。<br>  请注意，不不管原因是什什么，都会在 每次 渲染前触发此⽅方法。这与UNSAFE_componentWillReceiveProps 形成对⽐比，后者仅在⽗父组件重新渲染时触发，而不不是在内部调⽤用  setState 时。</p>
</li>
<li><p>getSnapshotBeforeUpdate<br>  getSnapshotBeforeUpdate(prevProps, prevState)<br>  在render之后，在componentDidUpdate之前<br>  getSnapshotBeforeUpdate() 在最近⼀一次渲染输出（提交到 DOM 节点）之前调⽤用。它使得组件能<br>在发⽣生更更改之前从 DOM 中捕获⼀一些信息（例例如，滚动位置）。此⽣生命周期的任何返回值将作为参数传<br>递给  componentDidUpdate(prevProps, prevState, snapshot)</p>
</li>
</ul>
<p>如果不不想⼿手动给将要废弃的⽣生命周期添加  UNSAFE_ 前缀，可以⽤用下⾯面的命令。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npx react-codemod <span class="built_in">rename</span>-unsafe-lifecycles &lt;<span class="built_in">path</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="react-资源"><a href="#react-资源" class="headerlink" title="react 资源"></a>react 资源</h2><ul>
<li><p><a href="https://juejin.cn/post/6950063294270930980">React全部api解读</a></p>
</li>
<li><p><a href="https://github.com/carlleton/reactjs101/tree/zh-CN">react从0学习</a></p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>js面试题</title>
    <url>./2020/10/29/js%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><h2 id="操作符的强制类型转换规则"><a href="#操作符的强制类型转换规则" class="headerlink" title="== 操作符的强制类型转换规则"></a>== 操作符的强制类型转换规则</h2><ul>
<li>字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较</li>
<li>其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较</li>
<li>null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</li>
<li>对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较</li>
<li>如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）</li>
<li>如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</li>
</ul>
<h2 id="、Object-is-、Set去重的区别"><a href="#、Object-is-、Set去重的区别" class="headerlink" title="===、Object.is()、Set去重的区别"></a>===、Object.is()、Set去重的区别</h2><ul>
<li>这几个的差异是在-0与+0；NaN上</li>
<li>=== -0与+0是相等的 NaN与NaN是不相等的</li>
<li>Object.is()  与===相反，-0与+0是不相等的，NaN与NaN是相等的</li>
<li>Set 认为两组都是相等的</li>
<li>includes 和 Set 相同</li>
</ul>
<h2 id="this指向-当前方法执行的主体-谁执行的这个方法-那么THIS就是谁-所以THIS和当前方法在哪创建的或者在哪执行的都没有必然的关系"><a href="#this指向-当前方法执行的主体-谁执行的这个方法-那么THIS就是谁-所以THIS和当前方法在哪创建的或者在哪执行的都没有必然的关系" class="headerlink" title="this指向 当前方法执行的主体(谁执行的这个方法,那么THIS就是谁,所以THIS和当前方法在哪创建的或者在哪执行的都没有必然的关系)"></a>this指向 当前方法执行的主体(谁执行的这个方法,那么THIS就是谁,所以THIS和当前方法在哪创建的或者在哪执行的都没有必然的关系)</h2><ul>
<li>给元素的某个事件绑定方法，方法中的THIS都是当前操作的元素本身</li>
<li>函数执行，看函数前面是否有点，有的话，点前面是谁THIS就是谁，没有点，THIS是WINDOW（在JS的严格模式下，没有点THIS是UNDEFINED）</li>
<li>构造函数执行，方法中的this一般都是当前类的实例</li>
<li>箭头函数中没有自己的THIS,THIS是上下文中的THIS</li>
<li>在小括号表达式中，会影响THIS的指向</li>
<li>使用call/apply/bind可以改变this指向<a id="more"></a>

</li>
</ul>
<h2 id="case语句是使用恒等（-）来判断的"><a href="#case语句是使用恒等（-）来判断的" class="headerlink" title="case语句是使用恒等（===）来判断的"></a>case语句是使用恒等（===）来判断的</h2><h2 id="正则-test-方法的参数如果不是字符串，会经过抽象-ToString操作强制转成字符串"><a href="#正则-test-方法的参数如果不是字符串，会经过抽象-ToString操作强制转成字符串" class="headerlink" title="正则 test 方法的参数如果不是字符串，会经过抽象 ToString操作强制转成字符串"></a>正则 test 方法的参数如果不是字符串，会经过抽象 ToString操作强制转成字符串</h2><h2 id="JSON-stringify-拷贝时obj-的缺陷"><a href="#JSON-stringify-拷贝时obj-的缺陷" class="headerlink" title="JSON.stringify 拷贝时obj 的缺陷"></a>JSON.stringify 拷贝时obj 的缺陷</h2><p><img src="./2020/10/29/js%E9%9D%A2%E8%AF%95%E9%A2%98/json.stringify.png" alt="JSON.stringify"></p>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失</li>
<li>拷贝 Date 引用类型会变成字符串</li>
<li>无法拷贝不可枚举的属性</li>
<li>无法拷贝对象的原型链</li>
<li>拷贝正则会变成空对象</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null</li>
<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)</li>
</ul>
<h2 id="js-常见的6中继承方式"><a href="#js-常见的6中继承方式" class="headerlink" title="js 常见的6中继承方式"></a>js 常见的6中继承方式</h2><p> <img src="./2020/10/29/js%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%A7%E6%89%BF.png" alt="JavaScript继承"></p>
<ul>
<li><p>原型链继承<br>  介绍：子类的原型指向父类构造的实例<br>  缺点： 原型属性共享问题</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line"><span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.type = <span class="string">&quot;child2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child1.prototype = <span class="keyword">new</span> Parent1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1());</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2();</span><br><span class="line">s1.play.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.play, s2.play);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数继承<br>  缺点：只能继承父类的实例属性和方法，不能继承原型属性或者方法</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;parent1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Parent1.call(<span class="built_in">this</span>);</span><br><span class="line"><span class="built_in">this</span>.type = <span class="string">&#x27;child1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="built_in">console</span>.log(child);  <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// Child1 &#123; name: &#x27;parent1&#x27;, type: &#x27;child1&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.getName());  <span class="comment">// 会报错 child.getName is not a function</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组合继承<br>  缺点：父类函数会多次执行</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二次调用 Parent3()</span></span><br><span class="line">    Parent3.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;child3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次调用 Parent3()</span></span><br><span class="line"></span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s3.play, s4.play);  <span class="comment">// 不互相影响</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s3.getName()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s4.getName()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承<br>  缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parent4 = &#123;</span><br><span class="line">    name: <span class="string">&quot;parent4&quot;</span>,</span><br><span class="line"></span><br><span class="line">    friends: [<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line"></span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person4 = <span class="built_in">Object</span>.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">person4.friends.push(<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person5 = <span class="built_in">Object</span>.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person4.name);</span><br><span class="line"><span class="comment">// tom</span></span><br><span class="line"><span class="built_in">console</span>.log(person4.name === person4.getName());</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.name);</span><br><span class="line"><span class="comment">// parent4</span></span><br><span class="line"><span class="built_in">console</span>.log(person4.friends);</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.friends);</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生式继承</p>
</li>
<li><p>寄生组合继承<br>  寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">    child.prototype = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;parent6&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent6.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent6.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.friends = <span class="string">&quot;child5&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line">Child6.prototype.getFriends = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.friends;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person6 = <span class="keyword">new</span> Child6();</span><br><span class="line"><span class="built_in">console</span>.log(person6);</span><br><span class="line"><span class="built_in">console</span>.log(person6.getName());</span><br><span class="line"><span class="built_in">console</span>.log(person6.getFriends());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="js-原型链"><a href="#js-原型链" class="headerlink" title="js 原型链"></a>js 原型链</h2><p><img src="./2020/10/29/js%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="js原型链"></p>
<ul>
<li>每个函数都有  <code>prototype</code> 属性，除了  <code>Function.prototype.bind()</code> 该属性指向原型。该属性的值是一个堆内存，堆内存中默认自带一个属性<code>constructor</code>,值是函数本身。</li>
<li>每个对象都有 <code>__proto__</code>属性，指向了创建该对象的构造函数的原型。</li>
<li>对象可以通过 <code>__proto__</code>来寻找不属于该对象的属性， <code>__proto__</code> 将对象连接起来组成了原型链。</li>
</ul>
<h2 id="定时器为什么不是精确的"><a href="#定时器为什么不是精确的" class="headerlink" title="定时器为什么不是精确的"></a>定时器为什么不是精确的</h2><h2 id="JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？"><a href="#JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？" class="headerlink" title="JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？"></a>JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</h2><ul>
<li>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条</li>
<li>offsetHeight：表示可视区域的高度，包含了 border 和滚动条</li>
<li>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分</li>
<li>clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</li>
<li>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css定位的元素或 body 元素)距离顶端的高度。</li>
</ul>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别?"></a>箭头函数和普通函数的区别?</h2><ul>
<li><p>箭头函数没有自己的this，只能通过作用域链来向上查找离自己最近的那个函数的this</p>
</li>
<li><p>箭头函数不能作为constructor，因此不能通过new 来调用，所以它并没用new.target这个属性</p>
</li>
<li><p>箭头函数没有argument属性，可以通过rest可以获取</p>
</li>
<li><p>箭头函数不能直接使用call和apply，bind来改变this</p>
</li>
<li><p>箭头函数不能使用yield，不能作为generator函数</p>
</li>
<li><p>箭头函数语法比普通函数更加简洁</p>
</li>
<li><p>ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数或构造方法。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数时怎样调用的。包括super也不存在以及原型prototype —- 因为在执行new的时候需要将函数的原型赋值给实力对象的原型属性。</p>
</li>
</ul>
<h2 id="TypeScript里面有哪些JavaScript没有的类型"><a href="#TypeScript里面有哪些JavaScript没有的类型" class="headerlink" title="TypeScript里面有哪些JavaScript没有的类型?"></a>TypeScript里面有哪些JavaScript没有的类型?</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">相比较JavaScript，TypeScript独有的类型</span><br><span class="line">any</span><br><span class="line">声明为any的变量可以赋予任意类型的值</span><br><span class="line"></span><br><span class="line">tuple</span><br><span class="line">元组类型用来表示已知元素数量和类型的数组，个元素的类型不必相同，对应位置的类型需要一样</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line">x = [‘string’, <span class="number">0</span>]; <span class="comment">// 正常</span></span><br><span class="line">x = [<span class="number">0</span>, ‘string’]; <span class="comment">// 报错</span></span><br><span class="line">enum</span><br><span class="line">枚举类型用于定义值集合</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="built_in">console</span>.log©; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">void</span> 标识方法返回值的类型，表示方法没有返回值。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br><span class="line">never</span><br><span class="line">never是其它类型(包括<span class="literal">null</span>和<span class="literal">undefined</span>)的子类型，是不会发生的类型。例如，never总是抛出异常或永不返回的异常的函数表达式的返回类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 never 的函数终点不可达</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回类型是 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> error(‘Something failed’);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 never 的函数终点不可达</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">unknown 未知类型，一般在使用后再手动转具体的类型</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line"></span><br><span class="line">联合类型，多种类型之一</span><br><span class="line"></span><br><span class="line">string | number; <span class="comment">// string 或 number</span></span><br><span class="line">intersection</span><br><span class="line">交叉类型，多种类型合并</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">a</span>: string; &#125; &amp; &#123; <span class="attr">b</span>: number; &#125; <span class="comment">// =&gt; &#123; a: string; b: number &#125;</span></span><br><span class="line">Generics</span><br><span class="line">泛型</span><br><span class="line"></span><br><span class="line">interface Backpack &#123;</span><br><span class="line">add: <span class="function">(<span class="params">obj: T</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">get: <span class="function">() =&gt;</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对-URL-进行编码-解码的实现方式"><a href="#对-URL-进行编码-解码的实现方式" class="headerlink" title="对 URL 进行编码/解码的实现方式"></a>对 URL 进行编码/解码的实现方式</h2><ul>
<li>：escape和unescape:<br>escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值<br>除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码。在u0000到u00ff之间的符号被转成%xx的形式，其余符号被转成%uxxxx的形式。对应的解码函数是unescape()。</li>
<li>：encodeURL和decodeURL：<br>encodeURI()是Javascript中真正用来对URL编码的函数。<br>它用于对URL的组成部分进行个别编码，除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。<br>它对应的解码函数是decodeURI()</li>
<li>：encodeURLComponent和decodeURLComponent:<br>与encodeURI()的区别是，它用于对整个URL进行编码。”; / ? : @ &amp; = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。<br>它对应的解码函数是decodeURIComponent()</li>
</ul>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="vuex的原理和理解"><a href="#vuex的原理和理解" class="headerlink" title="vuex的原理和理解"></a>vuex的原理和理解</h2><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h2 id="state如何注入组件，从redux到组件经历的过程"><a href="#state如何注入组件，从redux到组件经历的过程" class="headerlink" title="state如何注入组件，从redux到组件经历的过程"></a>state如何注入组件，从redux到组件经历的过程</h2><h2 id="react-最新的生命周期"><a href="#react-最新的生命周期" class="headerlink" title="react 最新的生命周期"></a>react 最新的生命周期</h2><p>React 16之后有三个⽣命周期被废弃(但并未删除)</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate<br>计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，⽬的是为了向下兼容，但是对于开发者⽽⾔应该尽量避免使⽤他们，⽽是使⽤新增的⽣命周期函数替代它们</li>
</ul>
<p>最新的⽣命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p>
<ul>
<li>挂载阶段<ul>
<li>constructor: 构造函数，最先被执⾏,我们通常在构造函数⾥初始化state对象或者给⾃定义⽅法绑定this</li>
<li>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState) ,这是个静态⽅法,当我们接收到新的属性想去修改我们state，可以使⽤getDerivedStateFromProps</li>
<li>render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返回原⽣的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</li>
<li>componentDidMount: 组件装载之后调⽤，此时我们可以获取到DOM节点并操作，⽐如对canvas，svg的操作，服务器请求，订阅都可以写在这个⾥⾯，但是记得在componentWillUnmount中取消订阅</li>
</ul>
</li>
<li>更新阶段<ul>
<li>getDerivedStateFromProps: 此⽅法在更新个挂载阶段都可能会调⽤</li>
<li>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState) ,有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回⼀个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利⽤此⽣命周期来优化React程序性能</li>
<li>render: 更新阶段也会触发此⽣命周期</li>
<li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState) , 这 个 ⽅ 法 在 render 之 后 ，componentDidUpdate之前调⽤，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有⼀个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此⽣命周期必须与componentDidUpdate搭配使⽤</li>
<li>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot) ,该⽅法在getSnapshotBeforeUpdate⽅法之后被调⽤，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统⼀触发回调或更新状态。</li>
</ul>
</li>
<li>卸载阶段</li>
</ul>
<h2 id="setState-是同步还是异步"><a href="#setState-是同步还是异步" class="headerlink" title="setState 是同步还是异步"></a>setState 是同步还是异步</h2><h2 id="react-组件的通信"><a href="#react-组件的通信" class="headerlink" title="react 组件的通信"></a>react 组件的通信</h2><h2 id="react-优化手段"><a href="#react-优化手段" class="headerlink" title="react 优化手段"></a>react 优化手段</h2><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h1><h2 id="请求在客户端报413是什么错误-怎么解决呢"><a href="#请求在客户端报413是什么错误-怎么解决呢" class="headerlink" title="请求在客户端报413是什么错误,怎么解决呢?"></a>请求在客户端报413是什么错误,怎么解决呢?</h2><ul>
<li>HTTP 413 错误(Request entity too large 请求实体太大)，就是客户端发送的实体主体部分比服务器能够或者希望处理的要大时，会出现这样的错误。一般上传文件时会出现这样的错误概率比较大。<br>解决方案可以修改服务器的配置文件。配置客户端请求大小和缓存大小</li>
</ul>
<h1 id="前端安全和工程化"><a href="#前端安全和工程化" class="headerlink" title="前端安全和工程化"></a>前端安全和工程化</h1><h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h1 id="面试题集"><a href="#面试题集" class="headerlink" title="面试题集"></a>面试题集</h1><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&mid=2650081252&idx=1&sn=1fedc422a3806fa1f9c3faf31bb2a20b&chksm=83db9a81b4ac1397132de99ebdbdbdad57dcc6785d0b8fe1a5ee2b57dbb960b0fbf65015c3ca&scene=126&sessionid=1603760808&key=54ce6b15dc70fa94e4cee849718a95dcb45463880bfbf73a52f6e49f4e4a65fb8adec9e1c54df8bf81bfa1d78626a8537229cc36083224e425c795f892103475ca5f06542d47eec5dabc5d55c77dc7f9fabc4524bbc83cf94060d9236d1061a0fa026db04b47ae38fdfd65662df5549a11d6cd60ff371f5492081a022254d0e7&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AXrZ8Ft8M/kmfXMdRQOHyYs=&pass_ticket=Kkp6C7aNRW+SS3CyH29rTpuzIryrfuzR2BkuJOMPRmZ73lUqRYKqbJR1nz5SlRhp&wx_header=0">面试题1</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247486750&idx=1&sn=d7e13a8393b83ac330d9b48690428c0e&chksm=fa2bedf7cd5c64e19fcafbe4dab742b65cfe168ad567f3f799b5fc229a35710eb4164084897c&scene=126&sessionid=1602725812&key=6664ac14267ba66883c13581e1d9e62b3ffc7ddfc44d1984c762bde82d19131986d5d9af50595ab1d798e16e45eddd68ded75929bfc6217a87ec0dcacb393b0aa10b53bcd066f65c7865905a425d129f9f1f110464e3a8faa5601a1b7a192f46240134dd033c0bacd43e93b0b51701140f106a0a52acfaabf76e8fee9f2cae06&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=Adc0WAca8bFpyYT3RtaxAjo=&pass_ticket=gNZw604QfgMyZ5MfqQB17Zb9G0KO/y/Gpe3+UhEBieJBkyQwt1xU8LnZyQLLT598&wx_header=0">面试题2</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NTk2NzUxNg==&mid=2247488674&idx=1&sn=3f5c6af2c52365525aa84ff92b9f865b&chksm=ea941651dde39f4790e96e2d8f2530fa23257afb50de8d40d6d318507b873f9d870c0f507863&mpshare=1&scene=1&srcid=1026yMwvhU6WsEBstdZUyIgl&sharer_sharetime=1603682665969&sharer_shareid=1b2206d548f7c54418de346a0102e46f&key=041bb01ba83758f9c012f304255f853e521afbe7bbf65555a0e068f76f2c433eea39d0413b426b59a870039c71945328b288292bbbbac9811706f2f09f6716c482684831e94eab0b6935f37a6a5c8892d4ca9ecd897e139bf608b85a18e8ee5339e931c56cc60e39443738eeb63253718488c0322710c61a17510cbfa97910cb&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AQ+cZHmGMZ8MBH/qQ1l2YVc=&pass_ticket=L+jndQVDhQl1X8R7c+wxUxrwQN/fivdCt7LVG0oUoik5qA1Gx2ZTiVGm+4shiHQn&wx_header=0">源码面试题</a></p>
</li>
<li><p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions">前端开发面试题</a></p>
</li>
<li><p><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/">WEB前端面试宝典</a></p>
</li>
<li><p><a href="https://github.com/shfshanyue/blog/blob/master/post/juejin-interview.md">掘金前端面试题合集</a></p>
</li>
<li><p><a href="https://yuchengkai.cn/">前端面试图谱</a></p>
</li>
<li><p><a href="https://github.com/biaochenxuying/blog/issues/47">前端面试开源项目汇总 | Github上100K+ Star 的前端面试开源项目汇总</a></p>
</li>
<li><p><a href="https://blog.poetries.top/FE-Interview-Questions/">前端面试常考问题整理 |  按模块和知识点分类</a></p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>js面试题</category>
      </categories>
      <tags>
        <tag>js面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue代码简单解析</title>
    <url>./2020/10/21/vue-souce/</url>
    <content><![CDATA[<h2 id="1-谈一下你对MVVM-原理的理解"><a href="#1-谈一下你对MVVM-原理的理解" class="headerlink" title="1.谈一下你对MVVM 原理的理解"></a>1.谈一下你对<code>MVVM </code>原理的理解</h2><img src="./2020/10/21/vue-souce/MVVM.jpg" alt="MVVM" style="zoom: 50%;">

<ul>
<li>传统的<code>MVC</code>指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染</li>
<li><code>MVVM</code>:传统的前端会将数据手动渲染到页面上,<code>MVVM</code>模式不需要用户收到操作<code>dom</code>元素,将数据绑定到<code>viewModel</code>层上，会自动将数据渲染到页面中，视图变化会通知<code>viewModel层</code>更新数据。<code>ViewModel</code>就是我们<code>MVVM</code>模式中的桥梁.<a id="more"></a>
<h2 id="2-请说一下响应式数据的原理？"><a href="#2-请说一下响应式数据的原理？" class="headerlink" title="2.请说一下响应式数据的原理？"></a>2.请说一下响应式数据的原理？</h2></li>
</ul>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>1.核心点:<code>Object.defineProperty</code></li>
<li>2.默认<code>Vue</code>在初始化数据时，会给<code>data</code>中的属性使用<code>Object.defineProperty</code>重新定义所有属性,当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher） 如果属性发生变化会通知相关依赖进行更新操作。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><p><img src="./2020/10/21/vue-souce/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend() <span class="comment">// ** 收集依赖 ** /</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify() <span class="comment">/**通知相关依赖进行更新**/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-Vue中是如何检测数组变化"><a href="#3-Vue中是如何检测数组变化" class="headerlink" title="3.Vue中是如何检测数组变化?"></a>3.<code>Vue</code>中是如何检测数组变化?</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>使用函数劫持的方式，重写了数组的方法</li>
<li><code>Vue</code>将<code>data</code>中的数组，进行了原型链重写。指向了自己定义的数组原型方法，这样当调用数组<code>api</code>时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控。</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h3><p><img src="./2020/10/21/vue-souce/%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123; <span class="comment">// 重写原型方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method] <span class="comment">// 调用原数组的方法</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify() <span class="comment">// 当调用数组方法后，手动通知视图更新</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.observeArray(value) <span class="comment">// 进行深度监控</span></span><br></pre></td></tr></table></figure>

<h2 id="4-为何Vue采用异步渲染"><a href="#4-为何Vue采用异步渲染" class="headerlink" title="4.为何Vue采用异步渲染?"></a>4.为何<code>Vue</code>采用异步渲染?</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染.所以为了性能考虑。<code>Vue</code>会在本轮数据更新后，再去异步更新视图!</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理:"></a>原理:</h3><p><img src="./2020/10/21/vue-souce/%E4%B8%BA%E4%BD%95%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="built_in">this</span>); <span class="comment">// 当数据发生变化时会将watcher放到一个队列中批量更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id <span class="comment">// 会对相同的watcher进行过滤</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue) <span class="comment">// 调用nextTick方法 批量的进行更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-nextTick实现原理"><a href="#5-nextTick实现原理" class="headerlink" title="5.nextTick实现原理?"></a>5.<code>nextTick</code>实现原理?</h2><h3 id="理解-宏任务和微任务-异步方法"><a href="#理解-宏任务和微任务-异步方法" class="headerlink" title="理解:(宏任务和微任务) 异步方法"></a>理解:(<strong>宏任务</strong>和<strong>微任务</strong>) 异步方法</h3><p><code>nextTick</code>方法主要是使用了<strong>宏任务</strong>和<strong>微任务</strong>,定义了一个异步方法.多次调用<code>nextTick</code> 会将方法存入队列中，通过这个异步方法清空当前队列。 所以这个<code>nextTick</code>方法就是异步方法</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理:"></a>原理:</h3><p><img src="./2020/10/21/vue-souce/nextTick%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc  <span class="comment">// 会定义一个异步方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;  <span class="comment">// promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; ( <span class="comment">// MutationObserver</span></span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> ) &#123; <span class="comment">// setImmediate</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;   <span class="comment">// setTimeout</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nextTick实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-Vue中Computed的特点"><a href="#6-Vue中Computed的特点" class="headerlink" title="6.Vue中Computed的特点"></a>6.<code>Vue</code>中<code>Computed</code>的特点</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>默认<code>computed</code>也是一个<code>watcher</code>是具备缓存的，只要当依赖的属性发生变化时才会更新视图</li>
</ul>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理:"></a>原理:</h3><p><img src="./2020/10/21/vue-souce/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123; <span class="comment">// 如果依赖的值没发生变化,就不会重新求值</span></span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Watch中的deep-true-是如何实现的"><a href="#7-Watch中的deep-true-是如何实现的" class="headerlink" title="7.Watch中的deep:true 是如何实现的"></a>7.<code>Watch</code>中的<code>deep:true</code> 是如何实现的</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><ul>
<li>当用户指定了<code>watch</code>中的deep属性为<code>true</code>时，如果当前监控的值是数组类型。会对对象中的每一项进行求值，此时会将当前<code>watcher</code>存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新</li>
</ul>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>) <span class="comment">// 先将当前依赖放到 Dep.target上</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123; <span class="comment">// 如果需要深度监控</span></span><br><span class="line">        traverse(value) <span class="comment">// 会对对象中的每一项取值,取值时会执行对应的get方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val: any, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8-Vue组件的生命周期"><a href="#8-Vue组件的生命周期" class="headerlink" title="8.Vue组件的生命周期"></a>8.<code>Vue</code>组件的生命周期</h2><h3 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h3><h4 id="要掌握每个生命周期什么时候被调用"><a href="#要掌握每个生命周期什么时候被调用" class="headerlink" title="要掌握每个生命周期什么时候被调用"></a>要掌握每个生命周期什么时候被调用</h4><ul>
<li><code>beforeCreate</code> 在实例初始化之后，数据观测(data observer) 之前被调用。</li>
<li><code>created</code> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el</li>
<li><code>beforeMount</code> 在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li><code>mounted</code> el 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。</li>
<li><code>beforeUpdate</code> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li>
<li><code>updated</code> 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
<li><code>beforeDestroy</code> 实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li><code>destroyed</code> <code>Vue</code> 实例销毁后调用。调用后，<code>Vue</code> 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h4 id="要掌握每个生命周期内部可以做什么事"><a href="#要掌握每个生命周期内部可以做什么事" class="headerlink" title="要掌握每个生命周期内部可以做什么事"></a>要掌握每个生命周期内部可以做什么事</h4><ul>
<li><code>created</code> 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。</li>
<li><code>mounted</code> 实例已经挂载完成，可以进行一些DOM操作</li>
<li><code>beforeUpdate</code> 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li><code>updated</code> 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。</li>
<li><code>destroyed</code> 可以执行一些优化操作,清空定时器，解除绑定事件</li>
</ul>
<p><img src="./2020/10/21/vue-souce/lifecycle.png" alt="lifecycle"></p>
<h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p><img src="./2020/10/21/vue-souce/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p>
<h2 id="9-ajax请求放在哪个生命周期中"><a href="#9-ajax请求放在哪个生命周期中" class="headerlink" title="9.ajax请求放在哪个生命周期中"></a>9.<code>ajax</code>请求放在哪个生命周期中</h2><h3 id="理解-5"><a href="#理解-5" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>在created的时候，视图中的<code>dom</code>并没有渲染出来，所以此时如果直接去操<code>dom</code>节点，无法找到相关的元素 </li>
<li>在mounted中，由于此时<code>dom</code>已经渲染出来了，所以可以直接操作<code>dom</code>节点 </li>
</ul>
<p>一般情况下都放到<code>mounted</code>中,保证逻辑的统一性,因为生命周期是同步执行的，<code>ajax</code>是异步执行的</p>
<blockquote>
<p>服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中</p>
</blockquote>
<h2 id="10-何时需要使用beforeDestroy"><a href="#10-何时需要使用beforeDestroy" class="headerlink" title="10.何时需要使用beforeDestroy"></a>10.何时需要使用<code>beforeDestroy</code></h2><h3 id="理解-6"><a href="#理解-6" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>可能在当前页面中使用了<code>$on</code>方法，那需要在组件销毁前解绑。</li>
<li>清除自己定义的定时器</li>
<li>解除事件的绑定 <code>scroll mousemove ....</code></li>
</ul>
<h2 id="11-Vue中模板编译原理"><a href="#11-Vue中模板编译原理" class="headerlink" title="11.Vue中模板编译原理"></a>11.<code>Vue</code>中模板编译原理</h2><ul>
<li>将<code>template</code>转化成<code>render</code>函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options) <span class="comment">// 1.将模板转化成ast语法树</span></span><br><span class="line">  <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;           <span class="comment">// 2.优化树</span></span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)         <span class="comment">// 3.生成树</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>; </span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span>;</span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>); <span class="comment">// 标签开头的正则 捕获的内容是标签名</span></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;\\/<span class="subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>); <span class="comment">// 匹配标签结尾的  &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>; <span class="comment">// 匹配属性的</span></span><br><span class="line"><span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>; <span class="comment">// 匹配标签结束的  &gt;</span></span><br><span class="line"><span class="keyword">let</span> root;</span><br><span class="line"><span class="keyword">let</span> currentParent;</span><br><span class="line"><span class="keyword">let</span> stack = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createASTElement</span>(<span class="params">tagName,attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag:tagName,</span><br><span class="line">        type:<span class="number">1</span>,</span><br><span class="line">        children:[],</span><br><span class="line">        attrs,</span><br><span class="line">        parent:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">tagName,attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> element = createASTElement(tagName,attrs);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!root</span>)</span>&#123;</span><br><span class="line">        root = element;</span><br><span class="line">    &#125;</span><br><span class="line">    currentParent = element;</span><br><span class="line">    stack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chars</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        type:<span class="number">3</span>,</span><br><span class="line">        text</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">tagName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = stack[stack.length-<span class="number">1</span>];</span><br><span class="line">    stack.length --; </span><br><span class="line">    currentParent = stack[stack.length-<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">currentParent</span>)</span>&#123;</span><br><span class="line">        element.parent = currentParent;</span><br><span class="line">        currentParent.children.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">textEnd == <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">startTagMatch</span>)</span>&#123;</span><br><span class="line">                start(startTagMatch.tagName,startTagMatch.attrs);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> endTagMatch = html.match(endTag);</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">endTagMatch</span>)</span>&#123;</span><br><span class="line">                advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">                end(endTagMatch[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> text;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">textEnd &gt;=<span class="number">0</span> </span>)</span>&#123;</span><br><span class="line">            text = html.substring(<span class="number">0</span>,textEnd)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">            advance(text.length);</span><br><span class="line">            chars(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">advance</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        html = html.substring(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> start = html.match(startTagOpen);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">start</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> match = &#123;</span><br><span class="line">                tagName:start[<span class="number">1</span>],</span><br><span class="line">                attrs:[]</span><br><span class="line">            &#125;</span><br><span class="line">            advance(start[<span class="number">0</span>].length);</span><br><span class="line">            <span class="keyword">let</span> attr,end</span><br><span class="line">            <span class="keyword">while</span>(!(end = html.match(startTagClose)) &amp;&amp; (attr=html.match(attribute)))&#123;</span><br><span class="line">                advance(attr[<span class="number">0</span>].length);</span><br><span class="line">                match.attrs.push(&#123;<span class="attr">name</span>:attr[<span class="number">1</span>],<span class="attr">value</span>:attr[<span class="number">3</span>]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">end</span>)</span>&#123;</span><br><span class="line">                advance(end[<span class="number">0</span>].length);</span><br><span class="line">                <span class="keyword">return</span> match</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成语法树</span></span><br><span class="line">parseHTML(<span class="string">`&lt;div id=&quot;container&quot;&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">node.type == <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generate(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(node.text)&#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genChildren</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> children = el.children;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">el.children</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;children.map(c=&gt;gen(c)).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>]`</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genProps</span>(<span class="params">attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length;i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> attr = attrs[i];</span><br><span class="line">        str+= <span class="string">`<span class="subst">$&#123;attr.name&#125;</span>:<span class="subst">$&#123;attr.value&#125;</span>,`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;attrs:&#123;<span class="subst">$&#123;str.slice(<span class="number">0</span>,-<span class="number">1</span>)&#125;</span>&#125;&#125;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> children = genChildren(el);</span><br><span class="line">    <span class="keyword">let</span> code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        el.attrs.length? <span class="string">`,<span class="subst">$&#123;genProps(el.attrs)&#125;</span>`</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        children? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据语法树生成新的代码</span></span><br><span class="line"><span class="keyword">let</span> code = generate(root);</span><br><span class="line"><span class="keyword">let</span> render = <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装成函数</span></span><br><span class="line"><span class="keyword">let</span> renderFn = <span class="keyword">new</span> <span class="built_in">Function</span>(render);</span><br><span class="line"><span class="built_in">console</span>.log(renderFn.toString());</span><br></pre></td></tr></table></figure>

<h2 id="12-Vue中v-if和v-show的区别"><a href="#12-Vue中v-if和v-show的区别" class="headerlink" title="12.Vue中v-if和v-show的区别"></a>12.<code>Vue</code>中<code>v-if</code>和<code>v-show</code>的区别</h2><h3 id="理解-7"><a href="#理解-7" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li><code>v-if</code>如果条件不成立不会渲染当前指令所在节点的<code>dom</code>元素</li>
<li><code>v-show</code>只是切换当前<code>dom</code>的显示或者隐藏</li>
</ul>
<h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-if=&quot;true&quot;&gt;&lt;span v-for=&quot;i in 3&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return (true) ? _c(&#x27;div&#x27;, _l((3), function (i) &#123;</span></span><br><span class="line"><span class="comment">        return _c(&#x27;span&#x27;, [_v(&quot;hello&quot;)])</span></span><br><span class="line"><span class="comment">    &#125;), 0) : _e()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-show=&quot;true&quot;&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        directives: [&#123;</span></span><br><span class="line"><span class="comment">            name: &quot;show&quot;,</span></span><br><span class="line"><span class="comment">            rawName: &quot;v-show&quot;,</span></span><br><span class="line"><span class="comment">            value: (true),</span></span><br><span class="line"><span class="comment">            expression: &quot;true&quot;</span></span><br><span class="line"><span class="comment">        &#125;]</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v-show 操作的是样式  定义在platforms/web/runtime/directives/show.js</span></span><br><span class="line">bind (el: any, &#123; value &#125;: VNodeDirective, <span class="attr">vnode</span>: VNodeWithData) &#123;</span><br><span class="line">    vnode = locateNode(vnode)</span><br><span class="line">    <span class="keyword">const</span> transition = vnode.data &amp;&amp; vnode.data.transition</span><br><span class="line">    <span class="keyword">const</span> originalDisplay = el.__vOriginalDisplay =</span><br><span class="line">      el.style.display === <span class="string">&#x27;none&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : el.style.display</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; transition) &#123;</span><br><span class="line">      vnode.data.show = <span class="literal">true</span></span><br><span class="line">      enter(vnode, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        el.style.display = originalDisplay</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.style.display = value ? originalDisplay : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13-为什么V-for和v-if不能连用"><a href="#13-为什么V-for和v-if不能连用" class="headerlink" title="13.为什么V-for和v-if不能连用"></a>13.为什么<code>V-for</code>和<code>v-if</code>不能连用</h2><h3 id="理解-8"><a href="#理解-8" class="headerlink" title="理解:"></a>理解:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-if=&quot;false&quot; v-for=&quot;i in 3&quot;&gt;hello&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _l((3), function (i) &#123;</span></span><br><span class="line"><span class="comment">        return (false) ? _c(&#x27;div&#x27;, [_v(&quot;hello&quot;)]) : _e()</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(r1.render);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-for</code>会比<code>v-if</code>的优先级高一些,如果连用的话会把<code>v-if</code>给每个元素都添加一下,会造成性能问题</li>
</ul>
<h2 id="14-用vnode来描述一个DOM结构"><a href="#14-用vnode来描述一个DOM结构" class="headerlink" title="14.用vnode来描述一个DOM结构"></a>14.用<code>vnode</code>来描述一个<code>DOM</code>结构</h2><ul>
<li>虚拟节点就是用一个对象来描述真实的<code>dom</code>元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$createElement</span>(<span class="params">tag,data,...children</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = data.key;</span><br><span class="line">    <span class="keyword">delete</span> data.key;</span><br><span class="line">    children = children.map(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> child === <span class="string">&#x27;object&#x27;</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> child</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vnode(<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> vnode(tag,props,key,children);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span>(<span class="params">tag,data,key,children,text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag, <span class="comment">// 表示的是当前的标签名</span></span><br><span class="line">        data, <span class="comment">// 表示的是当前标签上的属性</span></span><br><span class="line">        key, <span class="comment">// 唯一表示用户可能传递</span></span><br><span class="line">        children,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-diff算法的时间复杂度"><a href="#15-diff算法的时间复杂度" class="headerlink" title="15.diff算法的时间复杂度"></a>15.<code>diff</code>算法的时间复杂度</h2><p> 两个树的完全的<code>diff</code>算法是一个时间复杂度为 <code>O(n3) </code>,<code>Vue</code>进行了优化·<em>O(n3)</em> <em>复杂度</em>的问题转换成 O(n) <em>复杂度</em>的问题(只比较同级不考虑跨级问题)  在前端当中， 你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比。 </p>
<h2 id="16-简述Vue中diff算法原理"><a href="#16-简述Vue中diff算法原理" class="headerlink" title="16.简述Vue中diff算法原理"></a>16.简述<code>Vue</code>中<code>diff</code>算法原理</h2><h3 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h3><ul>
<li>1.先同级比较，在比较子节点</li>
<li>2.先判断一方有儿子一方没儿子的情况 </li>
<li>3.比较都有儿子的情况</li>
<li>4.递归比较子节点</li>
</ul>
<p><img src="./2020/10/21/vue-souce/vue-diff.jpg"></p>
<h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理:"></a>原理:</h3><blockquote>
<p><code>core/vdom/patch.js</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oldCh = oldVnode.children <span class="comment">// 老的儿子 </span></span><br><span class="line"><span class="keyword">const</span> ch = vnode.children  <span class="comment">// 新的儿子</span></span><br><span class="line"><span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// 比较孩子</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123; <span class="comment">// 新的儿子有 老的没有</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123; <span class="comment">// 如果老的有新的没有 就删除</span></span><br><span class="line">        removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;  <span class="comment">// 老的有文本 新的没文本</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 将老的清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123; <span class="comment">// 文本不相同替换</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-v-for中为什么要用key-图解"><a href="#17-v-for中为什么要用key-图解" class="headerlink" title="17.v-for中为什么要用key (图解)"></a>17.<code>v-for</code>中为什么要用<code>key</code> (图解)</h2><p><img src="./2020/10/21/vue-souce/diff-key.jpg"></p>
<h2 id="18-描述组件渲染和更新过程"><a href="#18-描述组件渲染和更新过程" class="headerlink" title="18.描述组件渲染和更新过程"></a>18.描述组件渲染和更新过程</h2><h3 id="理解：-2"><a href="#理解：-2" class="headerlink" title="理解："></a>理解：</h3><ul>
<li>渲染组件时，会通过<code>Vue.extend</code>方法构建子组件的构造函数，并进行实例化。最终手动调用<code>$mount()</code>进行挂载。更新组件时会进行<code>patchVnode</code>流程.核心就是diff算法</li>
</ul>
<p><img src="./2020/10/21/vue-souce/%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="19-组件中的-data为什么是一个函数"><a href="#19-组件中的-data为什么是一个函数" class="headerlink" title="19.组件中的 data为什么是一个函数?"></a>19.组件中的 <code>data</code>为什么是一个函数?</h2><h3 id="理解：-3"><a href="#理解：-3" class="headerlink" title="理解："></a>理解：</h3><p>同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果<code>data</code>是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过<code>data</code>函数返回一个对象作为组件的状态。</p>
<h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理:"></a>原理:</h3><blockquote>
<p><code>core/global-api/extend.js line:33</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 	 <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">        options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">strats.data = <span class="function"><span class="keyword">function</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123; <span class="comment">// 合并是会判断子类的data必须是一个函数</span></span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">&#x27;The &quot;data&quot; option should be a function &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;that returns a per-instance value in component &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;definitions.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个组件被使用多次，用的都是同一个构造函数。为了保证组件的不同的实例data不冲突，要求data必须是一个函数，这样组件间不会相互影响</li>
</ul>
<h2 id="20-Vue中事件绑定的原理"><a href="#20-Vue中事件绑定的原理" class="headerlink" title="20.Vue中事件绑定的原理"></a>20.<code>Vue</code>中事件绑定的原理</h2><h3 id="理解-9"><a href="#理解-9" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>1.原生<code>dom</code>事件的绑定,采用的是<code>addEventListener</code>实现</li>
<li>2.组件绑定事件采用的是<code>$on</code>方法</li>
</ul>
<h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理:"></a>原理:</h3><ul>
<li>事件的编译：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = compiler.compile(<span class="string">&#x27;&lt;div @click=&quot;fn()&quot;&gt;&lt;/div&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = compiler.compile(<span class="string">&#x27;&lt;my-component @click.native=&quot;fn&quot; @click=&quot;fn1&quot;&gt;&lt;/my-component&gt;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r1); <span class="comment">// &#123;on:&#123;click&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r2); <span class="comment">// &#123;nativeOnOn:&#123;click&#125;,on:&#123;click&#125;&#125;  </span></span><br></pre></td></tr></table></figure>

<p><img src="./2020/10/21/vue-souce/%E4%BA%8B%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p>
<h4 id="1-原生dom的绑定"><a href="#1-原生dom的绑定" class="headerlink" title="1.原生dom的绑定"></a>1.原生<code>dom</code>的绑定</h4><ul>
<li><code>Vue</code>在创建真是<code>dom</code>时会调用<code>createElm</code>,默认会调用<code>invokeCreateHooks</code></li>
<li>会遍历当前平台下相对的属性处理代码,其中就有<code>updateDOMListeners</code>方法,内部会传入<code>add</code>方法</li>
</ul>
<p>yuan</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMListeners</span> (<span class="params">oldVnode: VNodeWithData, vnode: VNodeWithData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> on = vnode.data.on || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> oldOn = oldVnode.data.on || &#123;&#125;</span><br><span class="line">  target = vnode.elm</span><br><span class="line">  normalizeEvents(on)</span><br><span class="line">  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context)</span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  capture: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  passive: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  target.addEventListener( <span class="comment">// 给当前的dom添加事件</span></span><br><span class="line">    name,</span><br><span class="line">    handler,</span><br><span class="line">    supportsPassive</span><br><span class="line">      ? &#123; capture, passive &#125;</span><br><span class="line">      : capture</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <code>vue</code>中绑定事件是直接绑定给真实<code>dom</code>元素的</p>
</blockquote>
<ul>
<li>2.组件中绑定事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateComponentListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldListeners: ?<span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  target = vm</span><br><span class="line">  updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, createOnceHandler, vm)</span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">  target.$on(event, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>组件绑定事件是通过<code>vue</code>中自定义的<code>$on</code>方法来实现的</p>
</blockquote>
<h2 id="21-v-model中的实现原理及如何自定义v-model"><a href="#21-v-model中的实现原理及如何自定义v-model" class="headerlink" title="21.v-model中的实现原理及如何自定义v-model"></a>21.<code>v-model</code>中的实现原理及如何自定义<code>v-model</code></h2><h3 id="理解-10"><a href="#理解-10" class="headerlink" title="理解:"></a>理解:</h3><p>组件的<code>v-model</code>是<code>value+input方法</code>的语法糖</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">:value</span>=<span class="string">&quot;&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;check&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以自己重新定义<code>v-model</code>的含义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;el-checkbox&#x27;</span>,&#123;</span><br><span class="line">    template:<span class="string">`&lt;input type=&quot;checkbox&quot; :checked=&quot;check&quot; @change=&quot;$emit(&#x27;change&#x27;,$event.target.checked)&quot;&gt;`</span>,</span><br><span class="line">    model:&#123;</span><br><span class="line">        prop:<span class="string">&#x27;check&#x27;</span>, <span class="comment">// 更改默认的value的名字</span></span><br><span class="line">        event:<span class="string">&#x27;change&#x27;</span> <span class="comment">// 更改默认的方法名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        check: <span class="built_in">Boolean</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="原理-11"><a href="#原理-11" class="headerlink" title="原理:"></a>原理:</h3><ul>
<li>会将组件的<code>v-model</code>默认转化成value+input</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ele = VueTemplateCompiler.compile(<span class="string">&#x27;&lt;el-checkbox v-model=&quot;check&quot;&gt;&lt;/el-checkbox&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// with(this) &#123;</span></span><br><span class="line"><span class="comment">//     return _c(&#x27;el-checkbox&#x27;, &#123;</span></span><br><span class="line"><span class="comment">//         model: &#123;</span></span><br><span class="line"><span class="comment">//             value: (check),</span></span><br><span class="line"><span class="comment">//             callback: function ($$v) &#123;</span></span><br><span class="line"><span class="comment">//                 check = $$v</span></span><br><span class="line"><span class="comment">//             &#125;,</span></span><br><span class="line"><span class="comment">//             expression: &quot;check&quot;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>core/vdom/create-component.js  line:155</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformModel</span> (<span class="params">options, data: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prop = (options.model &amp;&amp; options.model.prop) || <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> event = (options.model &amp;&amp; options.model.event) || <span class="string">&#x27;input&#x27;</span></span><br><span class="line">  ;(data.attrs || (data.attrs = &#123;&#125;))[prop] = data.model.value</span><br><span class="line">  <span class="keyword">const</span> on = data.on || (data.on = &#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> existing = on[event]</span><br><span class="line">  <span class="keyword">const</span> callback = data.model.callback</span><br><span class="line">  <span class="keyword">if</span> (isDef(existing)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">Array</span>.isArray(existing)</span><br><span class="line">        ? existing.indexOf(callback) === -<span class="number">1</span></span><br><span class="line">        : existing !== callback</span><br><span class="line">    ) &#123;</span><br><span class="line">      on[event] = [callback].concat(existing)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    on[event] = callback</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原生的 <code>v-model</code>，会根据标签的不同生成不同的事件和属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ele = VueTemplateCompiler.compile(<span class="string">&#x27;&lt;input v-model=&quot;value&quot;/&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;input&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        directives: [&#123;</span></span><br><span class="line"><span class="comment">            name: &quot;model&quot;,</span></span><br><span class="line"><span class="comment">            rawName: &quot;v-model&quot;,</span></span><br><span class="line"><span class="comment">            value: (value),</span></span><br><span class="line"><span class="comment">            expression: &quot;value&quot;</span></span><br><span class="line"><span class="comment">        &#125;],</span></span><br><span class="line"><span class="comment">        domProps: &#123;</span></span><br><span class="line"><span class="comment">            &quot;value&quot;: (value)</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        on: &#123;</span></span><br><span class="line"><span class="comment">            &quot;input&quot;: function ($event) &#123;</span></span><br><span class="line"><span class="comment">                if ($event.target.composing) return;</span></span><br><span class="line"><span class="comment">                value = $event.target.value</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译时：不同的标签解析出的内容不一样 <code>platforms/web/compiler/directives/model.js</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">    genComponentModel(el, value, modifiers)</span><br><span class="line">    <span class="comment">// component v-model doesn&#x27;t need extra runtime</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">    genSelect(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> &amp;&amp; type === <span class="string">&#x27;checkbox&#x27;</span>) &#123;</span><br><span class="line">    genCheckboxModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> &amp;&amp; type === <span class="string">&#x27;radio&#x27;</span>) &#123;</span><br><span class="line">    genRadioModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> || tag === <span class="string">&#x27;textarea&#x27;</span>) &#123;</span><br><span class="line">    genDefaultModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!config.isReservedTag(tag)) &#123;</span><br><span class="line">    genComponentModel(el, value, modifiers)</span><br><span class="line">    <span class="comment">// component v-model doesn&#x27;t need extra runtime</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时：会对元素处理一些关于输入法的问题 <code>platforms/web/runtime/directives/model.js</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inserted (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.tag === <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// #6903</span></span><br><span class="line">      <span class="keyword">if</span> (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) &#123;</span><br><span class="line">        mergeVNodeHook(vnode, <span class="string">&#x27;postpatch&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          directive.componentUpdated(el, binding, vnode)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setSelected(el, binding, vnode.context)</span><br><span class="line">      &#125;</span><br><span class="line">      el._vOptions = [].map.call(el.options, getValue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vnode.tag === <span class="string">&#x27;textarea&#x27;</span> || isTextInputType(el.type)) &#123;</span><br><span class="line">      el._vModifiers = binding.modifiers</span><br><span class="line">      <span class="keyword">if</span> (!binding.modifiers.lazy) &#123;</span><br><span class="line">        el.addEventListener(<span class="string">&#x27;compositionstart&#x27;</span>, onCompositionStart)</span><br><span class="line">        el.addEventListener(<span class="string">&#x27;compositionend&#x27;</span>, onCompositionEnd)</span><br><span class="line">        <span class="comment">// Safari &lt; 10.2 &amp; UIWebView doesn&#x27;t fire compositionend when</span></span><br><span class="line">        <span class="comment">// switching focus before confirming composition choice</span></span><br><span class="line">        <span class="comment">// this also fixes the issue where some browsers e.g. iOS Chrome</span></span><br><span class="line">        <span class="comment">// fires &quot;change&quot; instead of &quot;input&quot; on autocomplete.</span></span><br><span class="line">        el.addEventListener(<span class="string">&#x27;change&#x27;</span>, onCompositionEnd)</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (isIE9) &#123;</span><br><span class="line">          el.vmodel = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-Vue中v-html会导致哪些问题"><a href="#22-Vue中v-html会导致哪些问题" class="headerlink" title="22.Vue中v-html会导致哪些问题?"></a>22.<code>Vue</code>中<code>v-html</code>会导致哪些问题?</h2><h3 id="理解-11"><a href="#理解-11" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>可能会导致<code>xss</code>攻击</li>
<li><code>v-html</code>会替换掉标签内部的子元素</li>
</ul>
<h3 id="原理-12"><a href="#原理-12" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r = template.compile(<span class="string">`&lt;div v-html=&quot;&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;&quot;&gt;&lt;/div&gt;`</span>)</span><br><span class="line"><span class="comment">// with(this)&#123;return _c(&#x27;div&#x27;,&#123;domProps:&#123;&quot;innerHTML&quot;:_s(&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;)&#125;&#125;)&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r.render);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _c 定义在core/instance/render.js</span></span><br><span class="line"><span class="comment">// _s 定义在core/instance/render-helpers/index,js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key === <span class="string">&#x27;textContent&#x27;</span> || key === <span class="string">&#x27;innerHTML&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vnode.children) vnode.children.length = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (cur === oldProps[key]) <span class="keyword">continue</span></span><br><span class="line">      <span class="comment">// #6601 work around Chrome version &lt;= 55 bug where single textNode</span></span><br><span class="line">      <span class="comment">// replaced by innerHTML/textContent retains its parentNode property</span></span><br><span class="line">      <span class="keyword">if</span> (elm.childNodes.length === <span class="number">1</span>) &#123;</span><br><span class="line">        elm.removeChild(elm.childNodes[<span class="number">0</span>])</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-Vue父子组件生命周期调用顺序"><a href="#23-Vue父子组件生命周期调用顺序" class="headerlink" title="23.  Vue父子组件生命周期调用顺序"></a>23.  <code>Vue</code>父子组件生命周期调用顺序</h2><h3 id="理解-12"><a href="#理解-12" class="headerlink" title="理解:"></a>理解:</h3><p>组件的调用顺序都是先父后子,渲染完成的顺序肯定是先子后父</p>
<p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父</p>
<h3 id="原理-13"><a href="#原理-13" class="headerlink" title="原理:"></a>原理:</h3><p><img src="./2020/10/21/vue-souce/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1582263422513.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = [] <span class="comment">// 定义收集所有组件的insert hook方法的数组</span></span><br><span class="line">    <span class="comment">// somthing ...</span></span><br><span class="line">    createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">    )</span><br><span class="line">	<span class="comment">// somthing...</span></span><br><span class="line">    <span class="comment">// 最终会依次调用收集的insert hook</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">    insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    nested,</span></span></span><br><span class="line"><span class="function"><span class="params">    ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">    index</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// createChildren会递归创建儿子组件</span></span><br><span class="line">        createChildren(vnode, children, insertedVnodeQueue) </span><br><span class="line">        <span class="comment">// something...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将组件的vnode插入到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">      cbs.create[i](emptyNode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    i = vnode.data.hook <span class="comment">// Reuse variable</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i.create)) i.create(emptyNode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (isDef(i.insert)) insertedVnodeQueue.push(vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// insert方法中会依次调用mounted方法</span></span><br><span class="line">insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// delay insert hooks for component root nodes, invoke them after the</span></span><br><span class="line">     <span class="comment">// element is really inserted</span></span><br><span class="line">     <span class="keyword">if</span> (isTrue(initial) &amp;&amp; isDef(vnode.parent)) &#123;</span><br><span class="line">         vnode.parent.data.pendingInsert = queue</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">             queue[i].data.hook.insert(queue[i]); <span class="comment">// 调用insert方法</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>) <span class="comment">// </span></span><br><span class="line">    <span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line">    vm.__patch__(vm._vnode, <span class="literal">null</span>) <span class="comment">// 先销毁儿子 </span></span><br><span class="line">    <span class="comment">// fire destroyed hook</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-Vue组件如何通信"><a href="#24-Vue组件如何通信" class="headerlink" title="24.Vue组件如何通信?"></a>24.<code>Vue</code>组件如何通信?</h2><ul>
<li>父子间通信  父-&gt;子通过<code>props</code>、子-&gt; 父<code>$on、$emit</code></li>
<li>获取父子组件实例的方式<code>$parent、$children</code></li>
<li>在父组件中提供数据子组件进行消费 <code>Provide、inject</code></li>
<li><code>Ref</code>获取实例的方式调用组件的属性或者方法</li>
<li><code>Event Bus</code> 实现跨组件通信</li>
<li><code>Vuex </code>状态管理实现通信</li>
</ul>
<h2 id="25-Vue中相同逻辑如何抽离？"><a href="#25-Vue中相同逻辑如何抽离？" class="headerlink" title="25.Vue中相同逻辑如何抽离？"></a>25.<code>Vue</code>中相同逻辑如何抽离？</h2><ul>
<li><code>Vue.mixin</code>用法 给组件每个生命周期，函数等都混入一些公共逻辑</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.options = mergeOptions(<span class="built_in">this</span>.options, mixin); <span class="comment">// 将当前定义的属性合并到每个组件中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parent: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  child: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.extends) &#123; <span class="comment">// 递归合并extends</span></span><br><span class="line">      parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.mixins) &#123; <span class="comment">// 递归合并mixin</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125; <span class="comment">// 属性及生命周期的合并</span></span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">      mergeField(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    <span class="comment">// 调用不同属性合并策略进行合并</span></span><br><span class="line">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-为什么要使用异步组件？"><a href="#26-为什么要使用异步组件？" class="headerlink" title="26.为什么要使用异步组件？"></a>26.为什么要使用异步组件？</h2><h3 id="理解-13"><a href="#理解-13" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li><p>如果组件功能多打包出的结果会变大，我可以采用异步的方式来加载组件。主要依赖<code>import()</code>这个语法，可以实现文件的分割加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">	<span class="function"><span class="title">AddCustomerSchedule</span>(<span class="params">resolve</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>([<span class="string">&quot;../components/AddCustomer&quot;</span>], resolve);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="原理-14"><a href="#原理-14" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resolveAsyncComponent(asyncFactory, baseCtor) <span class="comment">// 默认调用此函数时返回undefiend</span></span><br><span class="line">    <span class="comment">// 第二次渲染时Ctor不为undefined</span></span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder( <span class="comment">// 渲染占位符 空虚拟节点</span></span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  factory: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.resolved)) &#123; <span class="comment">// 3.在次渲染时可以拿到获取的最新组件</span></span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">      <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        forceRender(<span class="literal">true</span>) <span class="comment">//2. 强制更新视图重新渲染</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">          factory.error = <span class="literal">true</span></span><br><span class="line">          forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> res = factory(resolve, reject)<span class="comment">// 1.将resolve方法和reject方法传入，用户调用resolve方法后</span></span><br><span class="line">  sync = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> factory.resolved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-什么是作用域插槽"><a href="#27-什么是作用域插槽" class="headerlink" title="27.什么是作用域插槽?"></a>27.什么是作用域插槽?</h2><h3 id="理解-14"><a href="#理解-14" class="headerlink" title="理解:"></a>理解:</h3><h4 id="1-插槽："><a href="#1-插槽：" class="headerlink" title="1.插槽："></a>1.插槽：</h4><ul>
<li>创建组件虚拟节点时，会将组件的儿子的虚拟节点保存起来。当初始化组件时,通过插槽属性将儿子进行分类 <code>&#123;a:[vnode],b[vnode]&#125;</code></li>
<li>渲染组件时会拿对应的slot属性的节点进行替换操作。（插槽的作用域为父组件）</li>
</ul>
<h4 id="2-作用域插槽"><a href="#2-作用域插槽" class="headerlink" title="2.作用域插槽:"></a>2.作用域插槽:</h4><ul>
<li>作用域插槽在解析的时候，不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。（插槽的作用域为子组件）</li>
</ul>
<h3 id="原理-15"><a href="#原理-15" class="headerlink" title="原理:"></a>原理:</h3><p><img src="./2020/10/21/vue-souce/%E6%8F%92%E6%A7%BD.png"></p>
<h4 id="1-插槽"><a href="#1-插槽" class="headerlink" title="1.插槽:"></a>1.插槽:</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;my-component&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot=&quot;header&quot;&gt;node&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;react&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot=&quot;footer&quot;&gt;vue&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/my-component&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;my-component&#x27;, [_c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        attrs: &#123;</span></span><br><span class="line"><span class="comment">            &quot;slot&quot;: &quot;header&quot;</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        slot: &quot;header&quot;</span></span><br><span class="line"><span class="comment">    &#125;, [_v(&quot;node&quot;)]), _v(&quot; &quot;), _c(&#x27;div&#x27;, [_v(&quot;react&quot;)]), _v(&quot; &quot;), _c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        attrs: &#123;</span></span><br><span class="line"><span class="comment">            &quot;slot&quot;: &quot;footer&quot;</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        slot: &quot;footer&quot;</span></span><br><span class="line"><span class="comment">    &#125;, [_v(&quot;vue&quot;)])])</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, [_t(&quot;header&quot;), _v(&quot; &quot;), _t(&quot;footer&quot;), _v(&quot; &quot;), _t(&quot;default&quot;)], 2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// _t定义在 core/instance/render-helpers/index.js</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽:"></a>作用域插槽:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;app&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot-scope=&quot;msg&quot; slot=&quot;footer&quot;&gt;&#123;&#123;msg.a&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/app&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;app&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        scopedSlots: _u([&#123; // 作用域插槽的内容会被渲染成一个函数</span></span><br><span class="line"><span class="comment">            key: &quot;footer&quot;,</span></span><br><span class="line"><span class="comment">            fn: function (msg) &#123;</span></span><br><span class="line"><span class="comment">                return _c(&#x27;div&#x27;, &#123;&#125;, [_v(_s(msg.a))])</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;])</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"></span><br><span class="line">VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;footer&quot; a=&quot;1&quot; b=&quot;2&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, [_t(&quot;footer&quot;, null, &#123;</span></span><br><span class="line"><span class="comment">        &quot;a&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="comment">        &quot;b&quot;: &quot;2&quot;</span></span><br><span class="line"><span class="comment">    &#125;)], 2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h2 id="28-谈谈你对-keep-alive-的了解？"><a href="#28-谈谈你对-keep-alive-的了解？" class="headerlink" title="28.谈谈你对 keep-alive 的了解？"></a>28.谈谈你对 keep-alive 的了解？</h2><h3 id="理解-15"><a href="#理解-15" class="headerlink" title="理解:"></a>理解:</h3><p><code>keep-alive</code>可以实现组件的缓存，当组件切换时不会对当前组件进行卸载,常用的2个属性<code>include</code>/<code>exclude</code>,2个生命周期<code>activated</code>,<code>deactivated</code></p>
<h3 id="原理-16"><a href="#原理-16" class="headerlink" title="原理:"></a>原理:</h3><blockquote>
<p><code>core/components/keep-alive.js</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>, <span class="comment">// 抽象组件</span></span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 创建缓存列表</span></span><br><span class="line">    <span class="built_in">this</span>.keys = [] <span class="comment">// 创建缓存组件的key列表</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123; <span class="comment">// keep-alive销毁时 会清空所有的缓存和key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.cache) &#123; <span class="comment">// 循环销毁</span></span><br><span class="line">      pruneCacheEntry(<span class="built_in">this</span>.cache, key, <span class="built_in">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted () &#123; <span class="comment">// 会监控include 和 include属性 进行组件的缓存处理</span></span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default <span class="comment">// 会默认拿插槽</span></span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot) <span class="comment">// 只缓存第一个组件</span></span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="comment">// 取出组件的名字</span></span><br><span class="line">      <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="comment">// 判断是否缓存</span></span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        : vnode.key <span class="comment">// 如果组件没key 就自己通过 组件的标签和key和cid 拼接一个key</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance <span class="comment">//  直接拿到组件实例</span></span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key) <span class="comment">// 删除当前的  [b,c,d,e,a]   // LRU 最近最久未使用法</span></span><br><span class="line">        keys.push(key) <span class="comment">// 并将key放到后面[b,a]</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[key] = vnode <span class="comment">// 缓存vnode</span></span><br><span class="line">        keys.push(key) <span class="comment">// 将key 存入</span></span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123; <span class="comment">// 缓存的太多超过了max 就需要删除掉</span></span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode) <span class="comment">// 要删除第0个 但是现在渲染的就是第0个</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span> <span class="comment">// 并且标准keep-alive下的组件是一个缓存组件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>]) <span class="comment">// 返回当前的虚拟节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-Vue中常见性能优化"><a href="#29-Vue中常见性能优化" class="headerlink" title="29.Vue中常见性能优化"></a>29.<code>Vue</code>中常见性能优化</h2><h3 id="1-编码优化"><a href="#1-编码优化" class="headerlink" title="1.编码优化:"></a>1.编码优化:</h3><ul>
<li><p>1.不要将所有的数据都放在data中，data中的数据都会增加getter和setter，会收集对应的watcher </p>
</li>
<li><p>2.<code>vue</code> 在 v-for 时给每项元素绑定事件需要用事件代理</p>
</li>
<li><p>3.<code>SPA</code>页面采用keep-alive缓存组件</p>
</li>
<li><p>4.拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染  )</p>
</li>
<li><p>5.<code>v-if</code> 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show </p>
</li>
<li><p>6.<code>key</code>保证唯一性 ( 默认<code>vue</code>会采用就地复用策略 )</p>
</li>
<li><p>7.<code>Object.freeze</code> 冻结数据 </p>
</li>
<li><p>8.合理使用路由懒加载、异步组件</p>
</li>
<li><p>9.尽量采用runtime运行时版本</p>
</li>
<li><p>10.数据持久化的问题 （防抖、节流）</p>
</li>
</ul>
<h3 id="2-Vue加载性能优化"><a href="#2-Vue加载性能优化" class="headerlink" title="2.Vue加载性能优化:"></a>2.<code>Vue</code>加载性能优化:</h3><ul>
<li><p>第三方模块按需导入 (<code>babel-plugin-component</code>) </p>
</li>
<li><p>滚动到可视区域动态加载  ( <a href="https://tangbc.github.io/vue-virtual-scroll-list">https://tangbc.github.io/vue-virtual-scroll-list</a> )</p>
</li>
<li><p>图片懒加载  (<a href="https://github.com/hilongjw/vue-lazyload.git">https://github.com/hilongjw/vue-lazyload.git</a>)</p>
</li>
</ul>
<h3 id="3-用户体验"><a href="#3-用户体验" class="headerlink" title="3.用户体验:"></a>3.用户体验:</h3><ul>
<li><code>app-skeleton</code>骨架屏</li>
<li><code>app-shell</code>app壳</li>
<li><code>pwa</code></li>
</ul>
<h3 id="4-SEO优化："><a href="#4-SEO优化：" class="headerlink" title="4.SEO优化："></a>4.<code>SEO</code>优化：</h3><ul>
<li>预渲染插件 <code>prerender-spa-plugin</code></li>
<li>服务端渲染<code>ssr</code></li>
</ul>
<h3 id="5-打包优化"><a href="#5-打包优化" class="headerlink" title="5.打包优化:"></a>5.打包优化:</h3><ul>
<li>使用<code>cdn</code>的方式加载第三方模块 </li>
<li>多线程打包 <code>happypack </code></li>
<li><code>splitChunks</code> 抽离公共文件 </li>
<li><code>sourceMap</code>生成 </li>
</ul>
<h3 id="6-缓存，压缩"><a href="#6-缓存，压缩" class="headerlink" title="6.缓存，压缩"></a>6.缓存，压缩</h3><ul>
<li>客户端缓存、服务端缓存</li>
<li>服务端<code>gzip</code>压缩</li>
</ul>
<h2 id="30-Vue3-0你知道有哪些改进"><a href="#30-Vue3-0你知道有哪些改进" class="headerlink" title="30.Vue3.0你知道有哪些改进?"></a>30.<code>Vue3.0</code>你知道有哪些改进?</h2><ul>
<li><p><code>Vue3</code>采用了TS来编写</p>
</li>
<li><p>支持 <code>Composition API </code></p>
</li>
<li><p><code>Vue3</code>中响应式数据原理改成<code>proxy</code></p>
</li>
<li><p><code> vdom</code>的对比算法更新，只更新<code>vdom</code>的绑定了动态数据的部分</p>
</li>
</ul>
<h2 id="31-实现hash路由和history路由"><a href="#31-实现hash路由和history路由" class="headerlink" title="31.实现hash路由和history路由"></a>31.实现<code>hash</code>路由和<code>history</code>路由</h2><ul>
<li><code>onhashchange</code></li>
<li><code>history.pushState</code></li>
</ul>
<h2 id="32-Vue-Router中导航守卫有哪些？"><a href="#32-Vue-Router中导航守卫有哪些？" class="headerlink" title="32.Vue-Router中导航守卫有哪些？"></a>32.<code>Vue-Router</code>中导航守卫有哪些？</h2><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫 <code>beforeRouteLeave</code>。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>
</ol>
<h2 id="33-action-和-mutation区别"><a href="#33-action-和-mutation区别" class="headerlink" title="33.action 和 mutation区别"></a>33.<code>action</code> 和 <code>mutation</code>区别</h2><ul>
<li><code>mutation</code>是同步更新数据(内部会进行是否为异步方式更新数据的检测)</li>
<li><code>action</code> 异步操作，可以获取数据后调佣<code>mutation</code>提交最终数据</li>
</ul>
<h2 id="34-简述Vuex工作原理"><a href="#34-简述Vuex工作原理" class="headerlink" title="34.简述Vuex工作原理"></a>34.简述<code>Vuex</code>工作原理</h2><p><img src="https://vuex.vuejs.org/vuex.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>vue代码解析</category>
      </categories>
      <tags>
        <tag>vue代码解析</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOM&amp;BOM面试题</title>
    <url>/2020/10/29/DOM&amp;BOM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>DOM&amp;BOM面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器原理</title>
    <url>/2021/05/14/browersRander/</url>
    <content><![CDATA[<h2 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h2><ul>
<li><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html">浏览器原理</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>浏览器原理</category>
      </categories>
      <tags>
        <tag>浏览器原理</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交规范</title>
    <url>/2022/08/02/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">emji</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">feat</td>
<td align="center">✨</td>
<td align="center">引入新功能</td>
</tr>
<tr>
<td align="center">fix</td>
<td align="center">🐛</td>
<td align="center">修复 bug</td>
</tr>
<tr>
<td align="center">style</td>
<td align="center">💄</td>
<td align="center">更新 UI 样式文按键</td>
</tr>
<tr>
<td align="center">format</td>
<td align="center">🥚</td>
<td align="center">格式化代码</td>
</tr>
<tr>
<td align="center">docs</td>
<td align="center">📝</td>
<td align="center">添加/更新文档</td>
</tr>
<tr>
<td align="center">perf</td>
<td align="center">👌</td>
<td align="center">提高性能/优化</td>
</tr>
<tr>
<td align="center">init</td>
<td align="center">🎉</td>
<td align="center">初次提交/初始化项目</td>
</tr>
<tr>
<td align="center">test</td>
<td align="center">✅</td>
<td align="center">增加测试代码</td>
</tr>
<tr>
<td align="center">refactor</td>
<td align="center">🎨</td>
<td align="center">改进代码结构/代码格式</td>
</tr>
<tr>
<td align="center">patch</td>
<td align="center">🚑</td>
<td align="center">添加重要补丁</td>
</tr>
<tr>
<td align="center">file</td>
<td align="center">📦</td>
<td align="center">添加新文件</td>
</tr>
<tr>
<td align="center">publish</td>
<td align="center">🚀</td>
<td align="center">发布新版本</td>
</tr>
<tr>
<td align="center">tag</td>
<td align="center">📌</td>
<td align="center">发布新版本</td>
</tr>
<tr>
<td align="center">config</td>
<td align="center">🔧</td>
<td align="center">修改配置文件</td>
</tr>
<tr>
<td align="center">git</td>
<td align="center">🙈</td>
<td align="center">添加或修改.gitignore 文件</td>
</tr>
</tbody></table>
<h2 id="git-commit-lint-vscode"><a href="#git-commit-lint-vscode" class="headerlink" title="git-commit-lint-vscode"></a>git-commit-lint-vscode</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>git提交规范</category>
      </categories>
      <tags>
        <tag>git提交规范</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>git init</td>
<td>git仓库初始化</td>
</tr>
<tr>
<td>git clone <giturl></giturl></td>
<td>复制现有仓库</td>
</tr>
<tr>
<td>git status</td>
<td>查看git仓库状态</td>
</tr>
<tr>
<td>git log</td>
<td>查看commit列表记录<br>–oneline  浓缩成一行一条记录<br>–stat         输出文件改动的统计数据<br>-p               输出改动文件的具体内容<br>-w              忽略空格的修改和-p一起用</td>
</tr>
<tr>
<td>git show <SHA></SHA></td>
<td>查看commit具体记录，也有–stat,-p,-w的配置</td>
</tr>
<tr>
<td>git add .</td>
<td>将工作区全部改动提交到暂存区</td>
</tr>
<tr>
<td>git commit</td>
<td>将暂存区改动提交到版本库<br>-m             添加本次改动的title<br>–amend  更改最后一个commit包括缓存区改动和改动的title</td>
</tr>
<tr>
<td>git diff</td>
<td>查看工作区修改</td>
</tr>
<tr>
<td>git tag -a <tagname></tagname></td>
<td>设置commit标签<br>-a               设置标签名<br>-d               删除标签名</td>
</tr>
<tr>
<td>git checkout <Branch></Branch></td>
<td>切换分支</td>
</tr>
<tr>
<td>git checkout -b &lt;本地分支名&gt; &lt;远程分支名&gt;</td>
<td>创建本地分支并关联远程分支</td>
</tr>
<tr>
<td>git checkout -t &lt;远程分支名&gt;</td>
<td>创建本地分支并自动关联远程分支，本地分支名和远程分支一致</td>
</tr>
<tr>
<td>git checkout .</td>
<td>撤销工作区的修改(只能撤销在已有文件上的修改)</td>
</tr>
<tr>
<td>git restore .</td>
<td>撤销工作区的修改</td>
</tr>
<tr>
<td>git clean -df</td>
<td>删除工作区新增的文件</td>
</tr>
<tr>
<td>git clean -xdf</td>
<td>删除工作区新增的文件和文件夹</td>
</tr>
<tr>
<td>git merge <branch></branch></td>
<td>合并分支</td>
</tr>
<tr>
<td>git revert <sha></sha></td>
<td>还原，并向前提交一个新的commit来保存还原的内容</td>
</tr>
<tr>
<td>git reset</td>
<td>重置，会删除commit，慎用<br>–hard  会清空工作目录和暂存区的改动<br>–soft    则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。<br>–mixed  默认行为，保留工作目录，并且清空暂存区<br>HEAD^表示当前版本<br>HEAD^^上上一个版本<br>HEAD~2上上一个版本</td>
</tr>
<tr>
<td>git reset HEAD^</td>
<td>使用场景：已使用git add . 命令，未使用git commit -m ‘’命令</td>
</tr>
<tr>
<td>git reset –soft HEAD^</td>
<td>使用场景：已使用git commit -m ‘’命令，撤销之后会把修改放在暂存区</td>
</tr>
<tr>
<td>git reset  –hard  HEAD^</td>
<td>使用场景：已使用git commit -m，撤销之后不会保留任何更改，比如打包之后提交了commit，想重新打包，则可以使用</td>
</tr>
<tr>
<td>git reset HEAD</td>
<td>撤销缓存区的修改，撤销上一次add</td>
</tr>
<tr>
<td>git remote -v</td>
<td>远程库查询</td>
</tr>
<tr>
<td>git remote add origin <url></url></td>
<td>添加远程库</td>
</tr>
<tr>
<td>git remote remove <origin></origin></td>
<td>删除远程库</td>
</tr>
<tr>
<td>git push origin –delete <branch></branch></td>
<td>删除远程分支</td>
</tr>
<tr>
<td>git push &lt;分支名&gt;</td>
<td>推送本地分支到远程分支</td>
</tr>
<tr>
<td>git push origin –delete <branch></branch></td>
<td>删除远程分支</td>
</tr>
<tr>
<td>git push origin –delete &lt;分支名&gt;</td>
<td>删除远程分支</td>
</tr>
<tr>
<td>git config –global core.autocrlf false</td>
<td>禁用换行方式转换</td>
</tr>
<tr>
<td>git push -u origin master</td>
<td>跟踪远程分支</td>
</tr>
<tr>
<td>git push -f</td>
<td>强制推送</td>
</tr>
<tr>
<td>git pull &lt;分支名&gt;</td>
<td>拉取远程分支到本地分支</td>
</tr>
<tr>
<td>git pull -u origin dev</td>
<td>拉取远程分支</td>
</tr>
<tr>
<td>git branch</td>
<td>列出所有分支(仅本地分支)</td>
</tr>
<tr>
<td>git branch -a</td>
<td>列出所有分支(包括远程分支)</td>
</tr>
<tr>
<td>git branch -d &lt;分支名&gt;</td>
<td>删除分支</td>
</tr>
<tr>
<td>git branch -D &lt;分支名&gt;</td>
<td>强行删除分支</td>
</tr>
<tr>
<td>git branch &lt;分支名&gt;</td>
<td>创建新分支</td>
</tr>
<tr>
<td>git branch -m &lt;旧分支名&gt;  &lt;新分支名&gt;</td>
<td>重命名分支</td>
</tr>
<tr>
<td>git branch -vv</td>
<td>查看本地分支与远程分支的关联分支</td>
</tr>
<tr>
<td>git clean -n</td>
<td>显示将要删除的新增文件，不显示新增的文件夹及包含的文件</td>
</tr>
<tr>
<td>git clean -f</td>
<td>删除新增文件，不删除新增的文件夹及包含的文件</td>
</tr>
<tr>
<td>git clean -df</td>
<td>删除新增文件以及新增的文件夹和其包含的文件</td>
</tr>
<tr>
<td>git fetch &lt;分支名&gt;</td>
<td>获取远端的更新，但不进行合并</td>
</tr>
<tr>
<td>git config –global core.quotepath false</td>
<td>git中文显示数字的问题</td>
</tr>
<tr>
<td>git log –pretty=oneline 文件名 （文件名是文件路径+文件名，输入完整）</td>
<td>git查看某个文件的提交历史</td>
</tr>
<tr>
<td>git show 某次commit 的哈希值  文件名</td>
<td>git查看某个文件某次提交的修改</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>git config –global gui.encoding utf-8</td>
<td></td>
</tr>
<tr>
<td>git config –global i18n.commit.encoding utf-8</td>
<td></td>
</tr>
<tr>
<td>git config –global i18n.logoutputencoding utf-8</td>
<td></td>
</tr>
<tr>
<td>$env:LESSCHARSET=’utf-8’</td>
<td>解决 powerShell git log显示中文的问题</td>
</tr>
<tr>
<td>git config –global core.autocrlf false</td>
<td>git提示LF CRLF转换的警告</td>
</tr>
<tr>
<td>git blame -L <lineStart>,<lineEnd> &lt;path+fileName&gt;</lineEnd></lineStart></td>
<td>git查看部分行的历史改动记录</td>
</tr>
<tr>
<td>git config –global core.quotepath false</td>
<td>解决中文显示成数字的bug</td>
</tr>
<tr>
<td>GIT_MERGE_AUTOEDIT=no      export GIT_MERGE_AUTOEDIT</td>
<td>用来解决git bash 合并时自动打开VIM编辑器的问题</td>
</tr>
<tr>
<td>git blame</td>
<td>找到具体代码的责任人</td>
</tr>
</tbody></table>
<a id="more"></a>


<h3 id="git恢复某个文件到上一个提交版本"><a href="#git恢复某个文件到上一个提交版本" class="headerlink" title="git恢复某个文件到上一个提交版本"></a>git恢复某个文件到上一个提交版本</h3><p>git提交了比较多的文件到远程，但是在合并时发现其中有一个文件合并有冲突或者某个原因不想修改该文件了，那就需要单独把这个文件回退到上一个提交版本状态。方法如下：</p>
<p>1.首先查看一下该文件的commit记录：git log 文件，例如 git log src/index.java</p>
<p>2.找到需要提交到上一个版本的commit号，然后checkout该文件的上一版本，输入下面的指令：</p>
<p>git checkout [commit id] 文件，例如 git checkout a57fb4b474888f0db4cba18de2180496 src/index.java</p>
<p>3.然后将checkout的版本提交到本地</p>
<p>git commit -m “回退到上一版本”</p>
<p>4.最后将改变提交到分支远程：</p>
<p>git push origin 分支名</p>
<p>这样此文件本地和远程都是上一版本内容</p>
<h1 id="git合并特定的commit"><a href="#git合并特定的commit" class="headerlink" title="git合并特定的commit"></a>git合并特定的commit</h1><p>多版本并行开发的时候一般都是一个版本一个分支，验收通过上线的时候将该分支直接合并到生产环境中</p>
<p>但是有的时候我们只想合并某一个或几个commit，来满足业务的需求(这个功能今晚上，其他可以晚点上)</p>
<p>使用git cherry-pick <commit id> 合并特定的commit，操作对象是commit而非分支</commit></p>
<p>commit id 可以是来自任何分支，他不关心分支，因为commit id 总是唯一的</p>
<p>使用git log来查看commit id，可以是完整的commit id，也可以是id前6位</p>
<p>实际演示</p>
<p>本地有两个分支，master和uat，我们将uat分支的commitid=9494f1的记录合并到master上，而不合并整个分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b uat  &#x2F;&#x2F; 创建uat分支</span><br><span class="line">... &#x2F;&#x2F; 修改两次，提交两次commit</span><br><span class="line">git log   &#x2F;&#x2F; 记录两次修改的commit   第一次修改为9494f1 第二次修改为d3450d</span><br><span class="line">git checkout master &#x2F;&#x2F; 切回master分支</span><br><span class="line">git cherry-pick 9494f1  &#x2F;&#x2F; 合并commit</span><br><span class="line">git log &#x2F;&#x2F; 发现commit已合并</span><br></pre></td></tr></table></figure>

<h2 id="git贮藏功能使用场景"><a href="#git贮藏功能使用场景" class="headerlink" title="git贮藏功能使用场景"></a>git贮藏功能使用场景</h2><p>1、如果你某个分支开发过程中，这个分支的内容是要在本月月底上线的，但是生产上已经出现了一个重大bug，需要你立马去修复。你在分支开发的内容已经开发一部分了，工作区有内容是不能切换分支的，这个时候就可以用到贮藏的功能了</p>
<h2 id="git贮藏功能使用流程（sourceTree）"><a href="#git贮藏功能使用流程（sourceTree）" class="headerlink" title="git贮藏功能使用流程（sourceTree）"></a>git贮藏功能使用流程（sourceTree）</h2><p>第一步：将修改一半的文件先贮藏起来，以防以后需要使用</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-1.png" alt="1574129769274"></p>
<p>选中修改的文件，点击贮藏按钮</p>
<p>第二步：再输入框中输入文字描述本次贮藏，然后点击确定按钮（之后就可以进行修改bug的工作）</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-2.png" alt="1574129926356"></p>
<p>第三步：应用贮藏功能</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-3.png" alt="1574130371631"></p>
<p>选择分支=&gt;选择贮藏=&gt;点击鼠标右键=&gt;应用贮藏区=&gt;确定=&gt;恢复为修改一般的初始状态</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-4.png" alt="1574130600911"></p>
<h2 id="git贮藏功能使用流程（git-shell）"><a href="#git贮藏功能使用流程（git-shell）" class="headerlink" title="git贮藏功能使用流程（git shell）"></a>git贮藏功能使用流程（git shell）</h2><ul>
<li>贮藏</li>
</ul>
<p>git stash：将当前工作贮藏</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-6.png" alt="1574130796152"></p>
<p>git stash save  “描述内容”:给每个stash加一个message</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/own\biji\notes\images\git贮藏\git-5.png" alt="1574133235403"></p>
<ul>
<li>查看贮藏列表</li>
</ul>
<p>git stash list：查看贮藏的列表</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-7.png" alt="1574131196038"></p>
<ul>
<li>应用</li>
</ul>
<p>git stash apply:将缓存堆栈中的第一个stash多次应用到工作目录中，但并不删除stash拷贝</p>
<p>git stash apply stash@{0} ：恢复贮藏序列为0的贮藏中的工作内容,但并不删除stash拷贝</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-8.png" alt="1574131410296"></p>
<ul>
<li>删除</li>
</ul>
<p>git stash drop：将缓存堆栈中的第一个stash删除</p>
<p>git stash drop stash@{0}：删除贮藏序列为0的贮藏中的工作内容</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/own\biji\notes\images\git贮藏\git-9.png" alt="1574132441468"></p>
<p>git stash clear：删除所有缓存的stash</p>
<ul>
<li>应用并删除</li>
</ul>
<p>git stash pop：将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</p>
<p>git stash pop stash@{0}：将贮藏序列为0的贮藏中的工作内容应用并且删除</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-10.png" alt="1574133389346"></p>
<ul>
<li>查看具体的修改记录</li>
</ul>
<p>git stash show:查看缓存堆栈中的第一个stash的diff</p>
<p>git stash show stash@{0}:查看贮藏序列为0的stash的diff</p>
<p><img src="/2021/12/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/.%5Cimages%5Cgit%E8%B4%AE%E8%97%8F%5Cgit-11.png" alt="1574133731206"></p>
<h2 id="git最基本的6个操作"><a href="#git最基本的6个操作" class="headerlink" title="git最基本的6个操作"></a>git最基本的6个操作</h2><ul>
<li>创建本地仓库<br> 创建.gitignore配置文件<br> git init<br> git add *<br> git commit -m “xxx”</li>
<li>创建远程仓库<br> New Repository<br> 指定名称<br> 创建</li>
<li>将本地仓库推送到远程仓库<br> git remote add origin <a href="https://github.com/zxfjd3g/xxx.git">https://github.com/zxfjd3g/xxx.git</a> 关联远程仓库<br> git push origin master</li>
<li>如果本地有更新, 推送到远程<br> git add *<br> git commit -m “xxx”<br> git push origin master</li>
<li>如果远程有更新, 拉取到本地<br> git pull origin master<br> git fetch origin master:tmp</li>
<li>克隆远程仓库到本地<br> git clone <a href="https://github.com/zxfjd3g/xxx.git">https://github.com/zxfjd3g/xxx.git</a><br> git checkout -b dev origin/dev</li>
</ul>
<h2 id="说说git的分支-合并与冲突"><a href="#说说git的分支-合并与冲突" class="headerlink" title="说说git的分支,合并与冲突"></a>说说git的分支,合并与冲突</h2><ul>
<li>分支是在开发主线之外编写你的代码完成特定工作而不影响开发主线</li>
<li>分支的操作:<br> 查看分支: git branch<br> 创建分支: git branch dev<br> 切换分支: git checkout dev<br> 比较分支: git diff master dev<br> 合并分支: git merge dev</li>
<li>冲突<br> 产生冲突: 当对2个分支进行合并时, 如果同一个文件的同一行内容不一样, 就会产生冲突<br> 解决冲突:<pre><code>修正合并后产生冲突的代码
git add *
git commit -m &quot;resolve conflict&quot;</code></pre>
</li>
</ul>
<h2 id="说说git公司多人协作与开源项目多人协作"><a href="#说说git公司多人协作与开源项目多人协作" class="headerlink" title="说说git公司多人协作与开源项目多人协作"></a>说说git公司多人协作与开源项目多人协作</h2><ul>
<li>公司多人协作: 先在github上创建组织(修改权限), 多个同事加入此组织, 在组织下创建项目, 成员都可以进行推送更新</li>
<li>开源多人协作: fork仓库到自己的账户下, 修改fork仓库的代码, 向原仓库发起一个pull request, 对方接收到请求后可以选择合并</li>
</ul>
<h2 id="区别fork-复刻-与clone-克隆"><a href="#区别fork-复刻-与clone-克隆" class="headerlink" title="区别fork(复刻)与clone(克隆)"></a>区别fork(复刻)与clone(克隆)</h2><ul>
<li>fork: 将别人的远程仓库完全复制为自己的远程仓库</li>
<li>clone:  将远程仓库(自己/别人)完全复制为本地仓库</li>
</ul>
<h2 id="区别git的pull与fetch"><a href="#区别git的pull与fetch" class="headerlink" title="区别git的pull与fetch"></a>区别git的pull与fetch</h2><ul>
<li>简单来说，git pull 是 git fetch + git merge</li>
<li>执行pull: 将远程仓库的更新拉取到本地后, 与本地仓库当前分支进行自动合并(可能会遇到冲突)</li>
<li>执行fetch: 将远程仓库的更新拉取到一个暂时的新分支上, 后面需要手动进行merge操作(可以先进行diff操作)</li>
</ul>
<h2 id="git的几个主要分支"><a href="#git的几个主要分支" class="headerlink" title="git的几个主要分支"></a>git的几个主要分支</h2><ul>
<li>master分支<br>主分支，产品的功能全部实现后，最终在master分支对外发布。</li>
<li>develop分支<br>开发分支，基于master分支克隆，产品的编码工作在此分支进行。</li>
<li>release分支<br>测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。</li>
<li>bugfix/hotfix分支<br>Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。</li>
<li>feature分支<br>功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>git命令</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>js设计模式</title>
    <url>/2022/08/02/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="五大设计原则-S-O-L-I-D"><a href="#五大设计原则-S-O-L-I-D" class="headerlink" title="五大设计原则 S O L I D"></a>五大设计原则 S O L I D</h2><ul>
<li><code>S 单一职责原则</code></li>
<li><code>O 开放封闭原则</code></li>
<li>L 里氏置换原则</li>
<li><code>I 接口独立原则</code></li>
<li>D 依赖倒置原则<a id="more"></a>
<blockquote class="pullquote mindmap mindmap-lg"><ul>
<li>设计模式<ul>
<li>创建型<ul>
<li>工厂模式（工厂方法 抽象工厂 建造者模式）</li>
<li>单例模式</li>
<li>原型模式</li>
</ul>
</li>
<li>结构型<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代器模式</li>
<li>职责链模式</li>
<li>命令模式</li>
<li>备忘录</li>
<li>中介者</li>
<li>状态模式</li>
<li>解释器模式</li>
<li>访问者模式</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>js设计模式</category>
      </categories>
      <tags>
        <tag>js设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>googleV8</title>
    <url>/2020/11/27/googleV8/</url>
    <content><![CDATA[<h2 id="如何学习谷歌高性能-JavaScript-引擎V8"><a href="#如何学习谷歌高性能-JavaScript-引擎V8" class="headerlink" title="如何学习谷歌高性能 JavaScript 引擎V8"></a>如何学习谷歌高性能 JavaScript 引擎V8</h2><ul>
<li><p>什么是 V8？<br>V8 是 JavaScript 虚拟机的一种。我们可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的编程语言 JavaScript，翻译成机器能够理解的机器语言。如下图所示：<br><img src="/2020/11/27/googleV8/v8_01.jpg" alt="JavaScript引擎"></p>
<p>上图中，中间的“黑盒”就是 JavaScript 引擎 V8。目前市面上有很多种 JavaScript 引擎，诸如 SpiderMonkey、V8、JavaScriptCore 等。而由谷歌开发的开源项目 V8 是当下使用最广泛的 JavaScript 虚拟机，全球有超过 25 亿台安卓设备，而这些设备中都使用了 Chrome 浏览器，所以我们写的 JavaScript 应用，大都跑在 V8 上。<br>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升</p>
<a id="more"></a>
<p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。</p>
<p>V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以你会看到目前市面上 JavaScript 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率</p>
<p>V8 的主要功能，就是结合 JavaScript 语言的特性和本质来编译执行它</p>
</li>
<li><p>学习V8</p>
<p>V8 的编译流水线，其完整流程<br><img src="/2020/11/27/googleV8/v8_02.jpg" alt="v8编译流水线"><br>编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等等。这些技术决定着一段 JavaScript 代码能否正常执行，以及代码的执行效率。</p>
<p>V8 中使用的隐藏类（Hide Class），这是将 JavaScript 中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果你熟悉 V8 的工作机制，在你编写 JavaScript 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码</p>
<p>V8 实现了 JavaScript 代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，你可以优化你的代码更加适应这个机制，从而提高程序性能</p>
<p>除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是 <strong><em>事件循环系统</em></strong> 和 <strong><em>垃圾回收机制</em></strong>。</p>
<p>事件循环系统和 JavaScript 中的难点——异步编程特性紧密相关。JavaScript 是单线程的，JavaScript 代码都是在一个线程上执行，如果同一时间发送了多个 JavaScript 执行的请求，就需要排队，也就是进行异步编程。<br>V8 的事件循环系统会调度这些排队任务，保证 JavaScript 代码被 V8 有序地执行。因此也可以说，事件循环系统就是 V8 的心脏，它驱动了 V8 的持续工作。</p>
<p>JavaScript 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是我们经常会遇到的一个问题。你需要知道 V8 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了<br><img src="/2020/11/27/googleV8/all_v8.jpg" alt="v8"></p>
</li>
</ul>
<blockquote class="pullquote mindmap mindmap-lg"><ul>
<li>googlV8<ul>
<li>v8的基础环境<ul>
<li>堆空间<ul>
<li>树状存储结构</li>
<li>存储对象</li>
<li>存储闭包函数引用的原生类型</li>
</ul>
</li>
<li>栈空间<ul>
<li>先进后出</li>
<li>存储原生类型</li>
</ul>
</li>
<li>全局执行上下文<ul>
<li>初始化this</li>
<li>全局作用域</li>
<li>全局对象</li>
</ul>
</li>
<li>宿主环境<ul>
<li>宿主类型<ul>
<li>浏览器</li>
<li>node</li>
<li>其他宿主</li>
</ul>
</li>
<li>内置<ul>
<li>内置函数</li>
<li>内置对象<ul>
<li>浏览器 window</li>
<li>node.global</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>事件循环系统<ul>
<li>消息队列</li>
<li>任务调度系统</li>
</ul>
</li>
</ul>
</li>
<li>v8执行流程<ul>
<li>词法分析<ul>
<li>扫描源码</li>
<li>分割源码中的字符</li>
<li>输出Token</li>
</ul>
</li>
<li>语法分析<ul>
<li>基于词法分析出来的Token分析语法错误，给出提示</li>
<li>输出AST</li>
<li>输出作用域<ul>
<li>词法作用域规则</li>
<li>包含当前域中的对象和函数</li>
</ul>
</li>
<li>惰性编译<ul>
<li>推迟解析函数中的代码</li>
<li>到执行函数时再解析</li>
<li>默认只解析顶层代码</li>
</ul>
</li>
<li>预解析器<ul>
<li>快速查看函数</li>
<li>检查函数的语法是否正确</li>
<li>检查是否有闭包函数<ul>
<li>如果函数引用了父函数中的变量，那么必须将引用的变量分配到堆中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>字节码<ul>
<li>v8执行javascript过程中的中间代码</li>
<li>根据作用域和AST生成</li>
<li>机器代码的抽象</li>
<li>v8虚拟机的指令集</li>
<li>字节码缓存<ul>
<li>降低内存</li>
<li>提升执行速度</li>
</ul>
</li>
</ul>
</li>
<li>解释执行字节码<ul>
<li>两种经典的虚拟机架构<ul>
<li>寄存器的虚拟机<ul>
<li>累加器<ul>
<li>计算过程中临时变量存放在累加器中</li>
</ul>
</li>
<li>寄存器<ul>
<li>PC寄存器—— 用来存放下一条字节码指令<ul>
<li>通用寄存器—— 用来存放数据</li>
</ul>
</li>
</ul>
</li>
<li>堆和栈<ul>
<li>堆存放对象等数据<ul>
<li>栈管理函数调用关系</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基于栈架构的虚拟机<ul>
<li>寄存器<ul>
<li>pc寄存器</li>
<li>通用寄存器</li>
</ul>
</li>
<li>栈<ul>
<li>管理函数调用</li>
<li>存放临时变量</li>
</ul>
</li>
<li>堆<ul>
<li>存放对象等数据</li>
</ul>
</li>
</ul>
</li>
<li>v8才用的是寄存器的虚拟机<ul>
<li>充分使用累加器</li>
<li>字节码指令集的编程风格和基于栈的有差异</li>
<li>顺序执行字节码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优化字节码执行速度<ul>
<li>为什么解释执行慢<ul>
<li>javascript 是动态语言</li>
<li>v8事先不知道类型的形状</li>
<li>动态查找属性</li>
<li>执行之前需要编译</li>
</ul>
</li>
<li>内联缓存<ul>
<li>缓存对象形状</li>
<li>下次执行相同类型时，直接使用该形态来快速定位属性</li>
</ul>
</li>
</ul>
</li>
<li>即时编译<ul>
<li>监视器<ul>
<li>监视解释器的执行过程</li>
<li>发现热点代码</li>
<li>将热点代码提交给编辑器优化</li>
</ul>
</li>
<li>编译器<ul>
<li>编译器会编译热点代码</li>
<li>并优化编译后的二进制机器代码</li>
<li>二进制代码能够被高效执行</li>
</ul>
</li>
<li>隐藏类<ul>
<li>提取代码中的对象的形状</li>
<li>并记录具体形状</li>
<li>通过形状快速定位对象属性</li>
</ul>
</li>
<li>反优化<ul>
<li>对象的形状被动态修改了</li>
<li>隐藏类失效</li>
<li>触发反优化机制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>事件循环系统<ul>
<li>什么是事件循环系统<ul>
<li>javascript是单线程模式</li>
<li>单线程同时只能执行一个任务</li>
<li>有新的任务就需要排队执行</li>
<li>引入消息队列</li>
<li>消息队列中的任务是宏任务</li>
<li>任务调度器<ul>
<li>循环读取消息队列中的任务</li>
<li>分派给指定的任务处理器</li>
</ul>
</li>
</ul>
</li>
<li>异步编程<ul>
<li>回掉函数模式<ul>
<li>以回掉函数的方式编写异步代码</li>
<li>可读性差</li>
<li>代码难维护</li>
<li>回掉地狱</li>
</ul>
</li>
<li>Promise 模式<ul>
<li>半同步的方式编写异步代码</li>
<li>使用微任务</li>
<li>改造了回调函数</li>
<li>可读性提升</li>
</ul>
</li>
<li>async/await 模式<ul>
<li>同步的方式编写异步代码</li>
<li>使用微任务</li>
<li>使用了协程</li>
<li>可读性大幅提升</li>
<li>原理复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>javascript设计思想<ul>
<li>函数一等公民<ul>
<li>函数拥有普通类型的特性<ul>
<li>可以作为参数</li>
<li>可以作为返回值</li>
<li>可以赋值给一个变量</li>
</ul>
</li>
<li>基于对象设计<ul>
<li>基本类型<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Symbol</li>
<li>BigInt</li>
</ul>
</li>
<li>对象类型<ul>
<li>普通对象</li>
<li>函数</li>
<li>数组</li>
</ul>
</li>
</ul>
</li>
<li>对象是动态的<ul>
<li>可以在运行时改变对象属性</li>
</ul>
</li>
<li>支持闭包<ul>
<li>函数即对象</li>
<li>函数可以作为返回值</li>
<li>子函数可以引用父函数内部的变量</li>
<li>父函数返回子函数，子函数引用父函数的变量需要一同打包带走</li>
</ul>
</li>
<li>函数表达式<ul>
<li>函数声明<ul>
<li>在编译阶段，会将声明的函数转换成函数对象</li>
<li>函数声明会被变量提升</li>
</ul>
</li>
<li>函数表达式<ul>
<li>在编译阶段，不会对函数表达式做任何操作</li>
<li>立即调用函数表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>类型系统和垃圾回收<ul>
<li>类型系统<ul>
<li>什么是类型系统<ul>
<li>内存中的二进制是没有类型的</li>
<li>我们可以强制给一组二进制赋予类型信息</li>
<li>类型信息为许多操作提供隐含的上下文<ul>
<li>两个整数类型相加</li>
<li>两个字符串类型相加</li>
</ul>
</li>
<li>类型系统限制了不合法的类型操作<ul>
<li>1+ ‘2’ js 中合法</li>
<li>1+ ‘2’ Python 中不合法</li>
</ul>
</li>
</ul>
</li>
<li>不同的类型如何存储<ul>
<li>对象存储在堆中</li>
<li>基本类型存储在栈中</li>
</ul>
</li>
<li>传值和传引用<ul>
<li>原生类型一律传值</li>
<li>对象类型一律传引用</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收<ul>
<li>采用自动垃圾回收策略</li>
</ul>
</li>
</ul>
</li>
<li>作用域<ul>
<li>源代码中定义变量的区域</li>
<li>静态作用域（写代码的时候静态确认下来的）</li>
<li>动态作用域 （和函数调用的位置有关）</li>
<li>javascript 是基于静态作用域</li>
<li>作用域链(沿着多个作用域，查找变量的链路)<ul>
<li>函数级作用域</li>
<li>函数内声明的变量生成周期和函数绑定</li>
<li>块级作用域</li>
<li>变量和函数声明</li>
</ul>
</li>
</ul>
</li>
<li>原型链继承<ul>
<li>原型<ul>
<li>每个对象都有一个原型属性</li>
<li>原型也是一个对象</li>
<li>通过__proto__指向原型对象</li>
</ul>
</li>
<li>原型链(查找对象属性的链路)<ul>
<li>先在当前的属性中查找</li>
<li>再在原型对象中查找</li>
<li>再在原型的原型对象中查找直到 顶层Object的原型对象</li>
</ul>
</li>
<li>new 关键字</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收系统<ul>
<li>什么是自动垃圾回收系统<ul>
<li>自动跟踪正在使用的对象并回收不再使用的对象</li>
</ul>
</li>
<li>回收方式<ul>
<li>手动分配和回收<ul>
<li>显示分配内存</li>
<li>手动回收内存</li>
</ul>
</li>
<li>智能指针<ul>
<li>记住每个对象被引用的次数</li>
<li>当引用计数为0 时，便自动回收该对象</li>
</ul>
</li>
<li>自动内存管理<ul>
<li>所有被引用的元素都用一个根元素</li>
<li>每次从根向下遍历，没有被遍历到的数据视为垃圾数据</li>
</ul>
</li>
</ul>
</li>
<li>代记假说<ul>
<li>大部分对象在内存中存活的时间短</li>
<li>不死的对象会会活的更久</li>
</ul>
</li>
<li>分代收集<ul>
<li>新生代存放新对象那</li>
<li>老生代存放老对象</li>
</ul>
</li>
<li>垃圾回收器<ul>
<li>副垃圾回收器(负责新生代的垃圾回收)</li>
<li>主垃圾回收器（负责老生代的代码回收）</li>
</ul>
</li>
<li>垃圾回收流程<ul>
<li>通用流程<ul>
<li>回收非活动对象占用的内存</li>
<li>整理内存碎片</li>
</ul>
</li>
<li>副垃圾回收器<ul>
<li>Scavenge 算法</li>
<li>新生代的对象和空闲区域</li>
<li>对象晋升策略</li>
</ul>
</li>
<li>主垃圾回收器<ul>
<li>标记清除算法</li>
<li>标记整理算法</li>
<li>大对象</li>
<li>晋升的对象</li>
</ul>
</li>
<li>全停顿<ul>
<li>垃圾回收操作会占用主线程</li>
<li>会阻塞主线程<ul>
<li>引发问题<ul>
<li>代码不规范，触发频繁的垃圾回收，主业务被阻塞</li>
</ul>
</li>
<li>优化方法<ul>
<li>优化代码<ul>
<li>减少触发垃圾回收次数</li>
<li>采用增量垃圾回收</li>
</ul>
</li>
<li>v8 采用并行垃圾回收策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>googleV8</category>
      </categories>
      <tags>
        <tag>googleV8</tag>
      </tags>
  </entry>
  <entry>
    <title>js 代码片段实现</title>
    <url>/2020/10/29/js-codeSnippet/</url>
    <content><![CDATA[<h2 id="做一个-PC-端的网页，设计图是-1920X1080，要在常见屏上显示正常-，比如：1280X720-1366X768-1440X900-1920X1080。就要使用-REM，width、height、margin、padding、left、top-都采用了-REM"><a href="#做一个-PC-端的网页，设计图是-1920X1080，要在常见屏上显示正常-，比如：1280X720-1366X768-1440X900-1920X1080。就要使用-REM，width、height、margin、padding、left、top-都采用了-REM" class="headerlink" title="做一个 PC 端的网页，设计图是 1920X1080，要在常见屏上显示正常 ，比如：1280X720 1366X768 1440X900 1920X1080。就要使用 REM，width、height、margin、padding、left、top 都采用了 REM"></a>做一个 PC 端的网页，设计图是 1920X1080，要在常见屏上显示正常 ，比如：1280X720 1366X768 1440X900 1920X1080。就要使用 REM，width、height、margin、padding、left、top 都采用了 REM</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tid;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> designSize = <span class="number">1920</span>; <span class="comment">// 设计图尺寸</span></span><br><span class="line">    <span class="keyword">let</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">    <span class="keyword">let</span> wW = html.clientWidth; <span class="comment">// 窗口宽度</span></span><br><span class="line">    <span class="keyword">let</span> rem = (wW * <span class="number">100</span>) / designSize;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontSize = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;resize&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">      tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;pageshow&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">        tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>计算 font-size 的逻辑是：<br>当设计图是 1920 时,规定 HTML 的 FONT-SIZE 的值是 100. 也就是,当浏览器窗口调整到 1920PX 时,1REM=100PX,如果要设定一个 160PX(1920 设计图时)的 margin-top,那么 REM 设置值是 1.6rem.</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin, hashMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (origin == <span class="literal">undefined</span> || <span class="keyword">typeof</span> origin !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(origin);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(origin);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> hashKey = hashMap.get(origin);</span><br><span class="line">  <span class="keyword">if</span> (hashKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashKey;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> target = <span class="keyword">new</span> origin.constructor();</span><br><span class="line">  hashMap.set(origin, target);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> origin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.hasOwnProperty(k)) &#123;</span><br><span class="line">      target[k] = deepClone(origin[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="js-原有的-toFixed-函数得到结果并非-想要的-需要自己重新定义"><a href="#js-原有的-toFixed-函数得到结果并非-想要的-需要自己重新定义" class="headerlink" title="js 原有的 toFixed 函数得到结果并非 想要的 需要自己重新定义"></a>js 原有的 toFixed 函数得到结果并非 想要的 需要自己重新定义</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFixed</span>(<span class="params">number, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;number不是数字&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.pow(<span class="number">10</span>, m) * number) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, m);</span><br><span class="line">  result = <span class="built_in">String</span>(result);</span><br><span class="line">  <span class="keyword">if</span> (result.indexOf(<span class="string">&quot;.&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="number">0</span>) &#123;</span><br><span class="line">      result += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">      result += <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).join(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = result.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">1</span>].length &lt; m) &#123;</span><br><span class="line">      arr[<span class="number">1</span>] += <span class="keyword">new</span> <span class="built_in">Array</span>(m - arr[<span class="number">1</span>].length + <span class="number">1</span>).join(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = arr.join(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind 实现"></a>bind 实现</h2><ul>
<li><p>箭头函数的 this 永远指向它所在的作用域，函数作为构造函数用 new 关键字调用时，不应该改变其 this 指向，因为 new 绑定 的优先级高于 显示绑定 和 硬绑定</p>
</li>
<li><p>返回⼀个函数，绑定 this，传递预置参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拿到参数，为了传给调用者</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> nop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 构建一个干净的函数，用于保存原函数的原型</span></span><br><span class="line">  <span class="comment">// 绑定的函数</span></span><br><span class="line">  <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this instanceof nop, 判断是否使用 new 来调用 bound</span></span><br><span class="line">    <span class="comment">// 如果是 new 来调用的话，this的指向就是其实例，</span></span><br><span class="line">    <span class="comment">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span></span><br><span class="line">    <span class="keyword">return</span> self.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> nop ? <span class="built_in">this</span> : thisArg,</span><br><span class="line">      args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.prototype) &#123;</span><br><span class="line">    nop.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改绑定函数的原型指向</span></span><br><span class="line">  bound.prototype = <span class="keyword">new</span> nop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="call-实现"><a href="#call-实现" class="headerlink" title="call 实现"></a>call 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this指向调用call的对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用call的若不是函数则报错</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  thisArg = thisArg || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将调用call函数的对象添加到thisArg的属性中</span></span><br><span class="line">  thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 执行该属性</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.fn(...arg);</span><br><span class="line">  <span class="comment">// 删除该属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">  <span class="comment">// 返回函数执行结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply 实现"></a>apply 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;不是一个函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = thisArg.fn(...arg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简单的防抖-函数"><a href="#简单的防抖-函数" class="headerlink" title="简单的防抖 函数"></a>简单的防抖 函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn();</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-实现的过程"><a href="#new-实现的过程" class="headerlink" title="new 实现的过程"></a>new 实现的过程</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为new是关键字,函数的形式来实现，将构造函数和构造函数的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">Fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.创建一个空对象，并将对象的__proto__指向构造函数的prototype 这里我两步一起做了</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Fn.prototype);</span><br><span class="line">  <span class="comment">//2.将构造函数中的this指向obj，执行构造函数代码,获取返回值</span></span><br><span class="line">  <span class="keyword">const</span> res = Fn.apply(obj, args);</span><br><span class="line">  <span class="comment">//3.判断返回值类型</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="compose-函数实现"><a href="#compose-函数实现" class="headerlink" title="compose 函数实现"></a>compose 函数实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">!fns.length</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">v</span>) =&gt;</span> v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">fns.length === <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fns.reducer(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> pre(cur(...args))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="settimeout-模拟实现-setinterval"><a href="#settimeout-模拟实现-setinterval" class="headerlink" title="settimeout 模拟实现 setinterval"></a>settimeout 模拟实现 setinterval</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySettimeout</span>(<span class="params">fn, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(interval, t);</span><br><span class="line">  &#125;</span><br><span class="line">  interval();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    cancel: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现订阅</span></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, callBack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type] = [callBack];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type].push(callBack);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除订阅</span></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type, callBack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.events[type] = <span class="built_in">this</span>.events[type].filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item !== callBack;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只执行一次订阅事件</span></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">type, callBack</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callBack();</span><br><span class="line">      <span class="built_in">this</span>.off(type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(type, fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type, ...rest</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type] &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.events[type].forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn.apply(<span class="built_in">this</span>, rest));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存数组长度</span></span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="comment">// 外层循环用于控制从头到尾的比较+交换到底有多少轮</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; </span><br><span class="line">    <span class="comment">// 每循环完一次就少一次比教</span></span><br><span class="line">    <span class="comment">// 内层循环用于完成每一轮遍历过程中的重复比较+交换 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="comment">// 若相邻元素前面的数比后面的大</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 交换两者</span></span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回数组</span></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现一个-add-方法-使计算结果能够满足如下预期：-add-1-2-3-6-add-1-2-3-4-10"><a href="#实现一个-add-方法-使计算结果能够满足如下预期：-add-1-2-3-6-add-1-2-3-4-10" class="headerlink" title="实现一个 add 方法 使计算结果能够满足如下预期： add(1)(2)(3)()=6 add(1,2,3)(4)()=10"></a>实现一个 add 方法 使计算结果能够满足如下预期： add(1)(2)(3)()=6 add(1,2,3)(4)()=10</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> allArgs = [...args];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...newArgs</span>) </span>&#123;</span><br><span class="line">    allArgs = [...allArgs, ...newArgs];</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">  &#125;</span><br><span class="line">  fn.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!allArgs.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allArgs.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LRU-缓-存-函-数"><a href="#LRU-缓-存-函-数" class="headerlink" title="LRU 缓 存 函 数"></a>LRU 缓 存 函 数</h2><h2 id="instanceof-操作符的实现原理及实现"><a href="#instanceof-操作符的实现原理及实现" class="headerlink" title="instanceof  操作符的实现原理及实现"></a>instanceof  操作符的实现原理及实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left);</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">  <span class="function"><span class="title">while</span>(<span class="params"><span class="literal">true</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!proto</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">proto === prototype</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>js 代码片段实现</category>
      </categories>
      <tags>
        <tag>js 代码片段实现</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode快捷键</title>
    <url>/2022/07/27/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="编辑器与窗口管理"><a href="#编辑器与窗口管理" class="headerlink" title="编辑器与窗口管理"></a>编辑器与窗口管理</h2><ul>
<li>Ctrl+N： 新建文件</li>
<li>Ctrl+Shift+N：打开一个新的VSCode编辑器</li>
<li>Ctrl+O：打开文件</li>
<li>Ctrl+Shift+O：打开文件夹</li>
<li>Ctrl+W：关闭当前文件</li>
<li>Ctrl+Shift+W 或 Alt+F4：关闭当前VSCode编辑器</li>
<li>Ctrl+\：新建窗口显示代码（相当于复制当前代码到一个新的窗口；同一引用，修改一个文件，其他相同文件会一起改变）</li>
<li>Ctrl+Alt+→：移动当前文件到右窗口，若没有右窗口，则创建一个新窗口</li>
<li>Ctrl+Alt+←：移动当前文件到左窗口</li>
<li>Ctrl+Tab：切换文件窗口</li>
<li>Ctrl+B：显示/隐藏侧边栏</li>
<li>Ctrl+`：显示/隐藏控制面板（Terminal）（反引号位置：英文输入法状态下，键盘ESC按键下面的按键）</li>
<li>Ctrl +/- ：放大/缩小编辑器窗口</li>
<li>F11：全屏显示</li>
<li>Ctrl+Shift+E：文件资源管理器（Explorer）</li>
<li>Ctrl+Shift+G：git管理窗口（Source Control）</li>
<li>Ctrl+Shift+X：扩展（插件）管理窗口（Extentions）</li>
</ul>
<a id="more"></a>

<h2 id="代码查找替换与格式调整"><a href="#代码查找替换与格式调整" class="headerlink" title="代码查找替换与格式调整"></a>代码查找替换与格式调整</h2><ul>
<li>Ctrl+F：查找</li>
<li>Ctrl+H：查找替换</li>
<li>Ctrl+Shift+F：全局查找</li>
<li>Ctrl+Shift+H：全局查找替换</li>
<li>Ctrl+D：选中下一个匹配项</li>
<li>Ctrl+Shift+L：选中所有匹配项（秀儿）</li>
<li>Ctrl+[ ：向左缩进</li>
<li>Ctrl+] ：向右缩进</li>
<li>Alt+Up：向上移动当前行</li>
<li>Alt+Down：向下移动当前行</li>
<li>Shift+Alt+Up：向上复制当前行</li>
<li>Shift+Alt+Down：向下复制当前行</li>
<li>Ctrl+Enter：在当前行下方插入空行（光标位置可以不在行尾）</li>
<li>Ctrl+Shift+Enter：在当前行上方插入空行（光标位置可以不在行尾）</li>
<li>Alt+Z：切换内容是否自动换行（底部显示/隐藏滚动条</li>
</ul>
<h2 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h2><ul>
<li>Home：光标移动到行首</li>
<li>End：光标移动到行尾</li>
<li>Ctrl+Home：光标移动到文件开头（左上）</li>
<li>Ctrl+End：光标移动到文件结尾（右下）</li>
<li>Shift+Home：选择从光标到行首的内容</li>
<li>Shift+End：选择从光标到行尾的内容</li>
<li>Shift+Alt+Right：扩大选中范围</li>
<li>Shift+Alt+Left：缩小选中范围</li>
<li>Alt+Shift+鼠标左键：同时选中编辑多行多列代码（秀儿）</li>
<li>Ctrl+Alt+Up：向上复制光标</li>
<li>Ctrl+Alt+Down：向下复制光标</li>
<li>Ctrl+U：回退到上一个光标处</li>
<li>F12：转到定义处</li>
<li>Alt+F12：查看定义处缩略图</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>vscode快捷键</category>
      </categories>
      <tags>
        <tag>vscode快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>代码中注意问题</title>
    <url>/2022/07/10/%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Object-keys-的顺序问题"><a href="#Object-keys-的顺序问题" class="headerlink" title="Object.keys()的顺序问题"></a>Object.keys()的顺序问题</h2><p><a href="https://blog.csdn.net/qq846294282/article/details/118719889">Object.keys</a></p>
<h2 id="JSON-stringify-使用数据丢失问题"><a href="#JSON-stringify-使用数据丢失问题" class="headerlink" title="JSON.stringify 使用数据丢失问题"></a>JSON.stringify 使用数据丢失问题</h2><p><a href="https://mp.weixin.qq.com/s/rTuiUtpTB6iOqCNb7yv0zQ">JSON.stringify</a></p>
<h2 id="if-else-语句里不能用函数声明定义函数"><a href="#if-else-语句里不能用函数声明定义函数" class="headerlink" title="if else 语句里不能用函数声明定义函数"></a>if else 语句里不能用函数声明定义函数</h2><h2 id="js-toFixed四舍五入出现的精度问题"><a href="#js-toFixed四舍五入出现的精度问题" class="headerlink" title="js toFixed四舍五入出现的精度问题"></a>js toFixed四舍五入出现的精度问题</h2><p><a href="https://blog.csdn.net/qq_38128179/article/details/89181805?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-89181805-blog-123878883.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-89181805-blog-123878883.pc_relevant_aa&utm_relevant_index=2">解决JS浮点数运算结果不精确的Bug</a><br> 解决办法的类库 <a href="https://mathjs.org/">Math.js</a> <a href="http://mikemcl.github.io/big.js/">big.js</a> <a href="http://mikemcl.github.io/decimal.js/">decimal.js</a></p>
<h2 id="forEach中不出现异步代码"><a href="#forEach中不出现异步代码" class="headerlink" title="forEach中不出现异步代码"></a>forEach中不出现异步代码</h2><a id="more"></a>

<h2 id="箭头函数不是万能的-4中情况禁止使用"><a href="#箭头函数不是万能的-4中情况禁止使用" class="headerlink" title="箭头函数不是万能的,4中情况禁止使用"></a>箭头函数不是万能的,4中情况禁止使用</h2><ul>
<li>请不要在构造函数中使用箭头函数</li>
<li>请不要在点击事件中操作this</li>
<li>请不要在对象的方法中使用箭头函数</li>
<li>请不要在原型链中使用箭头函数</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>代码中注意问题</category>
      </categories>
      <tags>
        <tag>代码中注意问题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9C%A8%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="面试题集"><a href="#面试题集" class="headerlink" title="面试题集"></a>面试题集</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&mid=2650081252&idx=1&sn=1fedc422a3806fa1f9c3faf31bb2a20b&chksm=83db9a81b4ac1397132de99ebdbdbdad57dcc6785d0b8fe1a5ee2b57dbb960b0fbf65015c3ca&scene=126&sessionid=1603760808&key=54ce6b15dc70fa94e4cee849718a95dcb45463880bfbf73a52f6e49f4e4a65fb8adec9e1c54df8bf81bfa1d78626a8537229cc36083224e425c795f892103475ca5f06542d47eec5dabc5d55c77dc7f9fabc4524bbc83cf94060d9236d1061a0fa026db04b47ae38fdfd65662df5549a11d6cd60ff371f5492081a022254d0e7&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AXrZ8Ft8M/kmfXMdRQOHyYs=&pass_ticket=Kkp6C7aNRW+SS3CyH29rTpuzIryrfuzR2BkuJOMPRmZ73lUqRYKqbJR1nz5SlRhp&wx_header=0">面试题 1</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247486750&idx=1&sn=d7e13a8393b83ac330d9b48690428c0e&chksm=fa2bedf7cd5c64e19fcafbe4dab742b65cfe168ad567f3f799b5fc229a35710eb4164084897c&scene=126&sessionid=1602725812&key=6664ac14267ba66883c13581e1d9e62b3ffc7ddfc44d1984c762bde82d19131986d5d9af50595ab1d798e16e45eddd68ded75929bfc6217a87ec0dcacb393b0aa10b53bcd066f65c7865905a425d129f9f1f110464e3a8faa5601a1b7a192f46240134dd033c0bacd43e93b0b51701140f106a0a52acfaabf76e8fee9f2cae06&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=Adc0WAca8bFpyYT3RtaxAjo=&pass_ticket=gNZw604QfgMyZ5MfqQB17Zb9G0KO/y/Gpe3+UhEBieJBkyQwt1xU8LnZyQLLT598&wx_header=0">面试题 2</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NTk2NzUxNg==&mid=2247488674&idx=1&sn=3f5c6af2c52365525aa84ff92b9f865b&chksm=ea941651dde39f4790e96e2d8f2530fa23257afb50de8d40d6d318507b873f9d870c0f507863&mpshare=1&scene=1&srcid=1026yMwvhU6WsEBstdZUyIgl&sharer_sharetime=1603682665969&sharer_shareid=1b2206d548f7c54418de346a0102e46f&key=041bb01ba83758f9c012f304255f853e521afbe7bbf65555a0e068f76f2c433eea39d0413b426b59a870039c71945328b288292bbbbac9811706f2f09f6716c482684831e94eab0b6935f37a6a5c8892d4ca9ecd897e139bf608b85a18e8ee5339e931c56cc60e39443738eeb63253718488c0322710c61a17510cbfa97910cb&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AQ+cZHmGMZ8MBH/qQ1l2YVc=&pass_ticket=L+jndQVDhQl1X8R7c+wxUxrwQN/fivdCt7LVG0oUoik5qA1Gx2ZTiVGm+4shiHQn&wx_header=0">源码面试题</a></p>
</li>
<li><p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions">前端开发面试题</a></p>
</li>
<li><p><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/">WEB 前端面试宝典</a></p>
</li>
<li><p><a href="https://github.com/shfshanyue/blog/blob/master/post/juejin-interview.md">掘金前端面试题合集</a></p>
</li>
<li><p><a href="https://yuchengkai.cn/">前端面试图谱</a></p>
</li>
<li><p><a href="https://github.com/biaochenxuying/blog/issues/47">前端面试开源项目汇总 | Github 上 100K+ Star 的前端面试开源项目汇总</a></p>
</li>
<li><p><a href="https://blog.poetries.top/FE-Interview-Questions/">前端面试常考问题整理 | 按模块和知识点分类</a></p>
</li>
<li><p><a href="https://juejin.cn/column/6964717704712290317">2021 前端面试题集</a></p>
</li>
<li><p><a href="https://h5bp.org/Front-end-Developer-Interview-Questions/">Front-end Developer Interview Questions</a></p>
</li>
<li><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map">CS-Interview-knowledge-Map</a></p>
</li>
<li><p><a href="https://github.com/shfshanyue/Daily-Question">Daily-Question</a></p>
</li>
<li><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question">Daily-Interview-Question</a></p>
</li>
<li><p><a href="https://lucifer.ren/fe-interview">fe-interview 大前端面试宝典</a></p>
</li>
<li><p><a href="https://github.com/biaochenxuying/blog/blob/master/interview/fe-interview.md">前端硬核面试专题</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problemset/all">LeetCode 算法试题学习</a></p>
</li>
<li><p><a href="https://www.nowcoder.com/">LeetCode 算法试题学习</a></p>
<div class="pdf-container" data-target="./前端面试题整合.pdf" data-height="500px"></div>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>面试题集</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器调试技巧</title>
    <url>/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="debug-函数"><a href="#debug-函数" class="headerlink" title="debug 函数"></a>debug 函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug(test);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="DOM-断点"><a href="#DOM-断点" class="headerlink" title="DOM 断点"></a>DOM 断点</h2><p><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/dom%E6%96%AD%E7%82%B9.png" alt="12"></p>
<h2 id="鼠标悬浮样式查看"><a href="#鼠标悬浮样式查看" class="headerlink" title="鼠标悬浮样式查看"></a>鼠标悬浮样式查看</h2><p><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/hover.png" alt="12"></p>
<h2 id="控制台内置对象-0"><a href="#控制台内置对象-0" class="headerlink" title="控制台内置对象 $0 $$ $"></a>控制台内置对象 $0 $$ $</h2><ul>
<li><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/$0.png" alt="12"></li>
<li>$$ == document.querySelectorAll</li>
<li>$ == document.querySelector</li>
</ul>
<h2 id="保留日志"><a href="#保留日志" class="headerlink" title="保留日志"></a>保留日志</h2><ul>
<li>当我们刷新完页面之后，通常控制台的 Console 面板就会被清空。如果想保留控制台的日志，就可以在设置中勾选 Preserve log 选项以保留控制台中的日志<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E4%BF%9D%E7%95%99%E6%97%A5%E5%BF%97.png"></li>
</ul>
<h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><ul>
<li>我们可以打开设置，在 Experiments 中勾选 Record coverage while performance tracing 选项。<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E8%A6%86%E7%9B%96%E7%8E%87.png"></li>
<li>在面板下方的 Coverage 面板中点击红色按钮以记录页面的代码覆盖率：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E8%A6%86%E7%9B%96%E7%8E%871.png"><br>代码覆盖率使用动态分析法来收集代码运行时的覆盖率，让开发者知道有代码在页面上真正的使用。动态分析是指在应用运行状态下收集代码执行数据的过程，换句话说，覆盖率数据就是在代码执行过程中通过标记收集到的。</li>
</ul>
<h2 id="显示重绘"><a href="#显示重绘" class="headerlink" title="显示重绘"></a>显示重绘</h2><ul>
<li>在浏览器的开发者工具中可以通过开启显示重绘选项以查看页面在执行操作时哪些元素会发生重绘<br>在控制台右上角三个点中的 More tools 选项中开启 Rendering 选项卡：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E9%87%8D%E5%9B%9E.png"></li>
<li>开启 Rendering（渲染）选项后，开启 Paint flashing：当刷新页面时，显示绿色的区域就是重新绘制区域<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E9%87%8D%E5%9B%9E1.png"></li>
</ul>
<h2 id="检查动画"><a href="#检查动画" class="headerlink" title="检查动画"></a>检查动画</h2><ul>
<li>Chrome 的开发者工具不仅可以调试样式，还可以调试动画，可以在控制台右上角三个点中的 More tools 选项中开启 Animations 选项卡：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%A3%80%E6%9F%A5%E5%8A%A8%E7%94%BB.png"></li>
<li>当页面的动画执行时，就会在时间轨道上查看所有的动画，点击其中一个动画可以懂得执行过程以及时间轴<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%A3%80%E6%9F%A5%E5%8A%A8%E7%94%BB1.png"><br>我们可以在时间轴上定位到任一时刻的动画帧，也可以拖动左右两端的圆点来修改动画的延迟和周期，修改之后可以在属性面板看到对应的 CSS 样式。</li>
</ul>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><ul>
<li>Chrome 浏览器内置了截图功能，可以在浏览器开发者工具中使用 Ctrl+Shift+P（Windows）或者 Command+Shift+P（Mac）快捷键打开搜索来查找 screenshot：<br>这里有四个选项： ● 第一个：截取自选区域； ● 第二个：截取整个网页； ● 第三个：截取当前节点； ● 第四个：截取当前屏幕。 截图完成后自动下载到下载目录，打开浏览器的下载框或本机的下载目录即可看到图片<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E6%88%AA%E5%9B%BE.png"></li>
</ul>
<h2 id="覆盖线上资源"><a href="#覆盖线上资源" class="headerlink" title="覆盖线上资源"></a>覆盖线上资源</h2><ul>
<li>我们可以使用本地资源覆盖网页所使用的资源，比如可以使用本地 CSS 文件覆盖网页的 css 文件，修改样式。将本地的文件夹映射到网络，在 Chrome 开发者功能里面对 CSS 样式的修改都会直接改动本地文件，页面重新加载，使用的资源也是本地资源，达到持久化的效果。<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E8%A6%86%E7%9B%96%E7%BD%91%E4%B8%8A%E8%B5%84%E6%BA%90.png"></li>
</ul>
<h2 id="事件监听断点"><a href="#事件监听断点" class="headerlink" title="事件监听断点"></a>事件监听断点</h2><ul>
<li>有时应用会在用户发生交互时出现问题，这时我们就可以添加事件监听器添加断点来捕获这些事件以检查交互时的问题。可以在 Source 面板右侧的 Event Listener Breakpoints 中勾选相应的事件：<br><img src="/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%AD%E7%82%B9.png"></li>
</ul>
<h2 id="常忽略的-js-操作符"><a href="#常忽略的-js-操作符" class="headerlink" title="常忽略的 js 操作符 ?? ??= ?."></a>常忽略的 js 操作符 <code>?? ??= ?.</code></h2><ul>
<li>??运算符被称为 nullish coalescing 运算符(零合并操作符)。如果第一个参数不是 null/undefined，这个运算符将返回第一个参数，否则，它将返回第二个参数</li>
<li>??=又被称为逻辑空值赋值运算符<code>var x= null; var y = 5; console.log(x ??= y) // 5</code></li>
<li>?. 允许开发人员读取深嵌在对象链中的属性值，而不必显式验证每个引用。当一个引用为空时，表达式停止计算并返回一个未定义的值 <code>travelPlans.tuesday?.location</code></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>浏览器调试技巧</category>
      </categories>
      <tags>
        <tag>浏览器调试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>算法思想</title>
    <url>/2022/07/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul>
<li><p>二分</p>
</li>
<li><p>双指针 （快慢指针 头尾指针） 1.链表 数组</p>
</li>
<li><p>递归 回溯 （画递归树）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backTrack</span>(<span class="params">数据， 路径缓存</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (下一个值)</span><br><span class="line">  标记</span><br><span class="line">  backTrack</span><br><span class="line">  取消标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>动态规划 找最优解</p>
</li>
<li><p>贪心</p>
</li>
<li><p>bfs(宽度优先) dfs(回溯 广度优先)</p>
</li>
</ul>
<a id="more"></a>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>链表</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">遍历;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">  head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">// 哨兵节点-中间节点</span></span><br><span class="line"><span class="keyword">let</span> dummny = &#123;</span><br><span class="line">  next: head,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummny.next;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组</li>
<li>树结构</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(二叉树)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">treeNode</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  终止条件 treeNode</span><br><span class="line">  walk(treeNode.left);</span><br><span class="line">  walk(treeNode.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  walk(treeNode.left);</span><br><span class="line">  终止条件 treeNode</span><br><span class="line">  walk(treeNode.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  walk(treeNode.left);</span><br><span class="line">  walk(treeNode.right)</span><br><span class="line">  终止条件 treeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote class="pullquote mindmap mindmap-lg"><ul>
<li>数据结构<ul>
<li>树与二叉树<ul>
<li>二叉树<ul>
<li>完全二叉树</li>
<li>满二叉树</li>
<li>二叉搜索树</li>
<li>平衡二叉搜索树<ul>
<li>红黑树</li>
</ul>
</li>
<li>特点<ul>
<li>遍历方式<ul>
<li>广度优先</li>
<li>深度优先<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
</ul>
</li>
<li>顺序和链式</li>
</ul>
</li>
</ul>
</li>
<li>哈夫曼叔</li>
<li>字典树</li>
</ul>
</li>
<li>排序<ul>
<li>O(n^2)<ul>
<li>冒泡</li>
<li>插入</li>
<li>选择</li>
</ul>
</li>
<li>O(nlog(n))<ul>
<li>快速排序</li>
<li>归并排序</li>
</ul>
</li>
<li>O(n)<ul>
<li>桶排序</li>
<li>基数排序</li>
<li>计数排序</li>
</ul>
</li>
</ul>
</li>
<li>受限线性表<ul>
<li>栈<ul>
<li>顺序和链式都可以实现 先进后出</li>
<li>实际应用<ul>
<li>浏览器的前进和后退</li>
<li>括号匹配</li>
<li>表达式计算</li>
</ul>
</li>
</ul>
</li>
<li>堆<ul>
<li>大顶堆</li>
<li>小顶堆</li>
</ul>
</li>
<li>队列<ul>
<li>普通队列 顺序和链式都可以实现 先进后出</li>
<li>双边队列 入口和出口都可以进队和出队</li>
<li>优先级队列 根据优先级来出队</li>
<li>实际应用 LRU cache</li>
</ul>
</li>
</ul>
</li>
<li>非受限线性表<ul>
<li>顺序结构<ul>
<li>数组<ul>
<li>支持 O(1) 的随机访问</li>
<li>平均为 O(n) 的插入和删除</li>
<li>警惕越界错误，导致 Stack Over Flow</li>
</ul>
</li>
</ul>
</li>
<li>链式结构<ul>
<li>单链表<ul>
<li>不支持随机访问，需要遍历去访问结点</li>
<li>插入和删除只需要移动指针，时间复杂度</li>
<li>每个结点需要额外的空间存储指针，需要的内存比数组大 为 O(1)</li>
</ul>
</li>
<li>双链表<ul>
<li>在单链表的基础上，除头结点外，每个结点多了一个存放前驱结点内存地址的指针</li>
</ul>
</li>
<li>循环链表<ul>
<li>尾节点指针指向头结点</li>
</ul>
</li>
<li>静态链表<ul>
<li>借助数组，伴随指向后继结点的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>算法思想</tag>
      </tags>
  </entry>
  <entry>
    <title>在线文档</title>
    <url>/2020/10/27/%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p><a href="https://www.bookstack.cn/">书栈网</a> <a href="https://docschina.org/">印记中文</a> <a href="https://www.javascriptc.com/">JS 中文网</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN</a> <a href="https://vue3js.cn/">vue3</a> <a href="https://cn.vuejs.org/">vue</a> <a href="https://react.docschina.org/">react</a> <a href="https://angular.cn/">angular</a> <a href="https://www.yuque.com/dashboard/">语雀</a> <a href="https://www.kancloud.cn/jsfront/month/1897005">看云 js 月报</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247487217&idx=2&sn=85f731a43b93b57230a7919945a7ae0d&chksm=fa2bee18cd5c670e9d0f2546fff7e579c416aa85fb4bf49223277ffb61624f99f6b50805902b&scene=126&sessionid=1606197281&key=b446d8ff764b323102bbb0c113388de17012eba1572ae079f7de09d4953d2d1bf50d1d2090b81c2dfc588fcff11bf70221158523c35e204a1efb7892811bf190ab4421d811a457fdc3900bfed451eb8448891ba49a6aa823bab680777e2c6eafae438fa434c108f7bf67b1397b3f1dca3dd4c3a5b661ebfefd647f8ebb7179cf&ascene=1&uin=MjQ4OTg5MDk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AbqEAQXqtW+qx3SZA80qofI=&pass_ticket=EgQTrjNMllPeNIVkI9qHCXD/LxBZ2Z/8w6sriw+i2SdOdjARLD0NCMZcPJQLNT7e&wx_header=0">编码规范</a></p>
<p><a href="https://kaiwu.lagou.com/xunlianying/index.html?courseId=25#/course">拉钩教育</a><br><a href="https://time.geekbang.org/">极客时间</a><br><a href="https://appf96umjwe7950.h5.xiaoeknow.com/v1/auth?appId=appF96umJwe7950&redirect_url=https://appF96umJwe7950.h5.xiaoeknow.com/homepage/30">珠峰培训</a><br><a href="https://www.kaikeba.com/">开课吧</a></p>
<h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><ul>
<li><a href="https://codepen.io/">CodePen | 前端在线测试和演示工具 国外站点</a></li>
<li><a href="https://caniuse.com/">Can I use | Web 前端兼容性列表</a></li>
<li><a href="https://tinypng.com/">TinyPNG | PNG/JPG 图片在线压缩工具</a></li>
<li><a href="https://www.umeng.com/">CNZZ | 老牌站点统计工具 5 年前国内站长必上网站</a></li>
<li><a href="https://web.dev/measure/">web.dev | 评测网站性能 基于 Lighthouse</a></li>
<li><a href="https://www.shapedivider.app/">Shape Divider | 定制各种形状 SVG 的工具</a></li>
<li><a href="https://gtmetrix.com/">GTmetrix | 网页性能在线分析工具</a></li>
<li><a href="https://carbon.now.sh/">Carbon | 代码转图片工具</a></li>
<li><a href="https://www.wappalyzer.com/">Wappalyzer | 检测某个网站的技术栈</a></li>
<li><a href="https://unbug.github.io/codelf">CODEIF | 变量方法起名工具 人工智能加持</a></li>
<li><a href="https://tool.lu/">tool.lu | 程序员在线工具大全</a></li>
</ul>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul>
<li><a href="http://justjavac.com/named-function-expressions-demystified.html">命名函数表达式探秘</a> - kangax、为之漫笔(翻译) (原始地址无法打开，所以此处地址为 justjavac 博客上的备份)</li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN">你不知道的 Javascript</a></li>
<li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解 JavaScript 系列</a></li>
<li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns">学用 JavaScript 设计模式</a> - 开源中国</li>
<li><a href="https://github.com/adamlu/javascript-style-guide">Airbnb JavaScript 规范</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a> - 阮一峰</li>
<li><a href="http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html">Google JavaScript 代码风格指南</a></li>
<li><a href="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程（alpha）</a></li>
<li><a href="https://github.com/justjavac/12-javascript-quirks">javascript 的 12 个怪癖</a></li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园</a></li>
<li><a href="https://github.com/jayli/javascript-patterns">《JavaScript 模式》</a> (《JavaScript patterns》译本)</li>
<li><a href="https://web.archive.org/web/20170112164945/http://typeof.net/s/jsmech/">Javascript 原理</a></li>
<li><a href="http://liubin.github.io/promises-book/">JavaScript Promise 迷你书</a></li>
<li><a href="http://pij.robinqu.me/">Javascript 编程指南</a> (<a href="https://github.com/RobinQu/Programing-In-Javascript">源码</a>)</li>
<li><a href="http://icodeit.org/jsccp/">JavaScript 核心概念及实践</a> (PDF)</li>
</ul>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ul>
<li><a href="http://nqdeng.github.io/7-days-nodejs/">七天学会 NodeJS</a> - 阿里团队</li>
<li><a href="https://github.com/nswbmw/N-blog">使用 Express + MongoDB 搭建多人博客</a></li>
<li><a href="http://expressjs.jser.us/">express.js 中文文档</a></li>
<li><a href="http://javascript.ruanyifeng.com/nodejs/express.html">Express 框架</a></li>
<li><a href="http://nodejs.ctolib.com/docs/sfile/jstraining/engineering.html">JavaScript 全栈工程师培训材料</a></li>
<li><a href="https://github.com/guo-yu/koa-guide">koa 中文文档</a></li>
<li><a href="https://www.npmjs.com/package/learnyounode-zh-cn">Learn You The Node.js For Much Win! (中文版)</a></li>
<li><a href="http://i5ting.github.io/node-debug-tutorial/">Node debug 三法三例</a></li>
<li><a href="https://github.com/alsotang/node-lessons">Node.js 包教不包会</a></li>
<li><a href="https://github.com/jollen/nodejs-fullstack-lessons">Node.js Fullstack《從零到一的進撃》</a></li>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html">Node 入门</a></li>
<li><a href="https://github.com/nodejs-tw/nodejs-wiki-book">Nodejs Wiki Book</a> (繁体中文)</li>
<li><a href="https://www.gitbook.com/book/0532/nodejs/details">nodejs 中文文档</a></li>
<li><a href="https://www.gitbook.com/book/0532/nodejs/details">The NodeJS 中文文档</a> - 社区翻译</li>
<li><a href="https://blog.poetries.top/node-learning-notes/notes/base/01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">Node.js 学习指南</a></li>
<li><a href="https://theanarkh.github.io/understand-nodejs/">Node.js 源码剖析</a></li>
</ul>
<h2 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h2><ul>
<li><a href="https://github.com/theJian/build-a-hn-front-page">Learn React &amp; Webpack by building the Hacker News front page</a></li>
<li><a href="https://github.com/hateonion/react-bits-CN">React-Bits 中文文档</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/react-native/">React Native 中文文档(含最新 Android 内容)</a></li>
<li><a href="https://github.com/fakefish/react-webpack-cookbook">React webpack-cookbook</a></li>
<li><a href="http://fraserxu.me/intro-to-react/">React.js 入门教程</a></li>
<li><a href="https://discountry.github.io/react/">React.js 中文文档</a></li>
<li><a href="https://github.com/sxfad/react-admin/">基于 Ant Design React 的管理系统架构</a></li>
<li><a href="https://react.jokcy.me/">React 源码解析</a></li>
<li><a href="https://github.com/KieSun/awesome-frontend-source-interpretation">从源码层面，剖析前端主流技术的底层实现原理</a></li>
<li><a href="https://juejin.cn/post/6844904157829136398">React Hooks 使用详解及实际项目中遇到的坑</a></li>
<li><a href="https://github.com/beichensky/Blog/issues/6">React Hooks 常见问题及解决方案</a></li>
<li><a href="https://react.iamkasong.com/">react 技术揭秘</a></li>
<li><a href="https://github.com/puxiao/react-hook-tutorial/blob/master/03%20useState%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.md">React Hook 系列教程，学习和探索 Hooks 世界</a></li>
</ul>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><ul>
<li><a href="https://cn.vuejs.org/v2/guide/">Vue.js 中文文档</a></li>
<li><a href="https://vue3.chengpeiquan.com/">Vue3.0 学习教程与实战案例</a> - chengpeiquan</li>
<li><a href="https://vue-js.com/learn-vue/start/">Vue 源码系列</a></li>
<li><a href="https://vue3js.cn/">vue3 文档</a></li>
</ul>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><ul>
<li><p><a href="https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json">深入理解 Typescript</a></p>
</li>
<li><p><a href="https://typescript.bootcss.com/">typescript</a></p>
</li>
</ul>
<ul>
<li><a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程</a> - runoob (HTML)</li>
<li><a href="https://www.runoob.com/w3cnote/getting-started-with-typescript.html">TypeScript 入门教程</a> - runoob (HTML)</li>
<li><a href="https://www.tslang.cn/">TypeScript 中文网</a> (HTML)</li>
<li><a href="https://github.com/jkchao/typescript-book-chinese">TypeScript Deep Dive 中文版</a> - 三毛 (HTML)</li>
<li><a href="https://www.runoob.com/manual/gitbook/TypeScript/_book/">TypeScript Handbook（中文版）</a> - Patrick Zhong (HTML)</li>
</ul>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul>
<li><a href="https://web.archive.org/web/20191004044726/http://igit.linuxtoy.org:80/index.html">沉浸式学 Git</a></li>
<li><a href="http://backlogtool.com/git-guide/cn/">猴子都能懂的 GIT 入门</a></li>
<li><a href="https://learngitbranching.js.org/">学习 Git 分支</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git - 简易指南</a></li>
<li><a href="http://gitref.justjavac.com/">Git 参考手册</a></li>
<li><a href="https://github.com/flyhigher139/Git-Cheat-Sheet">Git-Cheat-Sheet</a> - flyhigher139</li>
<li><a href="http://gitbook.liuhui998.com/">Git Community Book 中文版</a></li>
<li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git-flow 备忘清单</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git magic</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git Magic</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git 教程</a> - 廖雪峰</li>
<li><a href="https://github.com/waylau/github-help">Github 帮助文档</a></li>
<li><a href="https://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/">GitHub 秘籍</a></li>
<li><a href="https://github.com/gotgit/gotgithub">Got GitHub</a></li>
<li><a href="http://www.worldhello.net/gotgithub/index.html">GotGitHub</a></li>
<li><a href="https://zh-hginit.readthedocs.io/en/latest/">HgInit (中文版)</a></li>
<li><a href="https://www.mercurial-scm.org/wiki/ChineseTutorial">Mercurial 使用教程</a></li>
<li><a href="https://git-scm.com/book/zh/v2">Pro Git</a></li>
<li><a href="https://bingohuang.gitbooks.io/progit2/content">Pro Git 第二版 中文版</a> - Bingo Huang</li>
<li><a href="http://svnbook.red-bean.com/nightly/zh/index.html">svn 手册</a></li>
</ul>
<h2 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h2><ul>
<li><a href="https://deno-tutorial.js.org/">Deno 钻研之术</a></li>
<li><a href="https://chenshenhai.com/deno_note">Deno 进阶开发笔记</a> - 大深海</li>
</ul>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><ul>
<li><a href="http://www.jianshu.com/p/q81RER">献给写作者的 Markdown 新手指南</a></li>
<li><a href="https://markdown.tw/">Markdown 語法說明</a></li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul>
<li><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html">21 分钟 MySQL 入门教程</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li>
</ul>
<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><ul>
<li><a href="https://github.com/huangz1990/annotated_redis_source">带有详细注释的 Redis 2.6 代码</a></li>
<li><a href="https://github.com/huangz1990/redis-3.0-annotated">带有详细注释的 Redis 3.0 代码</a></li>
<li><a href="http://disque.huangz.me/">Disque 使用教程</a></li>
<li><a href="http://redisdoc.com/">Redis 命令参考</a></li>
<li><a href="http://redisbook.com/">Redis 设计与实现</a></li>
<li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md">The Little MongoDB Book</a></li>
<li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md">The Little Redis Book</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>在线文档</category>
      </categories>
      <tags>
        <tag>在线文档</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/2022/03/13/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<p><img src="/2022/03/13/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>运算符优先级</category>
      </categories>
      <tags>
        <tag>运算符优先级</tag>
      </tags>
  </entry>
  <entry>
    <title>react  redux中间件</title>
    <url>/2020/10/26/react%E7%AC%94%E8%AE%B0/MiddleWare%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MiddleWare的使用"><a href="#MiddleWare的使用" class="headerlink" title="MiddleWare的使用"></a>MiddleWare的使用</h2><h3 id="1-logger中间件"><a href="#1-logger中间件" class="headerlink" title="1.logger中间件"></a>1.logger中间件</h3><p>我们改写了，dispatch方法实现了在更改状态时打印前后的状态,但是这种方案并不好。所以我们可以采用中间的方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"><span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number);</span><br><span class="line">  dispatch(action);</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="实现logger中间件"><a href="#实现logger中间件" class="headerlink" title="实现logger中间件"></a>实现logger中间件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number);</span><br><span class="line">  dispatch(action);</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState().number)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> applyMiddleWare = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function"><span class="params">reducer</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="keyword">let</span> middle = middleware(store);</span><br><span class="line">  <span class="keyword">let</span> dispatch = middle(store.dispatch);</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="comment">//将中间返回的dispatch方法覆盖掉原有store中的dispatch</span></span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> applyMiddleWare(logger)(createStore)(reducer);</span><br></pre></td></tr></table></figure>

<h3 id="2-实现redux-thunk中间件"><a href="#2-实现redux-thunk中间件" class="headerlink" title="2.实现redux-thunk中间件"></a>2.实现redux-thunk中间件</h3><p>实现派发异步动作,actionCreator可以返回函数，可以把dispatch的权限交给此函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch,getState</span>) </span>&#123;</span><br><span class="line">      dispatch(&#123;<span class="attr">type</span>:Types.ADD,amount&#125;);</span><br><span class="line">      dispatch(&#123;<span class="attr">type</span>:Types.ADD,amount&#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(getState().number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">minus</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>:Types.MINUS,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">let</span> reduxThunk = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span></span>)</span>&#123; <span class="comment">//如果是函数将派发的权限传递给函数</span></span><br><span class="line">    <span class="keyword">return</span> action(dispatch,store.getState);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现redux-promise中间件"><a href="#3-实现redux-promise中间件" class="headerlink" title="3.实现redux-promise中间件"></a>3.实现redux-promise中间件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="function"><span class="title">minus</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type:Types.MINUS,</span><br><span class="line">      payload:<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">        reject(&#123;<span class="attr">amount</span>:<span class="number">2</span>&#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//store/index.js</span></span><br><span class="line"><span class="keyword">let</span> reduxPromise = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> <span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">action.then</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> action.then(dispatch); <span class="comment">//只支持成功</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">action.payload&amp;&amp;action.payload.then</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果payload是一个promise 会对成功和失败都进行捕获并且将成功或失败的数据放到payload中进行派发</span></span><br><span class="line">    <span class="keyword">return</span> action.payload.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      dispatch(&#123;...action,<span class="attr">payload</span>:data&#125;);</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      dispatch(&#123;...action,<span class="attr">payload</span>:data&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-compose应用"><a href="#4-compose应用" class="headerlink" title="4.compose应用"></a>4.compose应用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toResult</span>(<span class="params">who,decorator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> who+decorator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们的目的是将第一个函数的返回结果传递给第二个函数</span></span><br><span class="line"><span class="built_in">console</span>.log(len(toResult(<span class="string">&#x27;Mrs jiang&#x27;</span>, <span class="string">&#x27;很帅&#x27;</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="实现compose"><a href="#实现compose" class="headerlink" title="实现compose"></a>实现compose</h4><p>这个compose也是redux中的一个方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>)=&gt;</span><span class="function">(<span class="params">...args</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last = fns.pop();</span><br><span class="line">  <span class="keyword">return</span> fns.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">prev,next</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> next(prev);</span><br><span class="line">  &#125;,last(...args))</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(compose(len, toResult)(<span class="string">&#x27;Mrs jiang&#x27;</span>, <span class="string">&#x27;很帅&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="5-applyMiddleware实现"><a href="#5-applyMiddleware实现" class="headerlink" title="5.applyMiddleware实现"></a>5.applyMiddleware实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> applyMiddleWare = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function"><span class="params">reducer</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="keyword">let</span> middles = middlewares.map(<span class="function"><span class="params">middleware</span>=&gt;</span>middleware(store))</span><br><span class="line">  <span class="keyword">let</span> dispatch = compose(...middles)(store.dispatch);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-简化applyMiddleWare应用"><a href="#6-简化applyMiddleWare应用" class="headerlink" title="6.简化applyMiddleWare应用"></a>6.简化applyMiddleWare应用</h3><p>最终实现效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer,applyMiddleware(reduxThunk,reduxPromise));</span><br></pre></td></tr></table></figure>
<p>最终版redux库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createStore = <span class="function">(<span class="params">reducer, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">let</span> listeners = [];</span><br><span class="line">    <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> state;</span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item());</span><br><span class="line">    &#125;;</span><br><span class="line">    dispatch(&#123;&#125;);</span><br><span class="line">    <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">l</span>) =&gt;</span> &#123;</span><br><span class="line">        listeners.push(l);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(createStore, reducer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        createStore,</span><br><span class="line">        dispatch,</span><br><span class="line">        getState,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> combineReducers = <span class="function">(<span class="params">reducers</span>) =&gt;</span> <span class="function">(<span class="params">newState = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> reducers) &#123;</span><br><span class="line">        newState[key] = reducers[key](newState[key], action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bindActionCreators = <span class="function">(<span class="params">actions, dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> actions) &#123;</span><br><span class="line">        obj[key] = <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(actions[key](...args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> <span class="function">(<span class="params">createStore, reducer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">    <span class="keyword">let</span> middles = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(store));</span><br><span class="line">    <span class="keyword">let</span> dispatch = compose(...middles)(store.dispatch);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...store,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = fns.pop();</span><br><span class="line">        <span class="keyword">return</span> fns.reduceRight(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next(prev);</span><br><span class="line">        &#125;, fn(...args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125;</span><br></pre></td></tr></table></figure>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react redux中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>react-redux</title>
    <url>/2020/10/25/react%E7%AC%94%E8%AE%B0/React-Redux/</url>
    <content><![CDATA[<h2 id="React-Redux应用"><a href="#React-Redux应用" class="headerlink" title="React-Redux应用"></a>React-Redux应用</h2><h3 id="1-为什么需要高阶组件"><a href="#1-为什么需要高阶组件" class="headerlink" title="1.为什么需要高阶组件"></a>1.为什么需要高阶组件</h3><p>我们先看一个非常常见的例子，一个输入框需要从本地获取数据将获取的数据放到输入框内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Username extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;val:&#39;&#39;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    let username &#x3D; localStorage.getItem(&#39;username&#39;)||&#39;&#39;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      val:username</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.val&#125; onChange&#x3D;&#123;()&#x3D;&gt;&#123;&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段逻辑可能在Password组件中也要使用，那么从本地存储中获取数据放到输入框内的逻辑应该就是公用逻辑。这时我们就要使用高阶组件，也就是将组件在原有的基础上进行包装。</p>
</blockquote>
<a id="more"></a>
<h3 id="2-实现高阶组件"><a href="#2-实现高阶组件" class="headerlink" title="2.实现高阶组件"></a>2.实现高阶组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">let local &#x3D; (key)&#x3D;&gt;(Component)&#x3D;&gt;&#123;</span><br><span class="line">  return class HighOrderComponent extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state &#x3D; &#123;val:&#39;&#39;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      let username &#x3D; localStorage.getItem(key)||&#39;&#39;;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        val:username</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return &lt;Component &#123;...this.state&#125;&#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default local;</span><br><span class="line"></span><br><span class="line">import Local from &#39;.&#x2F;Local&#39;</span><br><span class="line">class Username extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.props.val&#125; onChange&#x3D;&#123;()&#x3D;&gt;&#123;&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Local(&#39;username&#39;)(Username);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们将公共的逻辑拿到外层组件，处理好后以属性的方式传递给原本的组件，为此高阶组件就是一个 React 组件包裹着另外一个 React 组件</p>
</blockquote>
<h3 id="3-context的用法"><a href="#3-context的用法" class="headerlink" title="3.context的用法"></a>3.context的用法</h3><p>react是单向数据流，我们想传递数据需要一层层向下传递，数据传递变得非常麻烦,我们可以用context实现数据的交互</p>
<ol>
<li><p>父 childContextTypes getChildContext函数</p>
</li>
<li><p>子 contextTypes</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">App |-&gt; header -&gt; title</span><br></pre></td></tr></table></figure>

<h4 id="跨组件交互"><a href="#跨组件交互" class="headerlink" title="跨组件交互"></a>跨组件交互</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;</span><br><span class="line">import Header from &quot;.&#x2F;Header&quot;;</span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;color:&#39;red&#39;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static childContextTypes &#x3D; &#123; &#x2F;&#x2F;定义子组件上下文的类型</span><br><span class="line">    color:PropTypes.string,</span><br><span class="line">    setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  setColor &#x3D; (color) &#x3D;&gt;&#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        color</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123; &#x2F;&#x2F; 定义子组件上下文的数据</span><br><span class="line">    return &#123;color:this.state.color,setColor:this.setColor&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;Header&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Header extends React.Component &#123;</span><br><span class="line">  static contextTypes &#x3D; &#123;</span><br><span class="line">     setColor:PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;</span><br><span class="line">        this.context.setColor(&#39;green&#39;);</span><br><span class="line">      &#125;&#125;&gt;变绿&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;Title&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Title extends React.Component &#123;</span><br><span class="line">  static contextTypes &#x3D; &#123;</span><br><span class="line">    color:PropTypes.string</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123; &#x2F;&#x2F; 通过context获取父组件定义的数据</span><br><span class="line">    return &lt;div style&#x3D;&#123;&#123;color:this.context.color&#125;&#125;&gt;Title&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-使用react-redux实现todo"><a href="#4-使用react-redux实现todo" class="headerlink" title="4.使用react-redux实现todo"></a>4.使用react-redux实现todo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Todos |-&gt; TodoHeader</span><br><span class="line">      |-&gt; TodoItems</span><br><span class="line">      |-&gt; TodoFooter</span><br></pre></td></tr></table></figure>


<h3 id="5-实现react-redux库"><a href="#5-实现react-redux库" class="headerlink" title="5.实现react-redux库"></a>5.实现react-redux库</h3><h4 id="react-redux计数器"><a href="#react-redux计数器" class="headerlink" title="react-redux计数器"></a>react-redux计数器</h4><p>和以前写过的逻辑一致,这回加上react-redux的逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import Counter from &quot;.&#x2F;components&#x2F;Counter&quot;;</span><br><span class="line">import store from &#39;.&#x2F;store&#x2F;index&#39;;</span><br><span class="line">import &#123;Provider&#125; from &#39;react-redux&#39;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    &lt;Counter&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;,window.root);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; counter组件</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      数量:&#123;this.props.number&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.props.add(1)&#125;&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button  onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.props.minus(1)&#125;&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),dispatch&#x3D;&gt;(&#123;</span><br><span class="line">  add:(amount)&#x3D;&gt;&#123;dispatch(actions.add(amount))&#125;,</span><br><span class="line">  minus:(amount)&#x3D;&gt;&#123;dispatch(actions.minus(amount))&#125;</span><br><span class="line">&#125;))(Counter)</span><br></pre></td></tr></table></figure>

<h4 id="编写react-redux库"><a href="#编写react-redux库" class="headerlink" title="编写react-redux库"></a>编写react-redux库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line">class Provider extends React.Component&#123;</span><br><span class="line">  static childContextTypes &#x3D; &#123;</span><br><span class="line">    store:PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line">  getChildContext()&#123;</span><br><span class="line">    return &#123;store:this.props.store&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let connect &#x3D; (mapStateToProps,mapDispatchToProps) &#x3D;&gt; (Component) &#x3D;&gt;&#123;</span><br><span class="line">  return class Proxy extends React.Component&#123;</span><br><span class="line">    static contextTypes &#x3D; &#123;</span><br><span class="line">      store:PropTypes.object</span><br><span class="line">    &#125;;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      this.unsubscribe &#x3D; this.context.store.subscribe(()&#x3D;&gt;&#123;</span><br><span class="line">        this.setState(mapStateToProps(this.context.store.getState()))</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">      this.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(props,context)&#123;</span><br><span class="line">      super();</span><br><span class="line">      this.state &#x3D; mapStateToProps(context.store.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return &lt;Component &#123;...this.state&#125; &#123;...mapDispatchToProps(this.context.store.dispatch)&#125;&#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;Provider,connect&#125;</span><br></pre></td></tr></table></figure>


<h4 id="bindActionCreators方法"><a href="#bindActionCreators方法" class="headerlink" title="bindActionCreators方法"></a>bindActionCreators方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let bindActionCreators &#x3D; (actions,dispatch) &#x3D;&gt; &#123;</span><br><span class="line">  let obj &#x3D; &#123;&#125;</span><br><span class="line">  for(let key in actions)&#123;</span><br><span class="line">    obj[key] &#x3D; (...args)&#x3D;&gt;&#123;</span><br><span class="line">      dispatch(actions[key](...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),dispatch&#x3D;&gt;bindActionCreators(actions,dispatch))(Counter)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bindActionCreators是redux中的一个方法，并且这样的逻辑过于复杂，我们依旧希望可以在react-redux中内部可以简化操作</p>
</blockquote>
<h4 id="简化mapDispatchToProps"><a href="#简化mapDispatchToProps" class="headerlink" title="简化mapDispatchToProps"></a>简化mapDispatchToProps</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default connect(state&#x3D;&gt;(&#123;...state&#125;),actions)(Counter);</span><br><span class="line"></span><br><span class="line">import &#123;bindActionCreators&#125; from &#39;.&#x2F;redux&#39;</span><br><span class="line">render()&#123;</span><br><span class="line">  let r &#x3D;&#123;&#125;</span><br><span class="line">  if(typeof mapDispatchToProps &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">    r &#x3D; bindActionCreators(mapDispatchToProps,this.context.store.dispatch)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    r &#x3D; mapDispatchToProps(this.context.store.dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;Component &#123;...this.state&#125; &#123;...r&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样我们在组件中更改状态时可以直接传入actionCreator对象。</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react 路由的使用</title>
    <url>/2020/10/22/react%E7%AC%94%E8%AE%B0/React%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>本章我们来介绍react中路由的使用,现在使用的路由是React-Router-4版本,我们需要下载的包叫react-router-dom</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>这里我们下载好后需要他内部的路由容器组件,主要包含BrowserRouter,HashRouter,MemoryRouter</p>
</blockquote>
<h3 id="容器组件的区别"><a href="#容器组件的区别" class="headerlink" title="容器组件的区别"></a>容器组件的区别</h3><ul>
<li>BrowserRouter: 浏览器自带的H5 API,restful风格,需要配合后台；</li>
<li>HashRouter: 使用hash方式进行路由,路径后均有#；</li>
<li>MemoryRouter: 在内存中管理history，地址栏不会变化。在reactNative中使用。</li>
</ul>
<blockquote>
<p>在开发时我们一般使用HashRouter,上线后我们改用BrowserRouter</p>
</blockquote>
<h3 id="跑通基本路由"><a href="#跑通基本路由" class="headerlink" title="跑通基本路由"></a>跑通基本路由</h3><p>我们来声明三个组件Home,User,Profile希望访问不同的路径可以实现显示不同的组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter,Route&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> Home = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> Profile = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Profile<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">let</span> User = <span class="function">() =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>User<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">ReactDOM.render(&lt;HashRouter&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/home&quot;</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/profile&quot;</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;User&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/HashRouter&gt;,<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们使用了HashRouter,代码一目了然,这里用到了Route组件,Route组件上有path和component属性,对应的path会显示对应的component,这里还需注意HashRouter必须只能包含一个根元素,所以我们在所有的Route外层包了一个div标签</p>
</blockquote>
<h3 id="路由的匹配"><a href="#路由的匹配" class="headerlink" title="路由的匹配"></a>路由的匹配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们稍作了下更改当访问/profile/user时你会发现/profile路由也会命中。所以说明只要路径开头匹配成功既会显示对应的组件,假如你希望不管访问任何路径时都能显示某一个组件你可以将path写成’/‘</p>
</blockquote>
<h3 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h3><p>我们先来引入bootstrap,将刚才的代码逻辑进行拆分,增加导航条点击不同的导航显示不同的组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123;HashRouter,Route&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">import &#39;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import Home from &#39;.&#x2F;components&#x2F;Home&#39;;</span><br><span class="line">import Profile from &#39;.&#x2F;components&#x2F;Profile&#39;;</span><br><span class="line">import User from &#39;.&#x2F;components&#x2F;User&#39;;</span><br><span class="line">ReactDOM.render(&lt;HashRouter&gt;</span><br><span class="line">    &lt;App&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;App&gt;</span><br><span class="line">&lt;&#x2F;HashRouter&gt;,document.querySelector(&#39;#root&#39;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们增加了App组件,为什么这样做呢?原因是我们并不希望将所有的逻辑都写在index中,这并不方便我们的管理,还记得children属性吗？我们可以直接在App中通过children的方式引入</p>
</blockquote>
<h3 id="增加导航"><a href="#增加导航" class="headerlink" title="增加导航"></a>增加导航</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Link&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">export default class App extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;navbar-inverse navbar&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;container-fluid&quot;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&quot;navbar-header&quot;&gt;</span><br><span class="line">                            &lt;div className&#x3D;&quot;navbar-brand&quot;&gt;</span><br><span class="line">                                用户管理系统</span><br><span class="line">                            &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;ul className&#x3D;&quot;navbar-nav nav&quot;&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;home&#39;&#125;&gt;首页&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;user&#39;&#125;&gt;用户管理&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                            &lt;li&gt;</span><br><span class="line">                                &lt;Link to&#x3D;&#123;&#39;&#x2F;profile&#39;&#125;&gt;个人中心&lt;&#x2F;Link&gt;</span><br><span class="line">                            &lt;&#x2F;li&gt;</span><br><span class="line">                        &lt;&#x2F;ul&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;row&quot;&gt;</span><br><span class="line">                        &lt;div className&#x3D;&quot;col-md-12&quot;&gt;</span><br><span class="line">                            &#123;this.props.children&#125;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用Link组件它可以替代我们自己写的a标签,因为后面我们可能会用到browserHistory，跳转可能需要用到H5的api进行跳转,Link组件是react路由中提供的声明式组件,可以帮我们区分路由的模式来实现路由的跳转。</p>
</blockquote>
<h3 id="页面级组件"><a href="#页面级组件" class="headerlink" title="页面级组件"></a>页面级组件</h3><p>这里我们先将对应的组件代码代码贴出来,后面我们来完善对用的逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Home.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class Home extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Home&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Profile.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class Profile extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Profile&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; User.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class User extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;User&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h3><p>刚才我们实现了一级导航,但是一般情况下管理系统都会拥有二级导航,比如说我们希望用户管理中包含用户列表和添加用户,这两个菜单应该属于用户列表下的子导航,我们先来看下效果</p>
<h4 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h4><p>二级导航就是在某个一级路由中继续嵌套路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">import UserList from &#39;.&#x2F;UserList&#39;</span><br><span class="line">import UserAdd from &#39;.&#x2F;UserAdd&#39;</span><br><span class="line">export default class User extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className&#x3D;&quot;row&quot;&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;col-md-2&quot;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;nav nav-stacked&quot;&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to&#x3D;&#39;&#x2F;user&#x2F;list&#39;&gt;用户列表&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                        &lt;li&gt;&lt;Link to&#x3D;&#39;&#x2F;user&#x2F;add&#39;&gt;增加用户&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div className&#x3D;&quot;col-md-10&quot;&gt;</span><br><span class="line">                    &lt;Route path&#x3D;&quot;&#x2F;user&#x2F;list&quot; component&#x3D;&#123;UserList&#125;&#x2F;&gt;</span><br><span class="line">                    &lt;Route path&#x3D;&quot;&#x2F;user&#x2F;add&quot; component&#x3D;&#123;UserAdd&#125;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里并没有什么需要注意的新用法,只是路径要特殊处理一下因为是二级路由,要保证一级路由也同时显示所以开头要和一级路由路径相同。如果多次点击相同路由时会触发<code>Hash history cannot PUSH the same path;</code>这样的一个警告,这个是无法去除的但是改成BrowserHistory就不会触发此警告了。所有不用担心.</p>
</blockquote>
<h4 id="UserList和Add组件"><a href="#UserList和Add组件" class="headerlink" title="UserList和Add组件"></a>UserList和Add组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; UserList.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserList extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;UserList&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; UserAdd.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserAdd extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;UserAdd&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们先不写任何逻辑，先将具体的功能实现出来。这样我们就实现了二级路。</p>
</blockquote>
<h3 id="路由跳转和路径参数"><a href="#路由跳转和路径参数" class="headerlink" title="路由跳转和路径参数"></a>路由跳转和路径参数</h3><p>本节我们完善一下内部的逻辑,进入到添加列表页可以实现用户的添加并且可以跳转到列表页面渲染出添加的用户列表,页面间的通信我们采用localStorage。并且点击某个用户可以进入到用户详情页。</p>
<h4 id="实现添加用户"><a href="#实现添加用户" class="headerlink" title="实现添加用户"></a>实现添加用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserAdd extends React.Component&#123;</span><br><span class="line">    handleSubmit &#x3D; (e) &#x3D;&gt;&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        let localStr &#x3D; localStorage.getItem(&#39;lists&#39;);</span><br><span class="line">        let list &#x3D; JSON.parse(localStr)|| [];</span><br><span class="line">        list.push(&#123;id:Math.random(),name:this.name.value&#125;);</span><br><span class="line">        localStorage.setItem(&#39;lists&#39;,JSON.stringify(list));</span><br><span class="line">        this.props.history.push(&#39;&#x2F;user&#x2F;list&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;label htmlFor&#x3D;&quot;name&quot; className&#x3D;&quot;control-label&quot;&gt;</span><br><span class="line">                            用户名:</span><br><span class="line">                        &lt;&#x2F;label&gt;</span><br><span class="line">                        &lt;input type&#x3D;&quot;text&quot; className&#x3D;&quot;form-control&quot; ref&#x3D;&#123;x&#x3D;&gt;this.name &#x3D; x&#125;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;button className&#x3D;&quot;btn btn-primary&quot;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;form&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们在props中使用了history的API,所有通过路由渲染的组件都拥有一些路由的属性后面我们会一一介绍到。这里我们采用编程式的方式跳转了路径。</p>
</blockquote>
<h4 id="列表页展示"><a href="#列表页展示" class="headerlink" title="列表页展示"></a>列表页展示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default class UserList extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state &#x3D; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        let userList &#x3D; JSON.parse(localStorage.getItem(&#39;lists&#39;));</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            userList</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ul className&#x3D;&quot;list-group&quot;&gt;</span><br><span class="line">                    &#123;this.state.userList.map((user,index)&#x3D;&gt;(</span><br><span class="line">                        &lt;li className&#x3D;&quot;list-group-item&quot; key&#x3D;&#123;index&#125;&gt;</span><br><span class="line">                            &lt;Link to&#x3D;&#123;&quot;&#x2F;user&#x2F;detail&#x2F;&quot;+user.id&#125;&gt;&#123;user.name&#125;&lt;&#x2F;Link&gt;</span><br><span class="line">                        &lt;&#x2F;li&gt;</span><br><span class="line">                    ))&#125;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的逻辑比较简单,我们又添加了一个detail路径同样也是一个二级路由，点击用户名可以显示具体的用户id和用户名。</p>
</blockquote>
<h4 id="引入UserDetail组件"><a href="#引入UserDetail组件" class="headerlink" title="引入UserDetail组件"></a>引入UserDetail组件</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ import UserDetail from &#x27;./UserDetail&#x27;;</span></span><br><span class="line">  &lt;Route path=&quot;/user/list&quot; component=&#123;UserList&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/user/add&quot; component=&#123;UserAdd&#125;/&gt;</span><br><span class="line"><span class="addition">+ &lt;Route path=&quot;/user/detail/:id&quot; component=&#123;UserDetail&#125;/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们采用了模糊匹配的方式,这就是我们常说的路径参数。也就是说id可以代表任何值，我们可以在详情页中通过this.props.match.params.id获取到真实传入的id</p>
</blockquote>
<h4 id="UserDetail详情页"><a href="#UserDetail详情页" class="headerlink" title="UserDetail详情页"></a>UserDetail详情页</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class UserDetail extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        let &#123;id &#125; &#x3D; this.props.match.params;</span><br><span class="line">        let &#123;name&#125; &#x3D; JSON.parse(localStorage.getItem(&#39;lists&#39;)).find(item&#x3D;&gt;item.id &#x3D;&#x3D; id);</span><br><span class="line">        return (</span><br><span class="line">            &lt;table className&#x3D;&quot;table table-bordered&quot;&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;th&gt;id号&lt;&#x2F;th&gt;</span><br><span class="line">                        &lt;th&gt;标题&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;&#123;id&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;name&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;tbody&gt;</span><br><span class="line">            &lt;&#x2F;table&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要注意通过params取出的结果都是字符串类型,所有匹配到的参数都会放在match.params的属性上。</p>
</blockquote>
<h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>有的时候我们希望对路由匹配有些限制,比如说严格对某个路径进行匹配,或者匹配到某个路径时就不在匹配</p>
<h4 id="新增路由匹配"><a href="#新增路由匹配" class="headerlink" title="新增路由匹配"></a>新增路由匹配</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;App&gt;</span><br><span class="line"><span class="addition">+       &lt;Route path=&quot;/&quot; render=&#123;()=&gt;&lt;h1&gt;首页&lt;/h1&gt;&#125;/&gt;</span></span><br><span class="line"><span class="addition">+       &lt;Route path=&quot;/:name&quot; render=&#123;()=&gt;&lt;h1&gt;zfpx&lt;/h1&gt;&#125;/&gt;</span></span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;/App&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在此我们会发现当访问/home时以上<code>首页</code>和<code>zfpx</code>和<code>home组件</code>都会访问到,而我们只希望在访问/时才会显示首页,我们可以在某个Route上增加exact属性</p>
</blockquote>
<h4 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;&quot; exact render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你会发现这样就实现啦~,只会当访问/时才可以匹配到。</p>
</blockquote>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p>但是现在访问/home时我们依然有两个组件会被匹配到，我们希望匹配到一个后就停止匹配，不在继续匹配下一个路由，我们可以使用Switch组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;HashRouter,Route,Switch&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;&quot; exact render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;:name&quot; render&#x3D;&#123;()&#x3D;&gt;&lt;h1&gt;首页&lt;&#x2F;h1&gt;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;profile&quot; component&#x3D;&#123;Profile&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;user&quot; component&#x3D;&#123;User&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Switch&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在访问/home你会发现Home组件永远都不会显示出来啦！</p>
</blockquote>
<h3 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h3><p>我们想对一些路由进行屏蔽,例如登录后才能访问,这里我们在本地存一个变量来表示是否登录,增加一个登录路由，点击登录按钮将本地变量改为登录成功状态,即可以访问用户列表页面</p>
<h3 id="受保护路由"><a href="#受保护路由" class="headerlink" title="受保护路由"></a>受保护路由</h3><p>我们匹配到/user路由时要根据状态判断是否有权限，如果没权限需要跳转到登录页面，主要靠的是高阶组件的思想来实现:</p>
<h4 id="Protected组件"><a href="#Protected组件" class="headerlink" title="Protected组件"></a>Protected组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Redirect&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default (&#123;component:Component,...others&#125;)&#x3D;&gt;&#123;</span><br><span class="line">   return &lt;Route &#123;...others&#125; render&#x3D;&#123;(props)&#x3D;&gt;&#123;</span><br><span class="line">       return localStorage.getItem(&#39;loginSystem&#39;)?&lt;Component &#123;...props&#125;&#x2F;&gt;:&lt;Redirect to&#x3D;&#123;&#123;</span><br><span class="line">           pathname:&#39;&#x2F;login&#39;,</span><br><span class="line">           from:props.match.url</span><br><span class="line">       &#125;&#125;&#x2F;&gt;</span><br><span class="line">   &#125;&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Redirect组件是用来重定向的，我们新增from属性来记录当前匹配的url,为了保证登录后可以在跳回到当前匹配的路径</p>
</blockquote>
<h4 id="新增Login组件"><a href="#新增Login组件" class="headerlink" title="新增Login组件"></a>新增Login组件</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line"><span class="deletion">-   &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span></span><br><span class="line"><span class="addition">+   &lt;PrivateRoute path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span></span><br><span class="line">    &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line"><span class="addition">+   &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Login.js</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">export default class Login extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button className=&quot;btn btn-primary&quot; onClick=&#123;()=&gt;&#123;</span><br><span class="line">                    window.localStorage.setItem(&#x27;loginSystem&#x27;,true);</span><br><span class="line">                   this.props.history.push(this.props.location.from)</span><br><span class="line">                &#125;&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们发现默认点击profile会默认跳转到login组件中，点击登录可以再次跳回profile。这样我们就实现了受保护的路由。</p>
</blockquote>
<h3 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h3><p>我们想给点击后的菜单增加激活样式，同样依然采用高阶组件的方式进行包装</p>
<h4 id="实现MenuLink组件"><a href="#实现MenuLink组件" class="headerlink" title="实现MenuLink组件"></a>实现MenuLink组件</h4><p>此组件是用来替换掉原有的Link组件，并且在内部进行判断是否增加激活状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;Route,Link&#125; from &#39;react-router-dom&#39;</span><br><span class="line">export default (&#123;to,label&#125;)&#x3D;&gt;&#123;</span><br><span class="line">    return &lt;Route children&#x3D;&#123;(props)&#x3D;&gt;&#123;</span><br><span class="line">        return &lt;li className&#x3D;&#123;props.match?&#39;active&#39;:&#39;&#39;&#125;&gt;&lt;Link to&#x3D;&#123;to&#125;&gt;&#123;label&#125;&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &#125;&#125;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有个children属性和以前render不同，children无论是否路由匹配到都会执行此函数。而render只要在匹配到后才会执行</p>
</blockquote>
<h3 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h3><p>我们希望在添加页的输入框中输入内容后点击其他路由时先询问一下是否需要跳转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;show:false&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Prompt when&#x3D;&#123;this.state.show&#125; message&#x3D;&#123;location &#x3D;&gt; (</span><br><span class="line">        &#96;Are you sure you want to go to $&#123;location.pathname&#125;?&#96;</span><br><span class="line">    )&#125;&#x2F;&gt;</span><br><span class="line">    &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">            &lt;label htmlFor&#x3D;&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; className&#x3D;&quot;form-control&quot; ref&#x3D;&#123;(x)&#x3D;&gt;this.x&#x3D;x&#125;</span><br><span class="line">               onChange&#x3D;&#123;(e)&#x3D;&gt;&#123;</span><br><span class="line">                   if(e.target.value.length&gt;0)&#123;</span><br><span class="line">                       this.setState(&#123;show:true&#125;)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div className&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">            &lt;button className&#x3D;&quot;btn btn-primary&quot; &gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>监听输入框中的内容,当有内容时将状态show变为true,当需要跳转路由时Prompt的组件when属性为true就会提示对应的message,当然我们点击添加时不需要弹出,所以先将状态改为false在进行跳转即可。</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">handleSubmit=(e)=&gt;&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    let list = JSON.parse(localStorage.getItem(&#x27;lists&#x27;))||[];</span><br><span class="line">    list.push(&#123;id:Math.random(),name:this.x.value&#125;);</span><br><span class="line">    localStorage.setItem(&#x27;lists&#x27;,JSON.stringify(list));</span><br><span class="line"><span class="addition">+   this.setState(&#123;show:false&#125;,()=&gt;&#123;</span></span><br><span class="line">        this.props.history.push(&#x27;/profile/list&#x27;)</span><br><span class="line"><span class="addition">+   &#125;)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要等待状态改变后在执行跳转，因为setState是异步的所以要将跳转逻辑放的回调函数中。</p>
</blockquote>
<h2 id="NotFound页面"><a href="#NotFound页面" class="headerlink" title="NotFound页面"></a>NotFound页面</h2><p>我们需要当路由都匹配不到时显示一个404页面,增加一个404组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default class NotFound extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;NotFound&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新增404路由"><a href="#新增404路由" class="headerlink" title="新增404路由"></a>新增404路由</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;PrivateRoute path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;</span><br><span class="line"><span class="addition">+       &lt;Route component=&#123;NotFound&#125;/&gt;</span></span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们使用switch组件当全部匹配不到时会默认渲染404路由,这样我们就实现了404页面</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>react Redux</title>
    <url>/2020/10/23/react%E7%AC%94%E8%AE%B0/Redux%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><p>我们一直通过属性来进行组件中的数据传递,这种模式是非常脆弱的。在日常的开发中经常会遇到非父子组件传递的场景。原来的方式是找到共同的父级进行数据交互，这时通信就变得比较麻烦<br>我们先通过一个简单的例子实现一下redux的工作模式:</p>
<h2 id="redux的理解-提供的API"><a href="#redux的理解-提供的API" class="headerlink" title="redux的理解 提供的API"></a>redux的理解 提供的API</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createStore()</span><br><span class="line">applyMiddleWare()</span><br><span class="line">combineReducers()</span><br><span class="line">store.getState()/dispatch()/subscribe()</span><br></pre></td></tr></table></figure>
<h3 id="1-统一数据管理"><a href="#1-统一数据管理" class="headerlink" title="1).统一数据管理"></a>1).统一数据管理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">  content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.content&#x27;</span>);</span><br><span class="line">  content.innerHTML = state.content.text;</span><br><span class="line">  content.style.color = state.content.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.title&#x27;</span>);</span><br><span class="line">  title.innerHTML = state.title.text;</span><br><span class="line">  title.style.color = state.title.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line">renderApp();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们可以将renderContent,renderTitle看成两个组件将所需的数据提取到state中统一进行管理。当渲染后我们希望更改状态，封装更改状态的方法(dispatch)</p>
</blockquote>
<a id="more"></a>
<h3 id="2-实现dispatch"><a href="#2-实现dispatch" class="headerlink" title="2).实现dispatch"></a>2).实现dispatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">      state = &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要直接更改状态而是使用dispatch方法进行状态的更改,派发一个带有type的属性来进行状态的更改，但是依然无法阻止用户更改状态.</p>
</blockquote>
<h3 id="3-createStore的实现"><a href="#3-createStore的实现" class="headerlink" title="3).createStore的实现"></a>3).createStore的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = &#123;</span><br><span class="line">    title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">    content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)); <span class="comment">// 创造一份和状态同样的对象给外界来用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">      <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">        state = &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = createStore(); <span class="comment">// 拿到createStore中返回的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderContent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.content&#x27;</span>);</span><br><span class="line">  content.innerHTML = store.getState().content.text;</span><br><span class="line">  content.style.color = store.getState().content.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.title&#x27;</span>);</span><br><span class="line">  title.innerHTML = store.getState().title.text;</span><br><span class="line">  title.style.color = store.getState().title.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderContent();</span><br><span class="line">  renderTitle()</span><br><span class="line">&#125;</span><br><span class="line">renderApp();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<!-- more -->
<blockquote>
<p>我们将状态放到了createStore函数中，目的是隔离作用域，并且再内部返回深度克隆的对象，这样用户无法再通过外界更改状态。但是状态应该由我们自身来控制，应该是外界传入的，所以要将状态拿出createStore。并且判断的逻辑也应该由我们自己来编写</p>
</blockquote>
<h3 id="4-reducer的实现"><a href="#4-reducer的实现" class="headerlink" title="4).reducer的实现"></a>4).reducer的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CHANGE_TITLE_TEXT = <span class="string">&#x27;CHANGE_TITLE_TEXT&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123; </span><br><span class="line">    state  = reducer(state,action);<span class="comment">//获取对应的状态覆盖掉store中的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;&#125;); <span class="comment">// 默认传入空对象获取reducer返回的默认结果</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> initState = &#123;</span><br><span class="line">  title:&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;标题&#x27;</span>&#125;,</span><br><span class="line">  content:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>,<span class="attr">text</span>:<span class="string">&#x27;内容&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// reducer应该具有默认状态,当更改状态后使用最新的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=initState,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_TITLE_TEXT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state,<span class="attr">title</span>:&#123;...state.title,<span class="attr">text</span>:action.text&#125;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时我们已将需要自己处理的逻辑提取出来，但是我们每次dispatch时都需要自己触发视图的更新,我们希望采用发布订阅来实现。</p>
</blockquote>
<h3 id="5-订阅函数"><a href="#5-订阅函数" class="headerlink" title="5).订阅函数"></a>5).订阅函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = []; <span class="comment">// 放置所有订阅的函数</span></span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span>=&gt;</span>item());<span class="comment">//每次派发后执行订阅的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">fn</span>)=&gt;</span>&#123; <span class="comment">//主要用于订阅事件</span></span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123; <span class="comment">//返回一个移除监听的方法</span></span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span>=&gt;</span>l!==fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(renderApp); <span class="comment">//通过suscribe订阅派发时需要触发的函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>:CHANGE_TITLE_TEXT,<span class="attr">text</span>:<span class="string">&#x27;hello&#x27;</span>&#125;);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时我们redux中常用的方法已经封装完成！^_^,我们将封装好的逻辑抽离成redux.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = []; <span class="comment">// 放置所有订阅的函数</span></span><br><span class="line">  <span class="keyword">let</span> getState = <span class="function">() =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    state  = reducer(state,action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span>=&gt;</span>item());<span class="comment">//每次派发后执行订阅的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> subscribe = <span class="function">(<span class="params">fn</span>)=&gt;</span>&#123; <span class="comment">//主要用于订阅事件</span></span><br><span class="line">    listeners.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123; <span class="comment">//返回一个移除监听的方法</span></span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span>=&gt;</span>l!==fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-应用redux-js实现counter"><a href="#2-应用redux-js实现counter" class="headerlink" title="2.应用redux+js实现counter"></a>2.应用redux+js实现counter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;container&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;add&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;minus&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;redux.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> MINUS = <span class="string">&#x27;MINUS&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=&#123;number:<span class="number">0</span>&#125;,action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">      <span class="keyword">case</span> ADD:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number + action.amount&#125;;</span><br><span class="line">      <span class="keyword">case</span> MINUS:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number - action.amount&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = store.getState().number</span><br><span class="line">  &#125;</span><br><span class="line">  render();</span><br><span class="line">  store.subscribe(render);</span><br><span class="line">  add.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:ADD,<span class="attr">amount</span>:<span class="number">1</span>&#125;)</span><br><span class="line">  &#125;,<span class="literal">false</span>);</span><br><span class="line">  minus.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:MINUS,<span class="attr">amount</span>:<span class="number">2</span>&#125;)</span><br><span class="line">  &#125;,<span class="literal">false</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>由此我们使用了自己的redux库链接了原生js进行使用。</p>
</blockquote>
<h2 id="3-应用redux-react实现counter"><a href="#3-应用redux-react实现counter" class="headerlink" title="3.应用redux+react实现counter"></a>3.应用redux+react实现counter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM,&#123;render&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;./redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> MINUS = <span class="string">&#x27;MINUS&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state=&#123;number:<span class="number">0</span>&#125;,action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> ADD:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number + action.amount&#125;;</span><br><span class="line">    <span class="keyword">case</span> MINUS:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    store.subscribe( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:ADD,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    store.dispatch(&#123;<span class="attr">type</span>:MINUS,<span class="attr">amount</span>:<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleAddClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleMinusClick&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们将redux数据映射到了组件自己的状态，并且订阅了setState事件。每次状态更新时都会重新刷新组件</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>react 基础</title>
    <url>/2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React?"></a>什么是React?</h2><ul>
<li>React 是一个用于构建用户界面的JavaScript库</li>
<li>核心专注于视图,目的实现组件化开发</li>
</ul>
<h2 id="组件化的概念"><a href="#组件化的概念" class="headerlink" title="组件化的概念"></a>组件化的概念</h2><p>我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用</p>
<ul>
<li>可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部</li>
<li>可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中</li>
<li>可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</li>
</ul>
<p><em><a href="https://pan.baidu.com/s/1hsivfN2">https://pan.baidu.com/s/1hsivfN2</a></em></p>
<h2 id="跑通react开发环境"><a href="#跑通react开发环境" class="headerlink" title="跑通react开发环境"></a>跑通react开发环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install create-react-app -g</span><br><span class="line">create-react-app &lt;project-name&gt;</span><br><span class="line">cd &lt;project-name&gt; &amp;&amp; npm start</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>默认会自动安装React,react由两部分组成,分别是:</p>
</blockquote>
<ul>
<li>react.js 是 React 的核心库</li>
<li>react-dom.js 是提供与DOM相关的功能,会在window下增加ReactDOM属性,内部比较重要的方法是render,将react元素或者react组件插入到页面中。</li>
</ul>
<h2 id="简介JSX"><a href="#简介JSX" class="headerlink" title="简介JSX"></a>简介JSX</h2><ul>
<li>是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。</li>
</ul>
<blockquote>
<p>需要注意的是JSX并不是html,在JSX中属性不能包含关键字，像class需要写成className,for需要写成htmlFor,并且属性名需要采用驼峰命名法！</p>
</blockquote>
<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p>JSX其实只是一种语法糖,最终会通过<a href="https://babeljs.io/repl/">babel</a>转译成createElement语法,以下代码等价</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(&lt;div&gt;姜,&lt;span&gt;帅哥&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;);</span><br><span class="line">ReactDOM.render(React.createElement(&quot;div&quot;,null,&quot;姜,&quot;,React.createElement(&quot;span&quot;,null,&quot;帅哥&quot;)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们一般使用React.createElement来创建一个虚拟dom元素。</p>
</blockquote>
<h2 id="react元素-JSX元素"><a href="#react元素-JSX元素" class="headerlink" title="react元素/JSX元素"></a>react元素/JSX元素</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span>(<span class="params">type,props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> React = &#123;</span><br><span class="line">    <span class="function"><span class="title">createElement</span>(<span class="params">type,props=&#123;&#125;,...childrens</span>)</span>&#123;</span><br><span class="line">        childrens.length===<span class="number">1</span>?childrens = childrens[<span class="number">0</span>]:<span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type,&#123;...props,<span class="attr">children</span>:childrens&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReactElement就是虚拟dom的概念，具有一个type属性代表当前的节点类型，还有节点的属性props</p>
</blockquote>
<h2 id="模拟render实现"><a href="#模拟render实现" class="headerlink" title="模拟render实现"></a>模拟render实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> render = <span class="function">(<span class="params">eleObj,container</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 先取出第一层 进行创建真实dom</span></span><br><span class="line">    <span class="keyword">let</span> &#123;type,props&#125; = eleObj;</span><br><span class="line">    <span class="keyword">let</span> elementNode = <span class="built_in">document</span>.createElement(type); <span class="comment">// 创建第一个元素</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> attr <span class="keyword">in</span> props</span>)</span>&#123; <span class="comment">// 循环所有属性</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">attr === <span class="string">&#x27;children&#x27;</span></span>)</span>&#123; <span class="comment">// 如果是children表示有嵌套关系</span></span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> props[attr] == <span class="string">&#x27;object&#x27;</span></span>)</span>&#123; <span class="comment">// 看是否是只有一个文本节点</span></span><br><span class="line">                props[attr].forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123; <span class="comment">// 多个的话循环判断 如果是对象再次调用render方法</span></span><br><span class="line">                    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> item === <span class="string">&#x27;object&#x27;</span></span>)</span>&#123;</span><br><span class="line">                        render(item,elementNode)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123; <span class="comment">//是文本节点 直接创建即可</span></span><br><span class="line">                        elementNode.appendChild(<span class="built_in">document</span>.createTextNode(item));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 只有一个文本节点直接创建即可</span></span><br><span class="line">                elementNode.appendChild(<span class="built_in">document</span>.createTextNode(props[attr]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">attr === <span class="string">&#x27;className&#x27;</span></span>)</span>&#123; <span class="comment">// 是不是class属性 class 属性特殊处理</span></span><br><span class="line">            elementNode.setAttribute(<span class="string">&#x27;class&#x27;</span>,props[attr]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            elementNode.setAttribute(attr,props[attr]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    container.appendChild(elementNode)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JSX表达式的用法"><a href="#JSX表达式的用法" class="headerlink" title="JSX表达式的用法"></a>JSX表达式的用法</h2><ul>
<li><ol>
<li>可以放JS的执行结果</li>
</ol>
</li>
<li><ol start="2">
<li>如果换行需要用()包裹jsx代码</li>
</ol>
</li>
<li><ol start="3">
<li>可以把JSX元素当作函数的返回值</li>
</ol>
</li>
<li><ol start="4">
<li>&lt;{来判断是表达式还是js</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toResult</span>(<span class="params">&#123;name,age&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>今年&#123;name&#125;,&#123;age&#125;岁了!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrs =  [&#123;<span class="attr">name</span>:<span class="string">&#x27;zfpx&#x27;</span>,<span class="attr">age</span>:<span class="number">8</span>&#125;,,&#123;<span class="attr">name</span>:<span class="string">&#x27;姜文&#x27;</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;];</span><br><span class="line">ReactDOM.render(&lt;div&gt;</span><br><span class="line">    &#123;arrs.map((<span class="function">(<span class="params">item,index</span>)=&gt;</span>(</span><br><span class="line">        <span class="keyword">typeof</span> item===<span class="string">&#x27;object&#x27;</span>?<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;toResult(item)&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>:<span class="literal">null</span></span><br><span class="line">    )))&#125;</span><br><span class="line">&lt;/div&gt;,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>null也是合法元素,循环时需要带key属性</p>
</blockquote>
<h2 id="JSX属性"><a href="#JSX属性" class="headerlink" title="JSX属性"></a>JSX属性</h2><ul>
<li>在JSX中分为普通属性和特殊属性，像class要写成className,for要写成htmlFor</li>
<li>style要采用对象的方式</li>
<li>dangerouslyInnerHTML插入html</li>
</ul>
<h2 id="组件的特点声明方式"><a href="#组件的特点声明方式" class="headerlink" title="组件的特点声明方式"></a>组件的特点声明方式</h2><p>react元素是是组件组成的基本单位</p>
<ul>
<li>首字母必须大写,目的是为了和JSX元素进行区分</li>
<li>组件定义后可以像JSX元素一样进行使用</li>
<li>每个组件必须返回唯一的顶级JSX元素</li>
<li>可以通过render方法将组件渲染成真实DOM</li>
</ul>
<h2 id="组件的两种定义方式"><a href="#组件的两种定义方式" class="headerlink" title="组件的两种定义方式"></a>组件的两种定义方式</h2><p>react怎么区分是组件还是jsx元素？组件名需要开头大写，react组件当作jsx来进行使用</p>
<ul>
<li>第一种方式是函数声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Build</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125; &#123;props.age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">render(&lt;div&gt;</span><br><span class="line">    &lt;Build name=&#123;school1.name&#125; age=&#123;school1.age&#125;/&gt;</span><br><span class="line">    &lt;Build &#123;...school2&#125; /&gt;</span><br><span class="line">&lt;/div&gt;,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方式是类声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;name,age&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name&#125; &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类声明有状态，this，和声明周期</p>
</blockquote>
<h2 id="组件中属性和状态的区别"><a href="#组件中属性和状态的区别" class="headerlink" title="组件中属性和状态的区别"></a>组件中属性和状态的区别</h2><ul>
<li>组件的数据来源有两个地方<ul>
<li>props 外界传递过来的(默认属性，属性校验)</li>
<li>state 状态是自己的,改变状态唯一的方式就是setState</li>
</ul>
</li>
</ul>
<blockquote>
<p>属性和状态的变化都会影响视图更新</p>
</blockquote>
<h2 id="setState-使用"><a href="#setState-使用" class="headerlink" title="setState 使用"></a>setState 使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setState(partialState, callback)</span><br><span class="line"><span class="number">1.</span> partialState : object|<span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">⽤于产⽣与当前<span class="title">state</span>合并的⼦集。</span></span><br><span class="line"><span class="function">2. <span class="title">callback</span> : <span class="function"><span class="keyword">function</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">state</span>更新之后被调⽤。</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SetStatePage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>(props);</span><br><span class="line"> <span class="built_in">this</span>.state = &#123;</span><br><span class="line"> counter: <span class="number">0</span></span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.setState(&#123;</span><br><span class="line"> counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line"> &#125;;</span><br><span class="line"> setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; counter &#125; = <span class="built_in">this</span>.state;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h3&gt;SetStatePage&lt;/h3&gt;</span><br><span class="line"> &lt;button onClick=&#123;<span class="built_in">this</span>.setCounter&#125;&gt;&#123;counter&#125;&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>setState只有在合成事件和⽣命周期函数中是异步的，在原⽣事件和setTimeout中都是同步<br>的，这⾥的异步其实是批量更新。<br>要获取到最新状态值有以下⽅式</p>
<ul>
<li><p>在回调中获取状态值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(</span><br><span class="line">  &#123;</span><br><span class="line">  counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line">  &#125;,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;counter&quot;</span>, <span class="built_in">this</span>.state.counter);</span><br><span class="line">  &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使⽤定时器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setCounter();</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>原⽣事件中修改状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.changeValue, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>传入对象 setState 的更新会被合并 执行最后一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="built_in">this</span>.state.counter + v</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入函数实现链式更新state</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">changeValue = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">counter</span>: state.counter + v &#125;));</span><br><span class="line">&#125;;</span><br><span class="line">setCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">this</span>.changeValue(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><ul>
<li>给元素绑定事件，事件绑定方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123; <span class="comment">//组件渲染完成，当渲染后会自动触发此函数</span></span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 箭头函数 否则this 指向的是window</span></span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;)</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123; <span class="comment">//组件将要卸载，当组件移除时会调用</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer); <span class="comment">//一般在这个方法中 清除定时器和绑定的事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    destroy=<span class="function">()=&gt;</span>&#123; <span class="comment">//es7 箭头函数</span></span><br><span class="line">        <span class="comment">// 删除某个组件</span></span><br><span class="line">        ReactDOM.unmountComponentAtNode(<span class="built_in">window</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 给react元素绑定事件默认this是undefined,bind方式 在就是箭头函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.destroy&#125;</span>&gt;</span>&#123;this.state.date&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行顺序 constructor -&gt; render -&gt; componentDidMount -&gt; setState-&gt; render - onClick-&gt; unmountComponentAtNode -&gt; componentWillUnmount -&gt; clearInterval</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>给jsx元素绑定事件要注意事件中的this指向，事件名采用 on+”开头大写事件名”的方式</p>
</blockquote>
<h2 id="属性校验-默认属性"><a href="#属性校验-默认属性" class="headerlink" title="属性校验,默认属性"></a>属性校验,默认属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>; <span class="comment">//引入属性校验的模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123; <span class="comment">// 类上的属性就叫静态属性</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123; <span class="comment">// 校验属性的类型和是否必填</span></span><br><span class="line">        age:PropTypes.number.isRequired, <span class="comment">// 支持的类型可以参考prop-types的readme文件</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123; <span class="comment">// 先默认调用defaultProps</span></span><br><span class="line">        name:<span class="string">&#x27;珠峰&#x27;</span>,</span><br><span class="line">        age:<span class="number">1</span></span><br><span class="line">    &#125;; <span class="comment">// 默认属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123; <span class="comment">//如果想在构造函数中拿到属性需要通过参数的方式</span></span><br><span class="line">         <span class="comment">//不能在组件中更改属性 不能修改属性*</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.name&#125; &#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>propTypes和defaultProps名字不能更改，这是react规定好的名称</p>
</blockquote>
<h2 id="状态的使用"><a href="#状态的使用" class="headerlink" title="状态的使用"></a>状态的使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    handleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// setState方法会进行合并 setState有两种写法 一种是对象一种是函数</span></span><br><span class="line">        <span class="comment">/*this.setState(&#123;count:this.state.count+1&#125;);</span></span><br><span class="line"><span class="comment">          this.setState(&#123;count:this.state.count+1&#125;);*/</span></span><br><span class="line">        <span class="comment">//this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;)); //如果返回的就是一个对象可以用小括号包裹</span></span><br><span class="line">        <span class="comment">//this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;));</span></span><br><span class="line">        <span class="comment">// 下一个状态是依赖于上一个状态时需要写成函数的方式</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;); <span class="comment">// 这个写法等同于 this.setState((prevState)=&gt;(&#123;count:prevState.count+1&#125;));</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果设置多个状态setState会合并，如果下一个状态依赖于上一个状态，需要写成函数的方式</p>
</blockquote>
<h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><p>复合组件就是将多个组件进行组合，结构非常复杂时可以把组件分离开</p>
<h3 id="不具名"><a href="#不具名" class="headerlink" title="不具名"></a>不具名</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> TopBar <span class="keyword">from</span> <span class="string">&quot;../components/TopBar&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> BottomBar <span class="keyword">from</span> <span class="string">&quot;../components/BottomBar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title = <span class="string">&quot;商城&quot;</span> &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="built_in">document</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children, showTopBar, showBottomBar &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;children&quot;</span>, children);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;showTopBar &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">TopBar</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;children.content&#125;</span><br><span class="line">        &#123;children.txt&#125;</span><br><span class="line">        &lt;button onClick=&#123;children.btnClick&#125;&gt;button&lt;/button&gt;</span><br><span class="line">        &#123;showBottomBar &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">BottomBar</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&quot;./Layout&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout showTopBar=&#123;<span class="literal">true</span>&#125; showBottomBar=&#123;<span class="literal">true</span>&#125; title=<span class="string">&quot;⽤用户中⼼心&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;UserPage&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/Layout&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="具名（传个对象进去）"><a href="#具名（传个对象进去）" class="headerlink" title="具名（传个对象进去）"></a>具名（传个对象进去）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&quot;./Layout&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout showTopBar=&#123;<span class="literal">false</span>&#125; showBottomBar=&#123;<span class="literal">true</span>&#125; title=<span class="string">&quot;商城⾸首⻚页&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;</span><br><span class="line">          content: (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;h3&gt;HomePage&lt;/h3&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          ),</span><br><span class="line">          txt: <span class="string">&quot;这是个⽂文本&quot;</span>,</span><br><span class="line">          btnClick: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;btnClick&quot;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;/Layout&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panel</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;header,body&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;panel-default panel&quot;</span>&gt;</span><br><span class="line">                    &lt;Header head=&#123;header&#125;&gt;&lt;/Header&gt;</span><br><span class="line">                    &lt;Body b=&#123;body&#125;/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// react种需要将属性一层层向下传递 单向数据流</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span>&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>&#123;this.props.head&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">header</span>:<span class="string">&#x27;我非常帅&#x27;</span>,<span class="attr">body</span>:<span class="string">&#x27;长的帅&#x27;</span>&#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Panel</span> &#123;<span class="attr">...data</span>&#125;/&gt;</span></span>,<span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

<h3 id="子父组件的通信"><a href="#子父组件的通信" class="headerlink" title="子父组件的通信"></a>子父组件的通信</h3><p>通过父亲传递给儿子一个函数，儿子调用父亲的函数将值传递给父亲,父亲更新值，刷新视图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panel</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">color</span>:<span class="string">&#x27;primary&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    changeColor=<span class="function">(<span class="params">color</span>)=&gt;</span>&#123; <span class="comment">//到时候儿子传递一个颜色</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;color&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div className=&#123;<span class="string">&quot;panel-&quot;</span>+<span class="built_in">this</span>.state.color+<span class="string">&quot; panel&quot;</span>&#125;&gt;</span><br><span class="line">                    &lt;Header head=&#123;<span class="built_in">this</span>.props.header&#125;</span><br><span class="line">                            change=&#123;<span class="built_in">this</span>.changeColor&#125;</span><br><span class="line">                    &gt;&lt;/Header&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    handleClick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props.change(<span class="string">&#x27;danger&#x27;</span>); <span class="comment">//调用父亲的方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;panel-heading&quot;</span>&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.head&#125; &lt;button className=<span class="string">&quot;btn btn-danger&quot;</span> onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;改颜色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h2><ul>
<li>受状态控制的组件，必须要有onChange方法，否则不能使用</li>
<li>受控组件可以赋予默认值（官方推荐使用 受控组件）</li>
</ul>
<h3 id="实现双向数据绑定"><a href="#实现双向数据绑定" class="headerlink" title="实现双向数据绑定"></a>实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">val</span>:<span class="string">&#x27;100&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123; <span class="comment">//e是事件源</span></span><br><span class="line">        <span class="keyword">let</span> val = e.target.value;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;val&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;<span class="built_in">this</span>.state.val&#125; onChange=&#123;<span class="built_in">this</span>.handleChange&#125;/&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.val&#125;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key表示的就是当前状态改的是哪一个</span></span><br><span class="line">    <span class="comment">// e表示的是事件源</span></span><br><span class="line">    <span class="function"><span class="title">handleChange</span>(<span class="params">key,e</span>)</span>&#123; <span class="comment">//处理多个输入框的值映射到状态的方法</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            [key]:<span class="built_in">parseInt</span>(e.target.value) || <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> value=&#123;<span class="built_in">this</span>.state.a&#125; onChange=&#123;<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">this</span>.handleChange(<span class="string">&#x27;a&#x27;</span>,e)&#125;&#125;/&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> value=&#123;<span class="built_in">this</span>.state.b&#125; onChange=&#123;<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">this</span>.handleChange(<span class="string">&#x27;b&#x27;</span>,e)&#125;&#125;/&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.a+<span class="built_in">this</span>.state.b&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state =  &#123;<span class="attr">result</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过ref设置的属性 可以通过this.refs获取到对应的dom元素</span></span><br><span class="line">    handleChange = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="built_in">this</span>.refs.a.value + <span class="built_in">this</span>.b.value;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;result&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div onChange=&#123;<span class="built_in">this</span>.handleChange&#125;&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> ref=<span class="string">&quot;a&quot;</span>/&gt;</span><br><span class="line">                &#123;<span class="comment">/*x代表的真实的dom,把元素挂载在了当前实例上*/</span>&#125;</span><br><span class="line">                &lt;input type=<span class="string">&quot;number&quot;</span> ref=&#123;<span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.b = x;</span><br><span class="line">                &#125;&#125;/&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.result&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123; <span class="comment">// 他会比较两个状态相等就不会刷新视图 PureComponent是浅比较</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name:<span class="string">&#x27;珠峰培训&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1.constructor构造函数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取本地的数据 同步的方式：采用渲染之前获取数据，只渲染一次</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2.组件将要加载 componentWillMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4.组件挂载完成 componentDidMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">number</span>:<span class="built_in">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// react可以shouldComponentUpdate方法中优化 PureComponent 可以帮我们做这件事</span></span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123; <span class="comment">// 代表的是下一次的属性 和 下一次的状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5.组件是否更新 shouldComponentUpdate&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> nextState.number%<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// return nextState.number!==this.state.number; //如果此函数种返回了false 就不会调用render方法了</span></span><br><span class="line">  &#125; <span class="comment">//不要随便用setState 可能会死循环</span></span><br><span class="line">  <span class="function"><span class="title">componentWillUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6.组件将要更新 componentWillUpdate&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7.组件完成更新 componentDidUpdate&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3.render&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.number&gt;<span class="number">3</span>?<span class="literal">null</span>:<span class="xml"><span class="tag">&lt;<span class="name">ChildCounter</span> <span class="attr">n</span>=<span class="string">&#123;this.state.number&#125;/</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCounter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;组件将要卸载componentWillUnmount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentWillMount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child-render&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">      &#123;<span class="built_in">this</span>.props.n&#125;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentDidMount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">newProps</span>)</span>&#123; <span class="comment">// 第一次不会执行，之后属性更新时才会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child componentWillReceiveProps&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextProps.n%<span class="number">3</span>; <span class="comment">//子组件判断接收的属性 是否满足更新条件 为true则更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defaultProps</span></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="comment">// componentWillMount</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br><span class="line"><span class="comment">// 状态更新会触发的</span></span><br><span class="line"><span class="comment">// shouldComponentUpdate nextProps,nextState=&gt;boolean</span></span><br><span class="line"><span class="comment">// componentWillUpdate</span></span><br><span class="line"><span class="comment">// componentDidUpdate</span></span><br><span class="line"><span class="comment">// 属性更新</span></span><br><span class="line"><span class="comment">// componentWillReceiveProps newProps</span></span><br><span class="line"><span class="comment">// 卸载</span></span><br><span class="line"><span class="comment">// componentWillUnmount</span></span><br></pre></td></tr></table></figure>

<h3 id="16-3-之前的"><a href="#16-3-之前的" class="headerlink" title="16.3 之前的"></a>16.3 之前的</h3><p><img src="/2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/react15.png" alt="lifeCycle"></p>
<h3 id="16-3-之后的"><a href="#16-3-之后的" class="headerlink" title="16.3 之后的"></a>16.3 之后的</h3><p><img src="/2020/10/21/react%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E7%AF%87/react16.3.png" alt="lifeCycle"><br>V17可能会废弃的三个⽣生命周期函数⽤用getDerivedStateFromProps替代，⽬目前使⽤用的话加上UNSAFE_：</p>
<ul>
<li><p>componentWillMount</p>
</li>
<li><p>componentWillReceiveProps</p>
</li>
<li><p>componentWillUpdate<br>引⼊入两个新的⽣生命周期函数：</p>
</li>
<li><p>static getDerivedStateFromProps<br>  getDerivedStateFromProps 会在调⽤用 render ⽅方法之前调⽤用，并且在初始挂载及后续更更新时都会被<br>  调⽤用。它应返回⼀一个对象来更更新 state，如果返回 null 则不不更更新任何内容。<br>  请注意，不不管原因是什什么，都会在 每次 渲染前触发此⽅方法。这与UNSAFE_componentWillReceiveProps 形成对⽐比，后者仅在⽗父组件重新渲染时触发，而不不是在内部调⽤用  setState 时。</p>
</li>
<li><p>getSnapshotBeforeUpdate<br>  getSnapshotBeforeUpdate(prevProps, prevState)<br>  在render之后，在componentDidUpdate之前<br>  getSnapshotBeforeUpdate() 在最近⼀一次渲染输出（提交到 DOM 节点）之前调⽤用。它使得组件能<br>在发⽣生更更改之前从 DOM 中捕获⼀一些信息（例例如，滚动位置）。此⽣生命周期的任何返回值将作为参数传<br>递给  componentDidUpdate(prevProps, prevState, snapshot)</p>
</li>
</ul>
<p>如果不不想⼿手动给将要废弃的⽣生命周期添加  UNSAFE_ 前缀，可以⽤用下⾯面的命令。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npx react-codemod <span class="built_in">rename</span>-unsafe-lifecycles &lt;<span class="built_in">path</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="react-资源"><a href="#react-资源" class="headerlink" title="react 资源"></a>react 资源</h2><ul>
<li><p><a href="https://juejin.cn/post/6950063294270930980">React全部api解读</a></p>
</li>
<li><p><a href="https://github.com/carlleton/reactjs101/tree/zh-CN">react从0学习</a></p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>react-hooks</title>
    <url>/2020/10/25/react%E7%AC%94%E8%AE%B0/react-hooks/</url>
    <content><![CDATA[<h2 id="认识-hooks"><a href="#认识-hooks" class="headerlink" title="认识 hooks"></a>认识 hooks</h2><ul>
<li><p>Hook 是⼀一个特殊的函数，它可以让你“钩⼊入” React 的特性。例例如， useState 是允许你在 React 函数组件中添加 state 的 Hook</p>
</li>
<li><p>如果你在编写函数组件并意识到需要向其添加⼀一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使⽤用 Hook</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使⽤-Effect-Hook"><a href="#使⽤-Effect-Hook" class="headerlink" title="使⽤ Effect Hook"></a>使⽤ Effect Hook</h2><ul>
<li>Effect Hook 可以让你在函数组件中执⾏行行副作⽤用操作。<br>数据获取，设置订阅以及⼿手动更更改 React 组件中的 DOM 都属于副作⽤用。不不管你知不不知道这些操作，或<br>是“副作⽤用”这个名字，应该都在组件中使⽤用过它们。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 与 componentDidMount 和 componentDidUpdate相似</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更更新 title</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数组件主体内（这⾥里里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器器、记录⽇日志以及执<br>⾏行行其他包含副作⽤用的操作都是不不被允许的，因为这可能会产⽣生莫名其妙的 bug 并破坏 UI 的⼀一致性。<br>使⽤用 useEffect 完成副作⽤用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执⾏行行。你可以<br>把 effect 看作从 React 的纯函数式世界通往命令式世界的逃⽣生通道。</p>
<h2 id="effect-的条件执⾏"><a href="#effect-的条件执⾏" class="headerlink" title="effect 的条件执⾏"></a>effect 的条件执⾏</h2><p>默认情况下，effect 会在每轮组件渲染完成后执⾏行行。这样的话，⼀一旦 effect 的依赖发⽣生变化，它就会被<br>重新创建。<br>然⽽而，在某些场景下这么做可能会矫枉过正。⽐比如，在上⼀一章节的订阅示例例中，我们不不需要在每次组件<br>更更新时都创建新的订阅，⽽而是仅需要在 source props 改变时重新创建。<br>要实现这⼀一点，可以给 useEffect 传递第⼆二个参数，它是 effect 所依赖的值数组。更更新后的示例例如<br>下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明⼀一个叫 “count” 的 state 变量量，初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  <span class="comment">// 与 componentDidMount 和 componentDidUpdate相似</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更更新 title</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;HookPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;p&gt;&#123;date.toLocaleTimeString()&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，只有当 useEffect 第⼆二个参数数组⾥里里的数值 改变后才会重新创建订阅</p>
<h2 id="清除-effect"><a href="#清除-effect" class="headerlink" title="清除 effect"></a>清除 effect</h2><p>组件卸载时需要清除 effect 创建的诸如订阅或计时器器 ID 等资源。要实现这⼀一点， useEffect<br>函数需返回⼀一个清除函数，以防⽌止内存泄漏漏，清除函数会在组件卸载前执⾏行行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h2 id="自定义-hooks"><a href="#自定义-hooks" class="headerlink" title="自定义 hooks"></a>自定义 hooks</h2><p>自定义 Hook 是⼀一个函数，其名称以 “use” 开头，函数内部可以调⽤用其他的 Hook。<br><code>&lt;p&gt;&#123;useClock().toLocaleTimeString()&#125;&lt;/p&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//⾃自定义hook，命名必须以use开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useClock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [date, setDate] = useState(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;date effect&quot;</span>);</span><br><span class="line">    <span class="comment">//只需要在didMount时候执⾏行行就可以了了</span></span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setDate(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//清除定时器器，类似willUnmount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hooks-使用规则"><a href="#hooks-使用规则" class="headerlink" title="hooks 使用规则"></a>hooks 使用规则</h2><ul>
<li>只能在函数最外层调⽤用 Hook。不不要在循环、条件判断或者⼦子函数中调⽤用。</li>
<li>只能在 React 的函数组件中调⽤用 Hook。不不要在其他 JavaScript 函数中调⽤用。（还有⼀一个地⽅方可<br>以调⽤用 Hook —— 就是⾃自定义的 Hook 中。）</li>
</ul>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>把“创建”函数和依赖项数组作为参数传⼊入 useMemo ，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进⾏行行⾼高开销的计算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseMemoPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> expensive = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;compute&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//只有count变化，这⾥里里才重新执⾏行行</span></span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;UseMemoPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;expensive:&#123;expensive&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;input value=&#123;value&#125; onChange=&#123;<span class="function">(<span class="params">event</span>) =&gt;</span> setValue(event.target.value)&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>把内联回调函数及依赖项数组作为参数传⼊入 useCallback ，它将返回该回调函数的 memoized 版本，<br>该回调函数仅在某个依赖项改变时才会更更新。当你把回调函数传递给经过优化的并使⽤用引⽤用相等性去避<br>免⾮非必要渲染（例例如 shouldComponentUpdate ）的⼦子组件时，它将⾮非常有⽤用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback, PureComponent &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseCallbackPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> addClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;UseCallbackPage&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;input value=&#123;value&#125; onChange=&#123;<span class="function">(<span class="params">event</span>) =&gt;</span> setValue(event.target.value)&#125; /&gt;</span><br><span class="line">      &lt;Child addClick=&#123;addClick&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;child render&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; addClick &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;Child&lt;/h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(addClick())&#125;&gt;add&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) 。</code><br>依赖项数组不不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引⽤用的<br>值都应该出现在依赖项数组中。未来编译器器会更更加智能，届时⾃自动创建数组将成为可能</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react-hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer</title>
    <url>/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Buffer/</url>
    <content><![CDATA[<h2 id="什么是Buffer"><a href="#什么是Buffer" class="headerlink" title="什么是Buffer"></a>什么是Buffer</h2><ul>
<li>缓冲区Buffer是暂时存放输入输出数据的一段内存。</li>
<li>JS语言没有二进制数据类型，而在处理TCP和文件流的时候，必须要处理二进制数据。</li>
<li>NodeJS提供了一个Buffer对象来提供对二进制数据的操作</li>
<li>是一个表示固定内存分配的全局对象，也就是说要放到缓存区中的字节数需要提前确定</li>
<li>Buffer好比由一个8位字节元素组成的数组，可以有效的在JavasScript中表示二进制数据</li>
</ul>
<h2 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h2><ul>
<li>字节(Byte)是计算机存储时的一种计量单位，一个字节等于8位二进制数</li>
<li>一个位就代表一个0或1，每8个位（bit）组成一个字节（Byte）</li>
<li>字节是通过网络传输信息的基本单位</li>
<li>一个字节最大值十进制数是255(2**8-1)</li>
</ul>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li><p>0b 2进制</p>
</li>
<li><p>0x 16进制</p>
</li>
<li><p>0o 8进制</p>
</li>
<li><p>将任意进制字符串转换为十进制</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;11&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;77&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;e7&quot;</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>将10进制转换为其它进制字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">3</span>).toString(<span class="number">2</span>)</span><br><span class="line">(<span class="number">17</span>).toString(<span class="number">16</span>)</span><br><span class="line">(<span class="number">33</span>).toString(<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<h2 id="定义buffer的三种方式"><a href="#定义buffer的三种方式" class="headerlink" title="定义buffer的三种方式"></a>定义buffer的三种方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.alloc(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.alloc(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf3 = Buffer.allocUnsafe(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf4 = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正常情况下为0-255之间;</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf5 = Buffer.from(<span class="string">&#x27;珠峰培训&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="buffer常用方法"><a href="#buffer常用方法" class="headerlink" title="buffer常用方法"></a>buffer常用方法</h2><p><code>buf.fill(value[, offset[, end]][, encoding])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buffer.fill(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>buf.write(string[, offset[, length]][, encoding])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.allocUnsafe(<span class="number">6</span>);</span><br><span class="line">buffer.write(<span class="string">&#x27;珠&#x27;</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">buffer.write(<span class="string">&#x27;峰&#x27;</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;utf8&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过指定的 <code>offset</code> 将 <code>value</code> 写入到当前 Buffer 中。</li>
<li>这个 value 应当是一个有效的有符号的8位整数</li>
</ul>
<p><code>buf.writeInt8(value, offset[, noAssert])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">4</span>);</span><br><span class="line">buf.writeInt8()</span><br><span class="line">buf.writeInt8(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">buf.writeInt8(<span class="number">16</span>,<span class="number">1</span>);</span><br><span class="line">buf.writeInt8(<span class="number">32</span>,<span class="number">2</span>);</span><br><span class="line">buf.writeInt8(<span class="number">48</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.readInt8(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序。</p>
<ul>
<li>Big-endian：将高序字节存储在起始地址（高位编址）</li>
<li>Little-endian：将低序字节存储在起始地址（低位编址）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.alloc(<span class="number">4</span>);</span><br><span class="line">buffer.writeInt16BE(<span class="number">2</span>**<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.readInt16BE(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">buffer.writeInt16LE(<span class="number">2</span>**<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.readInt16LE(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p><code>buf.toString([encoding[, start[, end]]])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰架构&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.toString(<span class="string">&#x27;utf8&#x27;</span>,<span class="number">3</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p><code>buf.slice([start[, end]])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰架构&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> subBuffer = buffer.slice(<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subBuffer.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;StringDecoder&#125;  = <span class="built_in">require</span>(<span class="string">&#x27;string_decoder&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sd = <span class="keyword">new</span> StringDecoder();</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sd.write(buffer.slice(<span class="number">0</span>,<span class="number">4</span>)));</span><br><span class="line"><span class="built_in">console</span>.log(sd.write(buffer.slice(<span class="number">4</span>)));</span><br></pre></td></tr></table></figure>

<ul>
<li>复制Buffer 把多个buffer拷贝到一个大buffer上</li>
</ul>
<p><code>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰架构&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> subBuffer = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subBuffer.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Buffer.prototype.copy = <span class="function"><span class="keyword">function</span>(<span class="params">targetBuffer,targetStart,sourceStart,sourceEnd</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=sourceStart;ithis[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">&#x27;珠峰&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> subBuffer = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">buffer.copy(subBuffer,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subBuffer.toString());</span><br></pre></td></tr></table></figure>

<p><code>Buffer.concat(list[, totalLength])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">&#x27;珠&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">&#x27;峰&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.concat([buffer1,buffer2]);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Buffer.concat = <span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> totalLength = list.reduce(<span class="function">(<span class="params">len, item</span>) =&gt;</span> len + item.length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (list.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> newBuffer = Buffer.alloc(totalLength);</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> buffer <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> byte <span class="keyword">of</span> buffer) &#123;</span><br><span class="line">            newBuffer[pos++] = byte;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newBuffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">&#x27;珠&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">&#x27;峰&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.concat([buffer1, buffer2]);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.toString());</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否是buffer</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Buffer.isBuffer();</span><br></pre></td></tr></table></figure>

<ul>
<li>获取字节长度(显示是字符串所代表buffer的长度)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;珠峰&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(str);</span><br><span class="line"><span class="built_in">console</span>.log(Buffer.byteLength(buffer));</span><br></pre></td></tr></table></figure>

<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><ul>
<li>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一</li>
<li>Base64就是一种基于64个可打印字符来表示二进制数据的方法</li>
<li>Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3 _8 = 4_6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CHARTS = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> buf = Buffer.from(str);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> b <span class="keyword">of</span> buf</span>)</span>&#123;</span><br><span class="line">      result += b.toString(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.match(<span class="regexp">/(\d&#123;6&#125;)/g</span>).map(<span class="function"><span class="params">val</span>=&gt;</span><span class="built_in">parseInt</span>(val,<span class="number">2</span>)).map(<span class="function"><span class="params">val</span>=&gt;</span>CHARTS[val]).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = transfer(<span class="string">&#x27;珠&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端整理</category>
      </categories>
      <tags>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>react Redux深入</title>
    <url>/2020/10/24/react%E7%AC%94%E8%AE%B0/Redux%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Redux深入"><a href="#Redux深入" class="headerlink" title="Redux深入"></a>Redux深入</h2><h3 id="1-redux文件拆分"><a href="#1-redux文件拆分" class="headerlink" title="1.redux文件拆分"></a>1.redux文件拆分</h3><p>我们将计数器的案例进行文件拆分,使代码更加容易维护和阅读,我们来增加一个store文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store</span><br><span class="line">    │  action-types.js</span><br><span class="line">    │  index.js</span><br><span class="line">    │</span><br><span class="line">    ├─actions</span><br><span class="line">    │      counter.js</span><br><span class="line">    │</span><br><span class="line">    └─reducer</span><br><span class="line">            counter.js</span><br></pre></td></tr></table></figure>

<ul>
<li><p>action-types用来存放需要的常量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const ADD &#x3D; &#39;ADD&#39;;</span><br><span class="line">export const MINUS &#x3D; &#39;MINUS&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>counter中存放reducer的逻辑</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default function reducer(state&#x3D;&#123;number:0&#125;,action) &#123;</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case Types.ADD:</span><br><span class="line">      return &#123;number:state.number + action.amount&#125;;</span><br><span class="line">    case Types.MINUS:</span><br><span class="line">      return &#123;number:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>store中的index文件用来创建store</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createStore&#125; from &#39;..&#x2F;redux&#39;;</span><br><span class="line">import reducer from &#39;.&#x2F;reducer&#x2F;counter&#39;;</span><br><span class="line">export default createStore(reducer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中的内容可更改为</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class="line">import ReactDOM,&#123;render&#125; from &#39;react-dom&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line">import * as Types from &#39;.&#x2F;store&#x2F;action-types&#39;</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;number:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    store.subscribe( () &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;number:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(&#123;type:Types.ADD,amount:1&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(&#123;type:Types.MINUS,amount:1&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;this.state.number&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleAddClick&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleMinusClick&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Counter&#x2F;&gt;,window.root);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>此时我们发现在redux和组件中都应用了action-types所以我们希望继续进行拆分,在store下创建action文件夹,用来生成action对象,我们管action文件中的方法称之为actionCreator</p>
</blockquote>
<ul>
<li><p>action文件夹中的counter,用来生成对应组件的action对象</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  add(amount)&#123;</span><br><span class="line">    return &#123;type:Types.ADD,amount&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minus(amount)&#123;</span><br><span class="line">    return &#123;type:Types.MINUS,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次更改组件代码</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class="line">import ReactDOM,&#123;render&#125; from &#39;react-dom&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line">import actions from &#39;.&#x2F;store&#x2F;actions&#x2F;counter&#39;</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;number:store.getState().number&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    store.subscribe( () &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;number:store.getState().number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleAddClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(actions.add(1));</span><br><span class="line">  &#125;;</span><br><span class="line">  handleMinusClick&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    store.dispatch(actions.minus(1));</span><br><span class="line">  &#125;;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;this.state.number&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleAddClick&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;this.handleMinusClick&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Counter&#x2F;&gt;,window.root);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>我们已经将redux的流程进行了详细的拆分,让我们来总结一下redux的流程吧：</p>
</blockquote>
<p><img src="http://son.fullstackjavascript.cn/redux.png"></p>
<h3 id="2-实现多个counter"><a href="#2-实现多个counter" class="headerlink" title="2.实现多个counter"></a>2.实现多个counter</h3><p>在redux中只能拥有一个store所以我们需要将多个状态进行合并,状态是通过reducer返回的，所以我们可以将多个reducer进行合并达到合并状态的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│  index.js</span><br><span class="line">│  redux.js</span><br><span class="line">│</span><br><span class="line">├─components</span><br><span class="line">│      counter1.js</span><br><span class="line">│      counter2.js</span><br><span class="line">│</span><br><span class="line">└─store</span><br><span class="line">    │  action-types.js</span><br><span class="line">    │  index.js</span><br><span class="line">    │</span><br><span class="line">    ├─actions</span><br><span class="line">    │      counter1.js</span><br><span class="line">    │      counter2.js</span><br><span class="line">    │</span><br><span class="line">    └─reducer</span><br><span class="line">            counter1.js</span><br><span class="line">            counter2.js</span><br><span class="line">            index.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们将counter1的逻辑进行拷贝，粘贴出counter2</p>
</blockquote>
<ul>
<li><p>action-types新增counter2处理的常量</p>
  <figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">export const ADD = &#x27;ADD&#x27;;</span><br><span class="line">export const MINUS = &#x27;MINUS&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ export const INCREMENT = &#x27;INCREMENT&#x27;;</span></span><br><span class="line"><span class="addition">+ export const DECREMENT = &#x27;DECREMENT&#x27;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对应的counter2中的action也进行更改</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  add(amount)&#123;</span><br><span class="line">    return &#123;type:Types.INCREMENT,amount&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  minus(amount)&#123;</span><br><span class="line">    return &#123;type:Types.DECREMENT,amount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样reducer中处理也是一样的</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as Types from &#39;..&#x2F;action-types&#39;</span><br><span class="line">export default function reducer(state&#x3D;&#123;number:0&#125;,action) &#123;</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case Types.INCREMENT:</span><br><span class="line">      return &#123;number:state.number + action.amount&#125;;</span><br><span class="line">    case Types.DECREMENT:</span><br><span class="line">      return &#123;number:state.number - action.amount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在问题出现了我们拥有了两个reducer,我们要将两个reducer进行合并,合并成一个新的reducer</p>
</blockquote>
</li>
<li><p>combineReducers</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import counter1 from &#39;.&#x2F;counter1&#39;;</span><br><span class="line">import counter2 from &#39;.&#x2F;counter2&#39;;</span><br><span class="line">let combineReducers &#x3D; (reducers) &#x3D;&gt; &#123;</span><br><span class="line">  return (state&#x3D;&#123;&#125;,action)&#x3D;&gt;&#123;</span><br><span class="line">    let obj &#x3D; &#123;&#125;;</span><br><span class="line">    for(let key in reducers)&#123;</span><br><span class="line">      obj[key] &#x3D; reducers[key](state[key],action); &#x2F;&#x2F;调用原有的reducer将返回的结果放到对象上</span><br><span class="line">    &#125;</span><br><span class="line">    return obj; &#x2F;&#x2F; 将合并后的对象进行返回即可 &#123;counter1:&#123;number:0&#125;,counter2:&#123;number:0&#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default combineReducers(&#123;</span><br><span class="line">  counter1,counter2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后组件中获取状态要增加合并时的命名空间来获取</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state &#x3D; &#123;number:store.getState().counter1.number&#125;</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    store.subscribe( () &#x3D;&gt; &#123;</span><br><span class="line">        this.setState(&#123;number:store.getState().counter1.number&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2代码简单解析</title>
    <url>/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/</url>
    <content><![CDATA[<h2 id="谈一下你对MVVM-原理的理解"><a href="#谈一下你对MVVM-原理的理解" class="headerlink" title="谈一下你对MVVM 原理的理解"></a>谈一下你对<code>MVVM </code>原理的理解</h2><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/MVVM.jpg" alt="MVVM" style="zoom: 50%;">

<ul>
<li>传统的<code>MVC</code>指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染</li>
<li><code>MVVM</code>:传统的前端会将数据手动渲染到页面上,<code>MVVM</code>模式不需要用户收到操作<code>dom</code>元素,将数据绑定到<code>viewModel</code>层上，会自动将数据渲染到页面中，视图变化会通知<code>viewModel层</code>更新数据。<code>ViewModel</code>就是我们<code>MVVM</code>模式中的桥梁.<a id="more"></a>
<h2 id="请说一下响应式数据的原理？"><a href="#请说一下响应式数据的原理？" class="headerlink" title="请说一下响应式数据的原理？"></a>请说一下响应式数据的原理？</h2></li>
</ul>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>核心点:<code>Object.defineProperty</code></li>
<li>默认<code>Vue</code>在初始化数据时，会给<code>data</code>中的属性使用<code>Object.defineProperty</code>重新定义所有属性,当页面取到对应属性时。会进行依赖收集（收集当前组件的watcher） 如果属性发生变化会通知相关依赖进行更新操作。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend() <span class="comment">// ** 收集依赖 ** /</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify() <span class="comment">/**通知相关依赖进行更新**/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Vue中是如何检测数组变化"><a href="#Vue中是如何检测数组变化" class="headerlink" title="Vue中是如何检测数组变化?"></a><code>Vue</code>中是如何检测数组变化?</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>使用函数劫持的方式，重写了数组的方法</li>
<li><code>Vue</code>将<code>data</code>中的数组，进行了原型链重写。指向了自己定义的数组原型方法，这样当调用数组<code>api</code>时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控。</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123; <span class="comment">// 重写原型方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method] <span class="comment">// 调用原数组的方法</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify() <span class="comment">// 当调用数组方法后，手动通知视图更新</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.observeArray(value) <span class="comment">// 进行深度监控</span></span><br></pre></td></tr></table></figure>

<h2 id="为何Vue采用异步渲染"><a href="#为何Vue采用异步渲染" class="headerlink" title="为何Vue采用异步渲染?"></a>为何<code>Vue</code>采用异步渲染?</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染.所以为了性能考虑。<code>Vue</code>会在本轮数据更新后，再去异步更新视图!</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E4%B8%BA%E4%BD%95%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="built_in">this</span>); <span class="comment">// 当数据发生变化时会将watcher放到一个队列中批量更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id <span class="comment">// 会对相同的watcher进行过滤</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue) <span class="comment">// 调用nextTick方法 批量的进行更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理?"></a><code>nextTick</code>实现原理?</h2><h3 id="理解-宏任务和微任务-异步方法"><a href="#理解-宏任务和微任务-异步方法" class="headerlink" title="理解:(宏任务和微任务) 异步方法"></a>理解:(<strong>宏任务</strong>和<strong>微任务</strong>) 异步方法</h3><p><code>nextTick</code>方法主要是使用了<strong>宏任务</strong>和<strong>微任务</strong>,定义了一个异步方法.多次调用<code>nextTick</code> 会将方法存入队列中，通过这个异步方法清空当前队列。 所以这个<code>nextTick</code>方法就是异步方法</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/nextTick%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc  <span class="comment">// 会定义一个异步方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;  <span class="comment">// promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; ( <span class="comment">// MutationObserver</span></span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> ) &#123; <span class="comment">// setImmediate</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;   <span class="comment">// setTimeout</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nextTick实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Vue中Computed的特点"><a href="#Vue中Computed的特点" class="headerlink" title="Vue中Computed的特点"></a><code>Vue</code>中<code>Computed</code>的特点</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>默认<code>computed</code>也是一个<code>watcher</code>是具备缓存的，只要当依赖的属性发生变化时才会更新视图</li>
</ul>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123; <span class="comment">// 如果依赖的值没发生变化,就不会重新求值</span></span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Watch中的deep-true-是如何实现的"><a href="#Watch中的deep-true-是如何实现的" class="headerlink" title="Watch中的deep:true 是如何实现的"></a><code>Watch</code>中的<code>deep:true</code> 是如何实现的</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><ul>
<li>当用户指定了<code>watch</code>中的deep属性为<code>true</code>时，如果当前监控的值是数组类型。会对对象中的每一项进行求值，此时会将当前<code>watcher</code>存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新</li>
</ul>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>) <span class="comment">// 先将当前依赖放到 Dep.target上</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123; <span class="comment">// 如果需要深度监控</span></span><br><span class="line">        traverse(value) <span class="comment">// 会对对象中的每一项取值,取值时会执行对应的get方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val: any, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Vue组件的生命周期"><a href="#Vue组件的生命周期" class="headerlink" title="Vue组件的生命周期"></a><code>Vue</code>组件的生命周期</h2><h3 id="理解-4"><a href="#理解-4" class="headerlink" title="理解"></a>理解</h3><h4 id="要掌握每个生命周期什么时候被调用"><a href="#要掌握每个生命周期什么时候被调用" class="headerlink" title="要掌握每个生命周期什么时候被调用"></a>要掌握每个生命周期什么时候被调用</h4><ul>
<li><code>beforeCreate</code> 在实例初始化之后，数据观测(data observer) 之前被调用。</li>
<li><code>created</code> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el</li>
<li><code>beforeMount</code> 在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li><code>mounted</code> el 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。</li>
<li><code>beforeUpdate</code> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li>
<li><code>updated</code> 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
<li><code>beforeDestroy</code> 实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li><code>destroyed</code> <code>Vue</code> 实例销毁后调用。调用后，<code>Vue</code> 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h4 id="要掌握每个生命周期内部可以做什么事"><a href="#要掌握每个生命周期内部可以做什么事" class="headerlink" title="要掌握每个生命周期内部可以做什么事"></a>要掌握每个生命周期内部可以做什么事</h4><ul>
<li><code>created</code> 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。</li>
<li><code>mounted</code> 实例已经挂载完成，可以进行一些DOM操作</li>
<li><code>beforeUpdate</code> 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li><code>updated</code> 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。</li>
<li><code>destroyed</code> 可以执行一些优化操作,清空定时器，解除绑定事件</li>
</ul>
<p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/lifecycle.png" alt="lifecycle"></p>
<h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p>
<h2 id="ajax请求放在哪个生命周期中"><a href="#ajax请求放在哪个生命周期中" class="headerlink" title="ajax请求放在哪个生命周期中"></a><code>ajax</code>请求放在哪个生命周期中</h2><h3 id="理解-5"><a href="#理解-5" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>在created的时候，视图中的<code>dom</code>并没有渲染出来，所以此时如果直接去操<code>dom</code>节点，无法找到相关的元素 </li>
<li>在mounted中，由于此时<code>dom</code>已经渲染出来了，所以可以直接操作<code>dom</code>节点 </li>
</ul>
<p>一般情况下都放到<code>mounted</code>中,保证逻辑的统一性,因为生命周期是同步执行的，<code>ajax</code>是异步执行的</p>
<blockquote>
<p>服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中</p>
</blockquote>
<h2 id="何时需要使用beforeDestroy"><a href="#何时需要使用beforeDestroy" class="headerlink" title="何时需要使用beforeDestroy"></a>何时需要使用<code>beforeDestroy</code></h2><h3 id="理解-6"><a href="#理解-6" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>可能在当前页面中使用了<code>$on</code>方法，那需要在组件销毁前解绑。</li>
<li>清除自己定义的定时器</li>
<li>解除事件的绑定 <code>scroll mousemove ....</code></li>
</ul>
<h2 id="Vue中模板编译原理"><a href="#Vue中模板编译原理" class="headerlink" title="Vue中模板编译原理"></a><code>Vue</code>中模板编译原理</h2><ul>
<li>将<code>template</code>转化成<code>render</code>函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options) <span class="comment">// 将模板转化成ast语法树</span></span><br><span class="line">  <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;           <span class="comment">// 优化树</span></span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)         <span class="comment">// 生成树</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>; </span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span>;</span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>); <span class="comment">// 标签开头的正则 捕获的内容是标签名</span></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;\\/<span class="subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>); <span class="comment">// 匹配标签结尾的  &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">const</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>; <span class="comment">// 匹配属性的</span></span><br><span class="line"><span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>; <span class="comment">// 匹配标签结束的  &gt;</span></span><br><span class="line"><span class="keyword">let</span> root;</span><br><span class="line"><span class="keyword">let</span> currentParent;</span><br><span class="line"><span class="keyword">let</span> stack = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createASTElement</span>(<span class="params">tagName,attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag:tagName,</span><br><span class="line">        type:<span class="number">1</span>,</span><br><span class="line">        children:[],</span><br><span class="line">        attrs,</span><br><span class="line">        parent:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">tagName,attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> element = createASTElement(tagName,attrs);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!root</span>)</span>&#123;</span><br><span class="line">        root = element;</span><br><span class="line">    &#125;</span><br><span class="line">    currentParent = element;</span><br><span class="line">    stack.push(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chars</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        type:<span class="number">3</span>,</span><br><span class="line">        text</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">tagName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = stack[stack.length-<span class="number">1</span>];</span><br><span class="line">    stack.length --; </span><br><span class="line">    currentParent = stack[stack.length-<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">currentParent</span>)</span>&#123;</span><br><span class="line">        element.parent = currentParent;</span><br><span class="line">        currentParent.children.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">textEnd == <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">startTagMatch</span>)</span>&#123;</span><br><span class="line">                start(startTagMatch.tagName,startTagMatch.attrs);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> endTagMatch = html.match(endTag);</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">endTagMatch</span>)</span>&#123;</span><br><span class="line">                advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">                end(endTagMatch[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> text;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">textEnd &gt;=<span class="number">0</span> </span>)</span>&#123;</span><br><span class="line">            text = html.substring(<span class="number">0</span>,textEnd)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">            advance(text.length);</span><br><span class="line">            chars(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">advance</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        html = html.substring(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> start = html.match(startTagOpen);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">start</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> match = &#123;</span><br><span class="line">                tagName:start[<span class="number">1</span>],</span><br><span class="line">                attrs:[]</span><br><span class="line">            &#125;</span><br><span class="line">            advance(start[<span class="number">0</span>].length);</span><br><span class="line">            <span class="keyword">let</span> attr,end</span><br><span class="line">            <span class="keyword">while</span>(!(end = html.match(startTagClose)) &amp;&amp; (attr=html.match(attribute)))&#123;</span><br><span class="line">                advance(attr[<span class="number">0</span>].length);</span><br><span class="line">                match.attrs.push(&#123;<span class="attr">name</span>:attr[<span class="number">1</span>],<span class="attr">value</span>:attr[<span class="number">3</span>]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">end</span>)</span>&#123;</span><br><span class="line">                advance(end[<span class="number">0</span>].length);</span><br><span class="line">                <span class="keyword">return</span> match</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成语法树</span></span><br><span class="line">parseHTML(<span class="string">`&lt;div id=&quot;container&quot;&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">node.type == <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generate(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(node.text)&#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genChildren</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> children = el.children;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">el.children</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;children.map(c=&gt;gen(c)).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>]`</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genProps</span>(<span class="params">attrs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length;i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> attr = attrs[i];</span><br><span class="line">        str+= <span class="string">`<span class="subst">$&#123;attr.name&#125;</span>:<span class="subst">$&#123;attr.value&#125;</span>,`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;attrs:&#123;<span class="subst">$&#123;str.slice(<span class="number">0</span>,-<span class="number">1</span>)&#125;</span>&#125;&#125;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> children = genChildren(el);</span><br><span class="line">    <span class="keyword">let</span> code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        el.attrs.length? <span class="string">`,<span class="subst">$&#123;genProps(el.attrs)&#125;</span>`</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        children? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据语法树生成新的代码</span></span><br><span class="line"><span class="keyword">let</span> code = generate(root);</span><br><span class="line"><span class="keyword">let</span> render = <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装成函数</span></span><br><span class="line"><span class="keyword">let</span> renderFn = <span class="keyword">new</span> <span class="built_in">Function</span>(render);</span><br><span class="line"><span class="built_in">console</span>.log(renderFn.toString());</span><br></pre></td></tr></table></figure>

<h2 id="Vue中v-if和v-show的区别"><a href="#Vue中v-if和v-show的区别" class="headerlink" title="Vue中v-if和v-show的区别"></a><code>Vue</code>中<code>v-if</code>和<code>v-show</code>的区别</h2><h3 id="理解-7"><a href="#理解-7" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li><code>v-if</code>如果条件不成立不会渲染当前指令所在节点的<code>dom</code>元素</li>
<li><code>v-show</code>只是切换当前<code>dom</code>的显示或者隐藏</li>
</ul>
<h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-if=&quot;true&quot;&gt;&lt;span v-for=&quot;i in 3&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return (true) ? _c(&#x27;div&#x27;, _l((3), function (i) &#123;</span></span><br><span class="line"><span class="comment">        return _c(&#x27;span&#x27;, [_v(&quot;hello&quot;)])</span></span><br><span class="line"><span class="comment">    &#125;), 0) : _e()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-show=&quot;true&quot;&gt;&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        directives: [&#123;</span></span><br><span class="line"><span class="comment">            name: &quot;show&quot;,</span></span><br><span class="line"><span class="comment">            rawName: &quot;v-show&quot;,</span></span><br><span class="line"><span class="comment">            value: (true),</span></span><br><span class="line"><span class="comment">            expression: &quot;true&quot;</span></span><br><span class="line"><span class="comment">        &#125;]</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v-show 操作的是样式  定义在platforms/web/runtime/directives/show.js</span></span><br><span class="line">bind (el: any, &#123; value &#125;: VNodeDirective, <span class="attr">vnode</span>: VNodeWithData) &#123;</span><br><span class="line">    vnode = locateNode(vnode)</span><br><span class="line">    <span class="keyword">const</span> transition = vnode.data &amp;&amp; vnode.data.transition</span><br><span class="line">    <span class="keyword">const</span> originalDisplay = el.__vOriginalDisplay =</span><br><span class="line">      el.style.display === <span class="string">&#x27;none&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : el.style.display</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; transition) &#123;</span><br><span class="line">      vnode.data.show = <span class="literal">true</span></span><br><span class="line">      enter(vnode, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        el.style.display = originalDisplay</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.style.display = value ? originalDisplay : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="为什么V-for和v-if不能连用"><a href="#为什么V-for和v-if不能连用" class="headerlink" title="为什么V-for和v-if不能连用"></a>为什么<code>V-for</code>和<code>v-if</code>不能连用</h2><h3 id="理解-8"><a href="#理解-8" class="headerlink" title="理解:"></a>理解:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = VueTemplateCompiler.compile(<span class="string">`&lt;div v-if=&quot;false&quot; v-for=&quot;i in 3&quot;&gt;hello&lt;/div&gt;`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _l((3), function (i) &#123;</span></span><br><span class="line"><span class="comment">        return (false) ? _c(&#x27;div&#x27;, [_v(&quot;hello&quot;)]) : _e()</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(r1.render);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-for</code>会比<code>v-if</code>的优先级高一些,如果连用的话会把<code>v-if</code>给每个元素都添加一下,会造成性能问题</li>
</ul>
<h2 id="用vnode来描述一个DOM结构"><a href="#用vnode来描述一个DOM结构" class="headerlink" title="用vnode来描述一个DOM结构"></a>用<code>vnode</code>来描述一个<code>DOM</code>结构</h2><ul>
<li>虚拟节点就是用一个对象来描述真实的<code>dom</code>元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$createElement</span>(<span class="params">tag,data,...children</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = data.key;</span><br><span class="line">    <span class="keyword">delete</span> data.key;</span><br><span class="line">    children = children.map(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> child === <span class="string">&#x27;object&#x27;</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> child</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vnode(<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> vnode(tag,props,key,children);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span>(<span class="params">tag,data,key,children,text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag, <span class="comment">// 表示的是当前的标签名</span></span><br><span class="line">        data, <span class="comment">// 表示的是当前标签上的属性</span></span><br><span class="line">        key, <span class="comment">// 唯一表示用户可能传递</span></span><br><span class="line">        children,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="diff算法的时间复杂度"><a href="#diff算法的时间复杂度" class="headerlink" title="diff算法的时间复杂度"></a><code>diff</code>算法的时间复杂度</h2><p> 两个树的完全的<code>diff</code>算法是一个时间复杂度为 <code>O(n3) </code>,<code>Vue</code>进行了优化·<em>O(n3)</em> <em>复杂度</em>的问题转换成 O(n) <em>复杂度</em>的问题(只比较同级不考虑跨级问题)  在前端当中， 你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比。 </p>
<h2 id="简述Vue中diff算法原理"><a href="#简述Vue中diff算法原理" class="headerlink" title="简述Vue中diff算法原理"></a>简述<code>Vue</code>中<code>diff</code>算法原理</h2><h3 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h3><ul>
<li>先同级比较，在比较子节点</li>
<li>先判断一方有儿子一方没儿子的情况 </li>
<li>比较都有儿子的情况</li>
<li>递归比较子节点</li>
</ul>
<p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/vue-diff.jpg"></p>
<h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理:"></a>原理:</h3><blockquote>
<p><code>core/vdom/patch.js</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oldCh = oldVnode.children <span class="comment">// 老的儿子 </span></span><br><span class="line"><span class="keyword">const</span> ch = vnode.children  <span class="comment">// 新的儿子</span></span><br><span class="line"><span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// 比较孩子</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123; <span class="comment">// 新的儿子有 老的没有</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123; <span class="comment">// 如果老的有新的没有 就删除</span></span><br><span class="line">        removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;  <span class="comment">// 老的有文本 新的没文本</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 将老的清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123; <span class="comment">// 文本不相同替换</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="v-for中为什么要用key-图解"><a href="#v-for中为什么要用key-图解" class="headerlink" title="v-for中为什么要用key (图解)"></a><code>v-for</code>中为什么要用<code>key</code> (图解)</h2><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/diff-key.jpg"></p>
<h2 id="描述组件渲染和更新过程"><a href="#描述组件渲染和更新过程" class="headerlink" title="描述组件渲染和更新过程"></a>描述组件渲染和更新过程</h2><h3 id="理解：-2"><a href="#理解：-2" class="headerlink" title="理解："></a>理解：</h3><ul>
<li>渲染组件时，会通过<code>Vue.extend</code>方法构建子组件的构造函数，并进行实例化。最终手动调用<code>$mount()</code>进行挂载。更新组件时会进行<code>patchVnode</code>流程.核心就是diff算法</li>
</ul>
<p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="组件中的-data为什么是一个函数"><a href="#组件中的-data为什么是一个函数" class="headerlink" title="组件中的 data为什么是一个函数?"></a>组件中的 <code>data</code>为什么是一个函数?</h2><h3 id="理解：-3"><a href="#理解：-3" class="headerlink" title="理解："></a>理解：</h3><p>同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果<code>data</code>是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过<code>data</code>函数返回一个对象作为组件的状态。</p>
<h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理:"></a>原理:</h3><blockquote>
<p><code>core/global-api/extend.js line:33</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 	 <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">        options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">strats.data = <span class="function"><span class="keyword">function</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123; <span class="comment">// 合并是会判断子类的data必须是一个函数</span></span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">&#x27;The &quot;data&quot; option should be a function &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;that returns a per-instance value in component &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;definitions.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个组件被使用多次，用的都是同一个构造函数。为了保证组件的不同的实例data不冲突，要求data必须是一个函数，这样组件间不会相互影响</li>
</ul>
<h2 id="Vue中事件绑定的原理"><a href="#Vue中事件绑定的原理" class="headerlink" title="Vue中事件绑定的原理"></a><code>Vue</code>中事件绑定的原理</h2><h3 id="理解-9"><a href="#理解-9" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>原生<code>dom</code>事件的绑定,采用的是<code>addEventListener</code>实现</li>
<li>组件绑定事件采用的是<code>$on</code>方法</li>
</ul>
<h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理:"></a>原理:</h3><ul>
<li>事件的编译：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = compiler.compile(<span class="string">&#x27;&lt;div @click=&quot;fn()&quot;&gt;&lt;/div&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = compiler.compile(<span class="string">&#x27;&lt;my-component @click.native=&quot;fn&quot; @click=&quot;fn1&quot;&gt;&lt;/my-component&gt;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r1); <span class="comment">// &#123;on:&#123;click&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r2); <span class="comment">// &#123;nativeOnOn:&#123;click&#125;,on:&#123;click&#125;&#125;  </span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E4%BA%8B%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p>
<h4 id="原生dom的绑定"><a href="#原生dom的绑定" class="headerlink" title="原生dom的绑定"></a>原生<code>dom</code>的绑定</h4><ul>
<li><code>Vue</code>在创建真是<code>dom</code>时会调用<code>createElm</code>,默认会调用<code>invokeCreateHooks</code></li>
<li>会遍历当前平台下相对的属性处理代码,其中就有<code>updateDOMListeners</code>方法,内部会传入<code>add</code>方法</li>
</ul>
<p>yuan</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMListeners</span> (<span class="params">oldVnode: VNodeWithData, vnode: VNodeWithData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> on = vnode.data.on || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> oldOn = oldVnode.data.on || &#123;&#125;</span><br><span class="line">  target = vnode.elm</span><br><span class="line">  normalizeEvents(on)</span><br><span class="line">  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context)</span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  capture: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  passive: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  target.addEventListener( <span class="comment">// 给当前的dom添加事件</span></span><br><span class="line">    name,</span><br><span class="line">    handler,</span><br><span class="line">    supportsPassive</span><br><span class="line">      ? &#123; capture, passive &#125;</span><br><span class="line">      : capture</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <code>vue</code>中绑定事件是直接绑定给真实<code>dom</code>元素的</p>
</blockquote>
<ul>
<li>组件中绑定事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateComponentListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldListeners: ?<span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  target = vm</span><br><span class="line">  updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, createOnceHandler, vm)</span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">  target.$on(event, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>组件绑定事件是通过<code>vue</code>中自定义的<code>$on</code>方法来实现的</p>
</blockquote>
<h2 id="v-model中的实现原理及如何自定义v-model"><a href="#v-model中的实现原理及如何自定义v-model" class="headerlink" title="v-model中的实现原理及如何自定义v-model"></a><code>v-model</code>中的实现原理及如何自定义<code>v-model</code></h2><h3 id="理解-10"><a href="#理解-10" class="headerlink" title="理解:"></a>理解:</h3><p>组件的<code>v-model</code>是<code>value+input方法</code>的语法糖</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">:value</span>=<span class="string">&quot;&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;check&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以自己重新定义<code>v-model</code>的含义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;el-checkbox&#x27;</span>,&#123;</span><br><span class="line">    template:<span class="string">`&lt;input type=&quot;checkbox&quot; :checked=&quot;check&quot; @change=&quot;$emit(&#x27;change&#x27;,$event.target.checked)&quot;&gt;`</span>,</span><br><span class="line">    model:&#123;</span><br><span class="line">        prop:<span class="string">&#x27;check&#x27;</span>, <span class="comment">// 更改默认的value的名字</span></span><br><span class="line">        event:<span class="string">&#x27;change&#x27;</span> <span class="comment">// 更改默认的方法名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        check: <span class="built_in">Boolean</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="原理-11"><a href="#原理-11" class="headerlink" title="原理:"></a>原理:</h3><ul>
<li>会将组件的<code>v-model</code>默认转化成value+input</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ele = VueTemplateCompiler.compile(<span class="string">&#x27;&lt;el-checkbox v-model=&quot;check&quot;&gt;&lt;/el-checkbox&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// with(this) &#123;</span></span><br><span class="line"><span class="comment">//     return _c(&#x27;el-checkbox&#x27;, &#123;</span></span><br><span class="line"><span class="comment">//         model: &#123;</span></span><br><span class="line"><span class="comment">//             value: (check),</span></span><br><span class="line"><span class="comment">//             callback: function ($$v) &#123;</span></span><br><span class="line"><span class="comment">//                 check = $$v</span></span><br><span class="line"><span class="comment">//             &#125;,</span></span><br><span class="line"><span class="comment">//             expression: &quot;check&quot;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>core/vdom/create-component.js  line:155</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformModel</span> (<span class="params">options, data: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prop = (options.model &amp;&amp; options.model.prop) || <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> event = (options.model &amp;&amp; options.model.event) || <span class="string">&#x27;input&#x27;</span></span><br><span class="line">  ;(data.attrs || (data.attrs = &#123;&#125;))[prop] = data.model.value</span><br><span class="line">  <span class="keyword">const</span> on = data.on || (data.on = &#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> existing = on[event]</span><br><span class="line">  <span class="keyword">const</span> callback = data.model.callback</span><br><span class="line">  <span class="keyword">if</span> (isDef(existing)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">Array</span>.isArray(existing)</span><br><span class="line">        ? existing.indexOf(callback) === -<span class="number">1</span></span><br><span class="line">        : existing !== callback</span><br><span class="line">    ) &#123;</span><br><span class="line">      on[event] = [callback].concat(existing)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    on[event] = callback</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原生的 <code>v-model</code>，会根据标签的不同生成不同的事件和属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ele = VueTemplateCompiler.compile(<span class="string">&#x27;&lt;input v-model=&quot;value&quot;/&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;input&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        directives: [&#123;</span></span><br><span class="line"><span class="comment">            name: &quot;model&quot;,</span></span><br><span class="line"><span class="comment">            rawName: &quot;v-model&quot;,</span></span><br><span class="line"><span class="comment">            value: (value),</span></span><br><span class="line"><span class="comment">            expression: &quot;value&quot;</span></span><br><span class="line"><span class="comment">        &#125;],</span></span><br><span class="line"><span class="comment">        domProps: &#123;</span></span><br><span class="line"><span class="comment">            &quot;value&quot;: (value)</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        on: &#123;</span></span><br><span class="line"><span class="comment">            &quot;input&quot;: function ($event) &#123;</span></span><br><span class="line"><span class="comment">                if ($event.target.composing) return;</span></span><br><span class="line"><span class="comment">                value = $event.target.value</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译时：不同的标签解析出的内容不一样 <code>platforms/web/compiler/directives/model.js</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">    genComponentModel(el, value, modifiers)</span><br><span class="line">    <span class="comment">// component v-model doesn&#x27;t need extra runtime</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">    genSelect(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> &amp;&amp; type === <span class="string">&#x27;checkbox&#x27;</span>) &#123;</span><br><span class="line">    genCheckboxModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> &amp;&amp; type === <span class="string">&#x27;radio&#x27;</span>) &#123;</span><br><span class="line">    genRadioModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;input&#x27;</span> || tag === <span class="string">&#x27;textarea&#x27;</span>) &#123;</span><br><span class="line">    genDefaultModel(el, value, modifiers)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!config.isReservedTag(tag)) &#123;</span><br><span class="line">    genComponentModel(el, value, modifiers)</span><br><span class="line">    <span class="comment">// component v-model doesn&#x27;t need extra runtime</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时：会对元素处理一些关于输入法的问题 <code>platforms/web/runtime/directives/model.js</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inserted (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.tag === <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// #6903</span></span><br><span class="line">      <span class="keyword">if</span> (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) &#123;</span><br><span class="line">        mergeVNodeHook(vnode, <span class="string">&#x27;postpatch&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          directive.componentUpdated(el, binding, vnode)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setSelected(el, binding, vnode.context)</span><br><span class="line">      &#125;</span><br><span class="line">      el._vOptions = [].map.call(el.options, getValue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vnode.tag === <span class="string">&#x27;textarea&#x27;</span> || isTextInputType(el.type)) &#123;</span><br><span class="line">      el._vModifiers = binding.modifiers</span><br><span class="line">      <span class="keyword">if</span> (!binding.modifiers.lazy) &#123;</span><br><span class="line">        el.addEventListener(<span class="string">&#x27;compositionstart&#x27;</span>, onCompositionStart)</span><br><span class="line">        el.addEventListener(<span class="string">&#x27;compositionend&#x27;</span>, onCompositionEnd)</span><br><span class="line">        <span class="comment">// Safari &lt; 10.2 &amp; UIWebView doesn&#x27;t fire compositionend when</span></span><br><span class="line">        <span class="comment">// switching focus before confirming composition choice</span></span><br><span class="line">        <span class="comment">// this also fixes the issue where some browsers e.g. iOS Chrome</span></span><br><span class="line">        <span class="comment">// fires &quot;change&quot; instead of &quot;input&quot; on autocomplete.</span></span><br><span class="line">        el.addEventListener(<span class="string">&#x27;change&#x27;</span>, onCompositionEnd)</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (isIE9) &#123;</span><br><span class="line">          el.vmodel = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue中v-html会导致哪些问题"><a href="#Vue中v-html会导致哪些问题" class="headerlink" title="Vue中v-html会导致哪些问题?"></a><code>Vue</code>中<code>v-html</code>会导致哪些问题?</h2><h3 id="理解-11"><a href="#理解-11" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li>可能会导致<code>xss</code>攻击</li>
<li><code>v-html</code>会替换掉标签内部的子元素</li>
</ul>
<h3 id="原理-12"><a href="#原理-12" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> r = template.compile(<span class="string">`&lt;div v-html=&quot;&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;&quot;&gt;&lt;/div&gt;`</span>)</span><br><span class="line"><span class="comment">// with(this)&#123;return _c(&#x27;div&#x27;,&#123;domProps:&#123;&quot;innerHTML&quot;:_s(&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;)&#125;&#125;)&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r.render);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _c 定义在core/instance/render.js</span></span><br><span class="line"><span class="comment">// _s 定义在core/instance/render-helpers/index,js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key === <span class="string">&#x27;textContent&#x27;</span> || key === <span class="string">&#x27;innerHTML&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vnode.children) vnode.children.length = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (cur === oldProps[key]) <span class="keyword">continue</span></span><br><span class="line">      <span class="comment">// #6601 work around Chrome version &lt;= 55 bug where single textNode</span></span><br><span class="line">      <span class="comment">// replaced by innerHTML/textContent retains its parentNode property</span></span><br><span class="line">      <span class="keyword">if</span> (elm.childNodes.length === <span class="number">1</span>) &#123;</span><br><span class="line">        elm.removeChild(elm.childNodes[<span class="number">0</span>])</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue父子组件生命周期调用顺序"><a href="#Vue父子组件生命周期调用顺序" class="headerlink" title="Vue父子组件生命周期调用顺序"></a><code>Vue</code>父子组件生命周期调用顺序</h2><h3 id="理解-12"><a href="#理解-12" class="headerlink" title="理解:"></a>理解:</h3><p>组件的调用顺序都是先父后子,渲染完成的顺序肯定是先子后父</p>
<p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父</p>
<h3 id="原理-13"><a href="#原理-13" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1582263422513.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = [] <span class="comment">// 定义收集所有组件的insert hook方法的数组</span></span><br><span class="line">    <span class="comment">// somthing ...</span></span><br><span class="line">    createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">    )</span><br><span class="line">  <span class="comment">// somthing...</span></span><br><span class="line">    <span class="comment">// 最终会依次调用收集的insert hook</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">    insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    nested,</span></span></span><br><span class="line"><span class="function"><span class="params">    ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">    index</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// createChildren会递归创建儿子组件</span></span><br><span class="line">        createChildren(vnode, children, insertedVnodeQueue) </span><br><span class="line">        <span class="comment">// something...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将组件的vnode插入到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">      cbs.create[i](emptyNode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    i = vnode.data.hook <span class="comment">// Reuse variable</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i.create)) i.create(emptyNode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (isDef(i.insert)) insertedVnodeQueue.push(vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// insert方法中会依次调用mounted方法</span></span><br><span class="line">insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// delay insert hooks for component root nodes, invoke them after the</span></span><br><span class="line">     <span class="comment">// element is really inserted</span></span><br><span class="line">     <span class="keyword">if</span> (isTrue(initial) &amp;&amp; isDef(vnode.parent)) &#123;</span><br><span class="line">         vnode.parent.data.pendingInsert = queue</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">             queue[i].data.hook.insert(queue[i]); <span class="comment">// 调用insert方法</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>) <span class="comment">// </span></span><br><span class="line">    <span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line">    vm.__patch__(vm._vnode, <span class="literal">null</span>) <span class="comment">// 先销毁儿子 </span></span><br><span class="line">    <span class="comment">// fire destroyed hook</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue组件如何通信"><a href="#Vue组件如何通信" class="headerlink" title="Vue组件如何通信?"></a><code>Vue</code>组件如何通信?</h2><ul>
<li>父子间通信  父-&gt;子通过<code>props</code>、子-&gt; 父<code>$on、$emit</code></li>
<li>获取父子组件实例的方式<code>$parent、$children</code></li>
<li>在父组件中提供数据子组件进行消费 <code>Provide、inject</code></li>
<li><code>Ref</code>获取实例的方式调用组件的属性或者方法</li>
<li><code>Event Bus</code> 实现跨组件通信</li>
<li><code>Vuex </code>状态管理实现通信</li>
</ul>
<h2 id="Vue中相同逻辑如何抽离？"><a href="#Vue中相同逻辑如何抽离？" class="headerlink" title="Vue中相同逻辑如何抽离？"></a><code>Vue</code>中相同逻辑如何抽离？</h2><ul>
<li><code>Vue.mixin</code>用法 给组件每个生命周期，函数等都混入一些公共逻辑</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.options = mergeOptions(<span class="built_in">this</span>.options, mixin); <span class="comment">// 将当前定义的属性合并到每个组件中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parent: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  child: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.extends) &#123; <span class="comment">// 递归合并extends</span></span><br><span class="line">      parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.mixins) &#123; <span class="comment">// 递归合并mixin</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125; <span class="comment">// 属性及生命周期的合并</span></span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">      mergeField(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    <span class="comment">// 调用不同属性合并策略进行合并</span></span><br><span class="line">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><h3 id="理解-13"><a href="#理解-13" class="headerlink" title="理解:"></a>理解:</h3><ul>
<li><p>如果组件功能多打包出的结果会变大，我可以采用异步的方式来加载组件。主要依赖<code>import()</code>这个语法，可以实现文件的分割加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">  <span class="function"><span class="title">AddCustomerSchedule</span>(<span class="params">resolve</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>([<span class="string">&quot;../components/AddCustomer&quot;</span>], resolve);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="原理-14"><a href="#原理-14" class="headerlink" title="原理:"></a>原理:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resolveAsyncComponent(asyncFactory, baseCtor) <span class="comment">// 默认调用此函数时返回undefiend</span></span><br><span class="line">    <span class="comment">// 第二次渲染时Ctor不为undefined</span></span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder( <span class="comment">// 渲染占位符 空虚拟节点</span></span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  factory: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.resolved)) &#123; <span class="comment">// 在次渲染时可以拿到获取的最新组件</span></span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">      <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        forceRender(<span class="literal">true</span>) <span class="comment">// 强制更新视图重新渲染</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">          factory.error = <span class="literal">true</span></span><br><span class="line">          forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> res = factory(resolve, reject)<span class="comment">// 将resolve方法和reject方法传入，用户调用resolve方法后</span></span><br><span class="line">  sync = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> factory.resolved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是作用域插槽"><a href="#什么是作用域插槽" class="headerlink" title="什么是作用域插槽?"></a>什么是作用域插槽?</h2><h3 id="理解-14"><a href="#理解-14" class="headerlink" title="理解:"></a>理解:</h3><h4 id="插槽："><a href="#插槽：" class="headerlink" title="插槽："></a>插槽：</h4><ul>
<li>创建组件虚拟节点时，会将组件的儿子的虚拟节点保存起来。当初始化组件时,通过插槽属性将儿子进行分类 <code>&#123;a:[vnode],b[vnode]&#125;</code></li>
<li>渲染组件时会拿对应的slot属性的节点进行替换操作。（插槽的作用域为父组件）</li>
</ul>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽:"></a>作用域插槽:</h4><ul>
<li>作用域插槽在解析的时候，不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。（插槽的作用域为子组件）</li>
</ul>
<h3 id="原理-15"><a href="#原理-15" class="headerlink" title="原理:"></a>原理:</h3><p><img src="/2020/10/21/vue%E7%AC%94%E8%AE%B0/vue-souce/%E6%8F%92%E6%A7%BD.png"></p>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽:"></a>插槽:</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;my-component&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot=&quot;header&quot;&gt;node&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;react&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot=&quot;footer&quot;&gt;vue&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/my-component&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;my-component&#x27;, [_c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        attrs: &#123;</span></span><br><span class="line"><span class="comment">            &quot;slot&quot;: &quot;header&quot;</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        slot: &quot;header&quot;</span></span><br><span class="line"><span class="comment">    &#125;, [_v(&quot;node&quot;)]), _v(&quot; &quot;), _c(&#x27;div&#x27;, [_v(&quot;react&quot;)]), _v(&quot; &quot;), _c(&#x27;div&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        attrs: &#123;</span></span><br><span class="line"><span class="comment">            &quot;slot&quot;: &quot;footer&quot;</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        slot: &quot;footer&quot;</span></span><br><span class="line"><span class="comment">    &#125;, [_v(&quot;vue&quot;)])])</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, [_t(&quot;header&quot;), _v(&quot; &quot;), _t(&quot;footer&quot;), _v(&quot; &quot;), _t(&quot;default&quot;)], 2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// _t定义在 core/instance/render-helpers/index.js</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽-1"><a href="#作用域插槽-1" class="headerlink" title="作用域插槽:"></a>作用域插槽:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ele = VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;app&gt;</span></span><br><span class="line"><span class="string">        &lt;div slot-scope=&quot;msg&quot; slot=&quot;footer&quot;&gt;&#123;&#123;msg.a&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/app&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;app&#x27;, &#123;</span></span><br><span class="line"><span class="comment">        scopedSlots: _u([&#123; // 作用域插槽的内容会被渲染成一个函数</span></span><br><span class="line"><span class="comment">            key: &quot;footer&quot;,</span></span><br><span class="line"><span class="comment">            fn: function (msg) &#123;</span></span><br><span class="line"><span class="comment">                return _c(&#x27;div&#x27;, &#123;&#125;, [_v(_s(msg.a))])</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;])</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> VueTemplateCompiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>);</span><br><span class="line"></span><br><span class="line">VueTemplateCompiler.compile(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;slot name=&quot;footer&quot; a=&quot;1&quot; b=&quot;2&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">with(this) &#123;</span></span><br><span class="line"><span class="comment">    return _c(&#x27;div&#x27;, [_t(&quot;footer&quot;, null, &#123;</span></span><br><span class="line"><span class="comment">        &quot;a&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="comment">        &quot;b&quot;: &quot;2&quot;</span></span><br><span class="line"><span class="comment">    &#125;)], 2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h2 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h2><h3 id="理解-15"><a href="#理解-15" class="headerlink" title="理解:"></a>理解:</h3><p><code>keep-alive</code>可以实现组件的缓存，当组件切换时不会对当前组件进行卸载,常用的2个属性<code>include</code>/<code>exclude</code>,2个生命周期<code>activated</code>,<code>deactivated</code></p>
<h3 id="原理-16"><a href="#原理-16" class="headerlink" title="原理:"></a>原理:</h3><blockquote>
<p><code>core/components/keep-alive.js</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>, <span class="comment">// 抽象组件</span></span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 创建缓存列表</span></span><br><span class="line">    <span class="built_in">this</span>.keys = [] <span class="comment">// 创建缓存组件的key列表</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123; <span class="comment">// keep-alive销毁时 会清空所有的缓存和key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.cache) &#123; <span class="comment">// 循环销毁</span></span><br><span class="line">      pruneCacheEntry(<span class="built_in">this</span>.cache, key, <span class="built_in">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted () &#123; <span class="comment">// 会监控include 和 include属性 进行组件的缓存处理</span></span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      pruneCache(<span class="built_in">this</span>, <span class="function"><span class="params">name</span> =&gt;</span> !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default <span class="comment">// 会默认拿插槽</span></span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot) <span class="comment">// 只缓存第一个组件</span></span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="comment">// 取出组件的名字</span></span><br><span class="line">      <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="comment">// 判断是否缓存</span></span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        : vnode.key <span class="comment">// 如果组件没key 就自己通过 组件的标签和key和cid 拼接一个key</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance <span class="comment">//  直接拿到组件实例</span></span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key) <span class="comment">// 删除当前的  [b,c,d,e,a]   // LRU 最近最久未使用法</span></span><br><span class="line">        keys.push(key) <span class="comment">// 并将key放到后面[b,a]</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[key] = vnode <span class="comment">// 缓存vnode</span></span><br><span class="line">        keys.push(key) <span class="comment">// 将key 存入</span></span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123; <span class="comment">// 缓存的太多超过了max 就需要删除掉</span></span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode) <span class="comment">// 要删除第0个 但是现在渲染的就是第0个</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span> <span class="comment">// 并且标准keep-alive下的组件是一个缓存组件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>]) <span class="comment">// 返回当前的虚拟节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue中常见性能优化"><a href="#Vue中常见性能优化" class="headerlink" title="Vue中常见性能优化"></a><code>Vue</code>中常见性能优化</h2><h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化:"></a>编码优化:</h3><ul>
<li><p>不要将所有的数据都放在data中，data中的数据都会增加getter和setter，会收集对应的watcher </p>
</li>
<li><p><code>vue</code> 在 v-for 时给每项元素绑定事件需要用事件代理</p>
</li>
<li><p><code>SPA</code>页面采用keep-alive缓存组件</p>
</li>
<li><p>拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染  )</p>
</li>
<li><p><code>v-if</code> 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show </p>
</li>
<li><p><code>key</code>保证唯一性 ( 默认<code>vue</code>会采用就地复用策略 )</p>
</li>
<li><p><code>Object.freeze</code> 冻结数据 </p>
</li>
<li><p>合理使用路由懒加载、异步组件</p>
</li>
<li><p>尽量采用runtime运行时版本</p>
</li>
<li><p>数据持久化的问题 （防抖、节流）</p>
</li>
</ul>
<h3 id="Vue加载性能优化"><a href="#Vue加载性能优化" class="headerlink" title="Vue加载性能优化:"></a><code>Vue</code>加载性能优化:</h3><ul>
<li><p>第三方模块按需导入 (<code>babel-plugin-component</code>) </p>
</li>
<li><p>滚动到可视区域动态加载  ( <a href="https://tangbc.github.io/vue-virtual-scroll-list">https://tangbc.github.io/vue-virtual-scroll-list</a> )</p>
</li>
<li><p>图片懒加载  (<a href="https://github.com/hilongjw/vue-lazyload.git">https://github.com/hilongjw/vue-lazyload.git</a>)</p>
</li>
</ul>
<h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验:"></a>用户体验:</h3><ul>
<li><code>app-skeleton</code>骨架屏</li>
<li><code>app-shell</code>app壳</li>
<li><code>pwa</code></li>
</ul>
<h3 id="SEO优化："><a href="#SEO优化：" class="headerlink" title="SEO优化："></a><code>SEO</code>优化：</h3><ul>
<li>预渲染插件 <code>prerender-spa-plugin</code></li>
<li>服务端渲染<code>ssr</code></li>
</ul>
<h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化:"></a>打包优化:</h3><ul>
<li>使用<code>cdn</code>的方式加载第三方模块 </li>
<li>多线程打包 <code>happypack </code></li>
<li><code>splitChunks</code> 抽离公共文件 </li>
<li><code>sourceMap</code>生成 </li>
</ul>
<h3 id="缓存，压缩"><a href="#缓存，压缩" class="headerlink" title="缓存，压缩"></a>缓存，压缩</h3><ul>
<li>客户端缓存、服务端缓存</li>
<li>服务端<code>gzip</code>压缩</li>
</ul>
<h2 id="Vue3-0你知道有哪些改进"><a href="#Vue3-0你知道有哪些改进" class="headerlink" title="Vue3.0你知道有哪些改进?"></a><code>Vue3.0</code>你知道有哪些改进?</h2><ul>
<li><p><code>Vue3</code>采用了TS来编写</p>
</li>
<li><p>支持 <code>Composition API </code></p>
</li>
<li><p><code>Vue3</code>中响应式数据原理改成<code>proxy</code></p>
</li>
<li><p><code> vdom</code>的对比算法更新，只更新<code>vdom</code>的绑定了动态数据的部分</p>
</li>
</ul>
<h2 id="实现hash路由和history路由"><a href="#实现hash路由和history路由" class="headerlink" title="实现hash路由和history路由"></a>实现<code>hash</code>路由和<code>history</code>路由</h2><ul>
<li><code>onhashchange</code></li>
<li><code>history.pushState</code></li>
</ul>
<h2 id="Vue-Router中导航守卫有哪些？"><a href="#Vue-Router中导航守卫有哪些？" class="headerlink" title="Vue-Router中导航守卫有哪些？"></a><code>Vue-Router</code>中导航守卫有哪些？</h2><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ul>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫 <code>beforeRouteLeave</code>。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>
</ul>
<h2 id="action-和-mutation区别"><a href="#action-和-mutation区别" class="headerlink" title="action 和 mutation区别"></a><code>action</code> 和 <code>mutation</code>区别</h2><ul>
<li><code>mutation</code>是同步更新数据(内部会进行是否为异步方式更新数据的检测)</li>
<li><code>action</code> 异步操作，可以获取数据后调佣<code>mutation</code>提交最终数据</li>
</ul>
<h2 id="简述Vuex工作原理"><a href="#简述Vuex工作原理" class="headerlink" title="简述Vuex工作原理"></a>简述<code>Vuex</code>工作原理</h2><p><img src="https://vuex.vuejs.org/vuex.png"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>vue代码解析</category>
      </categories>
      <tags>
        <tag>vue代码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Encoding</title>
    <url>/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Encoding/</url>
    <content><![CDATA[<h2 id="字符发展历史"><a href="#字符发展历史" class="headerlink" title="字符发展历史 #"></a>字符发展历史 <a href="#t01-%E5%AD%97%E7%AC%A6%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">#</a></h2><h3 id="字节"><a href="#字节" class="headerlink" title="字节 #"></a>字节 <a href="#t111-%E5%AD%97%E8%8A%82">#</a></h3><ul>
<li>计算机内部，所有信息最终都是一个二进制值</li>
<li>每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)<br><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Encoding/bits.jpg"></li>
</ul>
<h3 id="单位"><a href="#单位" class="headerlink" title="单位 #"></a>单位 <a href="#t212-%E5%8D%95%E4%BD%8D">#</a></h3><ul>
<li>8位 = 1字节</li>
<li>1024字节 = 1K</li>
<li>1024K = 1M</li>
<li>1024M = 1G</li>
<li>1024G = 1T</li>
</ul>
<h3 id="JavaScript中的进制"><a href="#JavaScript中的进制" class="headerlink" title="JavaScript中的进制 #"></a>JavaScript中的进制 <a href="#t313-javascript%E4%B8%AD%E7%9A%84%E8%BF%9B%E5%88%B6">#</a></h3><h4 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示 #"></a>进制表示 <a href="#t4131-%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA">#</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0b10100</span>;<span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0o24</span>;<span class="comment">//八进制</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">20</span>;<span class="comment">//十进制</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">0x14</span>;<span class="comment">//十六进制</span></span><br><span class="line"><span class="built_in">console</span>.log(a == b);</span><br><span class="line"><span class="built_in">console</span>.log(b == c);</span><br><span class="line"><span class="built_in">console</span>.log(c == d);</span><br></pre></td></tr></table></figure>

<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换 #"></a>进制转换 <a href="#t5132-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">#</a></h4><ul>
<li>10进制转任意进制 10进制数.toString(目标进制)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(c.toString(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>任意进制转十进制 parseInt(‘任意进制字符串’, 原始进制);</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;10100&#x27;</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII #"></a>ASCII <a href="#t614-ascii">#</a></h3><p>最开始计算机只在美国用，八位的字节可以组合出256种不同状态。0-32种状态规定了特殊用途,一旦终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作，如：</p>
<ul>
<li>遇上0×10, 终端就换行；</li>
<li>遇上0×07, 终端就向人们嘟嘟叫；</li>
</ul>
<p>又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第 127 号，这样计算机就可以用不同字节来存储英语的文字了</p>
<p>这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0</p>
<p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/Encoding/ascii.jpg"></p>
<p>这个方案叫做 ASCII 编码</p>
<blockquote>
<p>American Standard Code for Information Interchange：美国信息互换标准代码</p>
</blockquote>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312 #"></a>GB2312 <a href="#t715-gb2312">#</a></h3><p>后来西欧一些国家用的不是英文，它们的字母在ASCII里没有为了可以保存他们的文字，他们使用127号这后的空位来保存新的字母，一直编到了最后一位255。比如法语中的é的编码为130。当然了不同国家表示的符号也不一样，比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)。</p>
<blockquote>
<p>从128 到 255 这一页的字符集被称为扩展字符集。</p>
</blockquote>
<p>中国为了表示汉字，把127号之后的符号取消了，规定</p>
<ul>
<li>一个小于127的字符的意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字；</li>
<li>前面的一个字节（他称之为高字节）从 <code>0xA1</code>用到 <code>0xF7</code>，后面一个字节（低字节）从 <code>0xA1</code> 到 <code>0xFE</code>；</li>
<li>这样我们就可以组合出大约7000多个(247-161)*(254-161)=(7998)简体汉字了。</li>
<li>还把数学符号、日文假名和ASCII里原来就有的数字、标点和字母都重新编成两个字长的编码。这就是全角字符，127以下那些就叫半角字符。</li>
<li>把这种汉字方案叫做 GB2312。GB2312 是对 ASCII 的中文扩展</li>
</ul>
<h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK #"></a>GBK <a href="#t816-gbk">#</a></h3><p>后来还是不够用，于是干脆不再要求低字节一定是 127 号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始,又增加了近 20000 个新的汉字（包括繁体字）和符号。</p>
<h3 id="GB18030-DBCS"><a href="#GB18030-DBCS" class="headerlink" title="GB18030 / DBCS #"></a>GB18030 / DBCS <a href="#t917-gb18030--dbcs">#</a></h3><p>又加了几千个新的少数民族的字， <code>GBK</code>扩成了 <code>GB18030</code> 通称他们叫做 DBCS</p>
<blockquote>
<p>Double Byte Character Set：双字节字符集。</p>
</blockquote>
<p>在 DBCS 系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里</p>
<p>各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode #"></a>Unicode <a href="#t1018-unicode">#</a></h3><p>ISO 的国际组织废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符 的编码！ Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。</p>
<ul>
<li>International Organization for Standardization：国际标准化组织。</li>
<li>Universal Multiple-Octet Coded Character Set，简称 UCS，俗称 Unicode</li>
</ul>
<p>ISO 就直接规定必须用两个字节，也就是 16 位来统一表示所有的字符，对于 ASCII 里的那些 半角字符，Unicode 保持其原编码不变，只是将其长度由原来的 8 位扩展为16 位，而其他文化和语言的字符则全部重新统一编码。</p>
<p>从 Unicode 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的一个字符！同时，也都是统一的 两个字节</p>
<ul>
<li>字节是一个8位的物理存贮单元，</li>
<li>而字符则是一个文化相关的符号。</li>
</ul>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8 #"></a>UTF-8 <a href="#t1119-utf-8">#</a></h3><p>Unicode 在很长一段时间内无法推广，直到互联网的出现，为解决 Unicode 如何在网络上传输的问题，于是面向传输的众多 UTF 标准出现了，</p>
<blockquote>
<p>Universal Character Set（UCS）Transfer Format：UTF编码</p>
</blockquote>
<ul>
<li>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式</li>
<li>UTF-8就是每次以8个位为单位传输数据</li>
<li>而UTF-16就是每次 16 个位</li>
<li>UTF-8 最大的一个特点，就是它是一种变长的编码方式</li>
<li>Unicode 一个中文字符占 2 个字节，而 UTF-8 一个中文字符占 3 个字节</li>
<li>UTF-8 是 Unicode 的实现方式之一</li>
</ul>
<h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则 #"></a>编码规则 <a href="#t12110-%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99">#</a></h3><p> 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。<br> 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n+ 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Unicode符号范围     |        UTF-<span class="number">8</span>编码方式</span><br><span class="line">(十六进制)        |              （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line"><span class="number">0</span>000 <span class="number">0</span>000-<span class="number">0</span>000 <span class="number">0</span>07F | <span class="number">0</span>xxxxxxx</span><br><span class="line"><span class="number">0</span>000 <span class="number">0</span>080-<span class="number">0</span>000 <span class="number">0</span>7FF | <span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0</span>000 <span class="number">0</span>800-<span class="number">0</span>000 FFFF | <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0</span>001 <span class="number">0</span>000-<span class="number">0</span>010 FFFF | <span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://www.chi2ko.com/tool/CJK.htm">Unicode编码</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ary = [<span class="string">&#x27;1110&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> binary = num.toString(<span class="number">2</span>);</span><br><span class="line">  ary[<span class="number">2</span>] = ary[<span class="number">2</span>]+binary.slice(binary.length-<span class="number">6</span>);</span><br><span class="line">  ary[<span class="number">1</span>] = ary[<span class="number">1</span>]+binary.slice(binary.length-<span class="number">12</span>,binary.length-<span class="number">6</span>);</span><br><span class="line">  ary[<span class="number">0</span>] = ary[<span class="number">0</span>]+binary.slice(<span class="number">0</span>,binary.length-<span class="number">12</span>).padStart(<span class="number">4</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> result =  ary.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(result,<span class="number">2</span>).toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&amp;#x4E07;</span></span><br><span class="line"><span class="keyword">let</span> result = transfer(<span class="number">0x4E07</span>);<span class="comment">//E4B887</span></span><br></pre></td></tr></table></figure>

<h3 id="联通不如移动"><a href="#联通不如移动" class="headerlink" title="联通不如移动 #"></a>联通不如移动 <a href="#t13111-%E8%81%94%E9%80%9A%E4%B8%8D%E5%A6%82%E7%A7%BB%E5%8A%A8">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C1 1100 0001</span><br><span class="line">AA 1010 1010</span><br><span class="line">CD 1100 1101</span><br><span class="line">A8 1010 1000</span><br><span class="line"></span><br><span class="line">0000000001101010-&gt;006A(106)-&gt;j</span><br><span class="line">0000001101101000-&gt;0368(872)-&gt;?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://tools.jb5net/table/gb2312">GB2312</a></li>
<li><a href="http://blog.csdn.net/hherima/article/details/9045765">unicode编码表1</a></li>
<li><a href="http://blog.csdn.net/hherima/article/details/9045861">unicode编码表2</a></li>
</ul>
<h3 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码 #"></a>文本编码 <a href="#t14112-%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81">#</a></h3><p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。</p>
<h4 id="1-BOM的移除"><a href="#1-BOM的移除" class="headerlink" title=".1 BOM的移除 #"></a>.1 BOM的移除 <a href="#t151121-bom%E7%9A%84%E7%A7%BB%E9%99%A4">#</a></h4><p>BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> Bytes      Encoding</span><br><span class="line">----------------------------</span><br><span class="line"> FE FF       UTF16BE</span><br><span class="line"> FF FE       UTF16LE</span><br><span class="line"> EF BB BF    UTF8</span><br></pre></td></tr></table></figure>

<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line">    <span class="keyword">if</span> (bin[<span class="number">0</span>] === <span class="number">0xEF</span> &amp;&amp; bin[<span class="number">1</span>] === <span class="number">0xBB</span> &amp;&amp; bin[<span class="number">2</span>] === <span class="number">0xBF</span>) &#123;</span><br><span class="line">        bin = bin.slice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bin.toString(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-GBK转UTF8"><a href="#2-GBK转UTF8" class="headerlink" title=".2 GBK转UTF8 #"></a>.2 GBK转UTF8 <a href="#t161122-gbk%E8%BD%ACutf8">#</a></h4><p>NodeJS支持在读取文本文件时，或者在Buffer转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助iconv-lite这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">&#x27;iconv-lite&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readGBKText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line">    <span class="keyword">return</span> iconv.decode(bin, <span class="string">&#x27;gbk&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读 #"></a>扩展阅读 <a href="#t17112-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">#</a></h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-html">utf-8</a></li>
<li><a href="https://tianziyao.github.io/2017/07/03/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E6%95%85%E4%BA%8B/">字符编码的故事</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端整理</category>
      </categories>
      <tags>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>js异步</title>
    <url>/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/js%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul>
<li>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段,比如，有一个任务是读取文件进行处理，异步的执行过程就是下面这样。</li>
</ul>
<p><img src="http://img.zhufengpeixun.cn/asyncfunc1.png"></p>
<p>这种不连续的执行，就叫做异步。相应地，连续的执行，就叫做同步。</p>
<p><img src="http://img.zhufengpeixun.cn/syncfunc.png"></p>
<h2 id="异步编程的语法目标，就是怎样让它更像同步编程-有以下几种"><a href="#异步编程的语法目标，就是怎样让它更像同步编程-有以下几种" class="headerlink" title="异步编程的语法目标，就是怎样让它更像同步编程,有以下几种"></a>异步编程的语法目标，就是怎样让它更像同步编程,有以下几种</h2><ul>
<li>回调函数实现</li>
<li>事件监听</li>
<li>发布订阅</li>
<li>Promise/A+ 和生成器函数</li>
<li>async/await</li>
</ul>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;&amp;#x67D0;&amp;#x4E2A;&amp;#x6587;&amp;#x4EF6;&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这是一个错误优先的回调函数(error-first callbacks),这也是 Node.js 本身的特点之一。</p>
<a id="more"></a>
<h2 id="回调的问题"><a href="#回调的问题" class="headerlink" title="回调的问题"></a>回调的问题</h2><h3 id="5-1-异常处理"><a href="#5-1-异常处理" class="headerlink" title="5.1 异常处理"></a>5.1 异常处理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//xxx</span></span><br><span class="line">&#125;<span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span>&#123;<span class="comment">//TODO&#125;</span></span><br></pre></td></tr></table></figure>

<p>异步代码时 <code>try catch</code>不再生效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;&amp;#x6355;&amp;#x83B7;&amp;#x9519;&amp;#x8BEF;&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(t);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为这个回调函数被存放了起来，直到下一个事件环的时候才会取出,try 只能捕获当前循环内的异常，对 callback 异步无能为力。</p>
<p>Node 在处理异常有一个约定，将异常作为回调的第一个实参传回，如果为空表示没有出错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params">err, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>异步方法也要遵循两个原则</p>
<ul>
<li>必须在异步之后调用传入的回调函数</li>
<li>如果出错了要向回调函数传入异常供调用者判断</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (success) callback(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span> callback(<span class="string">&quot;&amp;#x9519;&amp;#x8BEF;&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;&amp;#x6355;&amp;#x83B7;&amp;#x9519;&amp;#x8BEF;&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**回调地狱<a href="#t852-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1">#</a>**异步多级依赖的情况下嵌套非常深，代码难以阅读的维护</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.readFile(<span class="string">&quot;template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(template + <span class="string">&quot; &quot;</span> + data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="异步流程解决方案"><a href="#异步流程解决方案" class="headerlink" title="异步流程解决方案"></a>异步流程解决方案</h2><h3 id="事件发布-订阅模型"><a href="#事件发布-订阅模型" class="headerlink" title="事件发布/订阅模型"></a>事件发布/订阅模型</h3><p>订阅事件实现了一个事件与多个回调函数的关联</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> eve = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="keyword">let</span> html = &#123;&#125;;</span><br><span class="line">eve.on(<span class="string">&quot;ready&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  html[key] = value;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(html).length == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(html);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    eve.emit(<span class="string">&quot;ready&quot;</span>, <span class="string">&quot;template&quot;</span>, template);</span><br><span class="line">  &#125;);</span><br><span class="line">  fs.readFile(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    eve.emit(<span class="string">&quot;ready&quot;</span>, <span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h3 id="哨兵变量"><a href="#哨兵变量" class="headerlink" title="哨兵变量"></a>哨兵变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> after = <span class="function"><span class="keyword">function</span> (<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    result[key] = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(result).length == times) &#123;</span><br><span class="line">      callback(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> done = after(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    done(<span class="string">&quot;template&quot;</span>, template);</span><br><span class="line">  &#125;);</span><br><span class="line">  fs.readFile(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    done(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">rende;</span><br></pre></td></tr></table></figure>

<h3 id="Promise-Deferred-模式"><a href="#Promise-Deferred-模式" class="headerlink" title="Promise/Deferred 模式"></a>Promise/Deferred 模式</h3><h3 id="生成器-Generators-yield"><a href="#生成器-Generators-yield" class="headerlink" title="生成器 Generators/ yield"></a>生成器 Generators/ yield</h3><ul>
<li>当你在执行一个函数的时候，你可以在某个点暂停函数的执行，并且做一些其他工作，然后再返回这个函数继续执行， 甚至是携带一些新的值，然后继续执行。</li>
<li>上面描述的场景正是 JavaScript 生成器函数所致力于解决的问题。当我们调用一个生成器函数的时候，它并不会立即执行， 而是需要我们手动的去执行迭代操作（next 方法）。也就是说，你调用生成器函数，它会返回给你一个迭代器。迭代器会遍历每个中断点。</li>
<li>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据</li>
</ul>
<h4 id="生成器的使用"><a href="#生成器的使用" class="headerlink" title="生成器的使用"></a>生成器的使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.next()); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Co"><a href="#Co" class="headerlink" title="Co"></a>Co</h4><p><code>co</code>是一个为 <code>Node.js</code>和浏览器打造的基于生成器的流程控制工具，借助于 Promise，你可以使用更加优雅的方式编写非阻塞代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="keyword">else</span> resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> template = <span class="keyword">yield</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">&#125;</span><br><span class="line">co(read).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> it = gen();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    !(<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">lastVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; value, done &#125; = it.next(lastVal);</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value.then(next, <span class="function">(<span class="params">reason</span>) =&gt;</span> reject(reason));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/ await"></a>Async/ await</h2><p>使用 <code>async</code>关键字，你可以轻松地达成之前使用生成器和 co 函数所做到的工作</p>
<h3 id="Async-的优点"><a href="#Async-的优点" class="headerlink" title="Async 的优点"></a>Async 的优点</h3><ul>
<li>内置执行器</li>
<li>更好的语义</li>
<li>更广的适用性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="keyword">else</span> resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> template = <span class="keyword">await</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = read();</span><br><span class="line">result.then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data));</span><br></pre></td></tr></table></figure>

<h3 id="async-函数的实现"><a href="#async-函数的实现" class="headerlink" title="async 函数的实现"></a>async 函数的实现</h3><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> template = <span class="keyword">await</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> template = <span class="keyword">yield</span> readFile(<span class="string">&quot;./template.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> template + <span class="string">&quot;+&quot;</span> + data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端整理</category>
      </categories>
      <tags>
        <tag>js异步</tag>
      </tags>
  </entry>
  <entry>
    <title>module&amp;NPM</title>
    <url>/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/module&amp;NPM/</url>
    <content><![CDATA[<h2 id="JS模块化方面的不足"><a href="#JS模块化方面的不足" class="headerlink" title="JS模块化方面的不足 #"></a>JS模块化方面的不足 <a href="#t01-js%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B8%8D%E8%B6%B3">#</a></h2><ul>
<li>JS没有模块系统，不支持封闭的作用域和依赖管理</li>
<li>没有标准库，没有文件系统和IO流API</li>
<li>也没有包管理系统</li>
</ul>
<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范 #"></a>CommonJS规范 <a href="#t12-commonjs%E8%A7%84%E8%8C%83">#</a></h2><ul>
<li>封装功能</li>
<li>封闭作用域</li>
<li>可能解决依赖问题</li>
<li>工作效率更高，重构方便</li>
</ul>
<h2 id="Node中的CommonJS"><a href="#Node中的CommonJS" class="headerlink" title="Node中的CommonJS #"></a>Node中的CommonJS <a href="#t23-node%E4%B8%AD%E7%9A%84commonjs">#</a></h2><ul>
<li>在node.js 里，模块划分所有的功能，每个JS都是一个模块</li>
<li>实现require方法,NPM实现了模块的自动加载和安装依赖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>,<span class="built_in">require</span>,<span class="built_in">module</span>,__filename,__dirname</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">exports</span> = <span class="built_in">module</span>.exports=&#123;&#125;</span><br><span class="line">  <span class="built_in">exports</span>.name = <span class="string">&#x27;zfpx&#x27;</span>;</span><br><span class="line">  <span class="built_in">exports</span> = &#123;<span class="attr">name</span>:<span class="string">&#x27;zfpx&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类 #"></a>模块分类 <a href="#t34-%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB">#</a></h2><h3 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块 #"></a>原生模块 <a href="#t441-%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97">#</a></h3><p><code>http</code> <code>path</code> <code>fs</code> <code>util</code> <code>events</code> 编译成二进制,加载速度最快，原来模块通过名称来加载</p>
<h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块 #"></a>文件模块 <a href="#t542-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97">#</a></h3><p>在硬盘的某个位置，加载速度非常慢，文件模块通过名称或路径来加载 文件模块的后缀有三种</p>
<ul>
<li>后缀名为.js的JavaScript脚本文件,需要先读入内存再运行</li>
<li>后缀名为.json的JSON文件,fs 读入内存 转化成JSON对象</li>
<li>后缀名为.node的经过编译后的二进制C/C++扩展模块文件,可以直接使用</li>
</ul>
<blockquote>
<p>一般自己写的通过路径来加载,别人写的通过名称去当前目录或全局的node_modules下面去找</p>
</blockquote>
<h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块 #"></a>第三方模块 <a href="#t643-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97">#</a></h3><ul>
<li>如果require函数只指定名称则视为从node_modules下面加载文件，这样的话你可以移动模块而不需要修改引用的模块路径</li>
<li>第三方模块的查询路径包括module.paths和全局目录</li>
</ul>
<h4 id="全局目录"><a href="#全局目录" class="headerlink" title=". 全局目录 #"></a>. 全局目录 <a href="#t7431--%E5%85%A8%E5%B1%80%E7%9B%AE%E5%BD%95">#</a></h4><p>window如果在环境变量中设置了 <code>NODE_PATH</code>变量，并将变量设置为一个有效的磁盘目录，require在本地找不到此模块时向在此目录下找这个模块。 UNIX操作系统中会从 $HOME/.node_modules $HOME/.node_libraries目录下寻找</p>
<h3 id="模块的加载策略"><a href="#模块的加载策略" class="headerlink" title="模块的加载策略 #"></a>模块的加载策略 <a href="#t844-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5">#</a></h3><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/module&NPM/lookmodule.png"></p>
<h3 id="文件模块查找规则"><a href="#文件模块查找规则" class="headerlink" title="文件模块查找规则 #"></a>文件模块查找规则 <a href="#t945-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99">#</a></h3><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/module&NPM/lookfile.png"></p>
<h2 id="从模块外部访问模块内的成员"><a href="#从模块外部访问模块内的成员" class="headerlink" title="从模块外部访问模块内的成员 #"></a>从模块外部访问模块内的成员 <a href="#t105-%E4%BB%8E%E6%A8%A1%E5%9D%97%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84%E6%88%90%E5%91%98">#</a></h2><ul>
<li>使用exports对象</li>
<li>使用module.exports导出引用类型</li>
</ul>
<h2 id="模块对象的属性"><a href="#模块对象的属性" class="headerlink" title="模块对象的属性 #"></a>模块对象的属性 <a href="#t116-%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">#</a></h2><ul>
<li>module.id</li>
<li>module.filename</li>
<li>module.loaded</li>
<li>module.parent</li>
<li>module.children</li>
<li>module.paths</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包 #"></a>包 <a href="#t127-%E5%8C%85">#</a></h2><p>在Node.js中，可以通过包来对一组具有相互依赖关系的模块进行统一管理，通过包可以把某个独立功能封装起来 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境</p>
<p>项目 描述 name 项目名称 version 版本号 description 项目描述 keywords: {Array} 关键词，便于用户搜索到我们的项目 homepage 项目url主页 bugs 项目问题反馈的Url或email配置 license 项目许可证 author,contributors 作者和贡献者 main 主文件 bin 项目用到的可执行文件配置 repository 项目代码存放地方 scripts 声明一系列npm脚本指令 dependencies 项目在生产环境中依赖的包 devDependencies 项目在生产环境中依赖的包 peerDependencies 应用运行依赖的宿主包</p>
<p><a href="https://docs.npmjs.com/files/package.json">package.json</a> <a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html">packagejson</a></p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM #"></a>NPM <a href="#t138-npm">#</a></h2><ul>
<li>安装完node之后只能使用Node语言特性及核心函数，我们还需要一个系统来下载、安装和管理第三方模块</li>
<li>在Node里这个系统被称为Node包管理器(Node Package Manager,NPM)</li>
</ul>
<h3 id="npm提供的功能"><a href="#npm提供的功能" class="headerlink" title="npm提供的功能 #"></a>npm提供的功能 <a href="#t1481-npm%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD">#</a></h3><ul>
<li>公共注册服务，用户可以把自己写的包上传到服务器上</li>
<li>命令行下载工具，用户可以通过npm命令把别人写的包下载到自己电脑上，还可以管理自己模块依赖的其它模块</li>
</ul>
<p>搜索第三方包的地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//www.npmjs.com/search</span></span><br></pre></td></tr></table></figure>

<h3 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令 #"></a>npm命令 <a href="#t1582-npm%E5%91%BD%E4%BB%A4">#</a></h3><h4 id="npm-install-安装包"><a href="#npm-install-安装包" class="headerlink" title="(npm install)安装包 #"></a>(npm install)安装包 <a href="#t16821-npm-install%E5%AE%89%E8%A3%85%E5%8C%85">#</a></h4><ul>
<li>打开命令行或终端，进入要安装包的目录,然后执行以下命令安装依赖的模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install &lt;package-name&gt;</span><br><span class="line">npm i mime</span><br><span class="line">&lt;/package-name&gt;</span><br></pre></td></tr></table></figure>

<p>此命令会从服务器上下载此模块到当前目录下的node_modules目录下，如果node_modules目录不存在则会创建一个</p>
<ul>
<li>也可以安装特定的版本</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install &lt;package name&gt;@&lt;version spec&gt;</span><br><span class="line">npm i mime@<span class="number">2.1</span></span><br><span class="line">&lt;<span class="regexp">/version&gt;&lt;/</span>package&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以使用一个版本号范围来替换点位符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i mime@<span class="number">2.</span>x</span><br></pre></td></tr></table></figure>

<h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包 #"></a>卸载包 <a href="#t17822-%E5%8D%B8%E8%BD%BD%E5%8C%85">#</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm uninstall &lt;package name&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure>

<h4 id="更新包"><a href="#更新包" class="headerlink" title="更新包 #"></a>更新包 <a href="#t18823-%E6%9B%B4%E6%96%B0%E5%8C%85">#</a></h4><p>我们还可以通过以下指令更新已经安装的包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm update &lt;package name&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure>

<h3 id="包的安装模式"><a href="#包的安装模式" class="headerlink" title="包的安装模式 #"></a>包的安装模式 <a href="#t1983-%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E6%A8%A1%E5%BC%8F">#</a></h3><h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装 #"></a>本地安装 <a href="#t20831-%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85">#</a></h4><ul>
<li>默认情况下安装命令会把对应的包安装到当前目录下，这叫本地安装，如果包里有可执行的文件NPM会把可执行文件安装到 <code>./node_modules/.bin</code>目录下</li>
<li>本地安装的模块只能在当前目录和当前目录的子目录里面使用</li>
</ul>
<h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装 #"></a>全局安装 <a href="#t21832-%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85">#</a></h4><ul>
<li>如果希望安装的包能够在计算机机的所有目录下面都能使用就需要全局安装</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install  -g</span><br><span class="line">npm install mime -g</span><br><span class="line">C:\Users\zhufeng\AppData\Roaming\npm\node_modules\mime</span><br></pre></td></tr></table></figure>

<ul>
<li>在全局安装的模式下，npm会把包安装到全局目录，通过此命令可以查看当前全局目录的位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm root -g</span><br><span class="line">C:\Users\Administrator\AppData\Roaming\npm\node_modules</span><br></pre></td></tr></table></figure>

<ul>
<li>如果包里有可执行文件，会把可执行文件安装到此node_modules的上一级目录中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\npm</span><br></pre></td></tr></table></figure>

<ul>
<li>全局安装的一般是需要在任意目录下面执行的命令，比如 <code>babel</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install babel-cli -g</span><br></pre></td></tr></table></figure>

<ul>
<li>如果全局安装的命令不能用则可能是没有正确配置用户变量 <code>PATH</code>,需要在系统变量中为 <code>PATH</code>变量添加全局安装目录</li>
</ul>
<h3 id="注册、登录和发布模块"><a href="#注册、登录和发布模块" class="headerlink" title="注册、登录和发布模块 #"></a>注册、登录和发布模块 <a href="#t2283-%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E5%92%8C%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97">#</a></h3><ol>
<li><p>注册npm账号 <a href="https://www.npmjs.com/">npmjs</a></p>
<p>登录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure>

<p>发布</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="npx"><a href="#npx" class="headerlink" title="npx #"></a>npx <a href="#t2384-npx">#</a></h3><ul>
<li>npm 从5.2版开始，增加了 npx 命令</li>
</ul>
<h4 id="调用项目安装的模块"><a href="#调用项目安装的模块" class="headerlink" title="调用项目安装的模块 #"></a>调用项目安装的模块 <a href="#t24841-%E8%B0%83%E7%94%A8%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%E7%9A%84%E6%A8%A1%E5%9D%97">#</a></h4><ul>
<li>npx 想要解决的主要问题，就是调用项目内部安装的模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -D mocha</span><br></pre></td></tr></table></figure>

<p> 一般来说，调用mocha只能在 <code>package.json</code>的scripts字段里面使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;mocha -version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx mocha --version</span><br></pre></td></tr></table></figure>

<ul>
<li>npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在</li>
</ul>
<h4 id="避免全局安装模块"><a href="#避免全局安装模块" class="headerlink" title="避免全局安装模块 #"></a>避免全局安装模块 <a href="#t25842-%E9%81%BF%E5%85%8D%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97">#</a></h4><ul>
<li>除了调用项目内部模块，npx 还能避免全局安装的模块。比如， <code>create-react-app</code>这个模块是全局安装,npx 可以运行它,而且不进行全局安装</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-react-app</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除</li>
</ul>
<h4 id="–no-install-参数和–ignore-existing-参数"><a href="#–no-install-参数和–ignore-existing-参数" class="headerlink" title="–no-install 参数和–ignore-existing 参数 #"></a>–no-install 参数和–ignore-existing 参数 <a href="#t26843---no-install-%E5%8F%82%E6%95%B0%E5%92%8C--ignore-existing-%E5%8F%82%E6%95%B0">#</a></h4><ul>
<li>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用 <code>--no-install</code>参数。如果本地不存在该模块，就会报错</li>
<li>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用 <code>--ignore-existing</code>参数</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端整理</category>
      </categories>
      <tags>
        <tag>module&amp;NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>node</title>
    <url>/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/</url>
    <content><![CDATA[<h2 id="Node-能够解决什么问题"><a href="#Node-能够解决什么问题" class="headerlink" title="Node 能够解决什么问题? #"></a>Node 能够解决什么问题? <a href="#t01-node%E8%83%BD%E5%A4%9F%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">#</a></h2><ul>
<li>Node 的首要目标是提供一种简单的，用于创建高性能服务器的开发工具</li>
<li>Web 服务器的瓶颈在于并发的用户量，对比 Java 和 Php 的实现方式</li>
</ul>
<h2 id="Node-是什么"><a href="#Node-是什么" class="headerlink" title="Node 是什么? #"></a>Node 是什么? <a href="#t12-node%E6%98%AF%E4%BB%80%E4%B9%88">#</a></h2><ul>
<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境,让 JavaScript 的执行效率与低端的 C 语言的相近的执行效率。。</li>
<li>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</li>
<li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li>
</ul>
<h2 id="Node-特点"><a href="#Node-特点" class="headerlink" title="Node 特点 #"></a>Node 特点 <a href="#t23-node%E7%89%B9%E7%82%B9">#</a></h2><h3 id="为什么-JavaScript-是单线程？"><a href="#为什么-JavaScript-是单线程？" class="headerlink" title="为什么 JavaScript 是单线程？ #"></a>为什么 JavaScript 是单线程？ <a href="#t331-%E4%B8%BA%E4%BB%80%E4%B9%88javascript%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B">#</a></h3><ul>
<li>这是由 Javascript 这门脚本语言的用途决定的。</li>
<li>Web Worker 并没有改变 JavaScript 单线程的本质。</li>
</ul>
<h3 id="浏览器模型"><a href="#浏览器模型" class="headerlink" title="浏览器模型 #"></a>浏览器模型 <a href="#t432-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B">#</a></h3><ul>
<li>用户界面-包括地址栏、前进/后退按钮、书签菜单等</li>
<li>浏览器引擎-在用户界面和呈现引擎之间传送指令</li>
<li>呈现引擎-又称渲染引擎，也被称为浏览器内核，在线程方面又称为 UI 线程</li>
<li>网络-用于网络调用，比如 HTTP 请求</li>
<li>用户界面后端-用于绘制基本的窗口小部件,UI 线程和 JS 共用一个线程</li>
<li>JavaScript 解释器-用于解析和执行 JavaScript 代码</li>
<li>数据存储-这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie</li>
</ul>
<p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/browser.jpg"></p>
<h3 id="除-JS-线程和-UI-线程之外的其它线程"><a href="#除-JS-线程和-UI-线程之外的其它线程" class="headerlink" title="除 JS 线程和 UI 线程之外的其它线程 #"></a>除 JS 线程和 UI 线程之外的其它线程 <a href="#t533-%E9%99%A4js%E7%BA%BF%E7%A8%8B%E5%92%8Cui%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A4%96%E7%9A%84%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B">#</a></h3><ul>
<li>浏览器事件触发线程</li>
<li>定时触发器线程</li>
<li>异步 HTTP 请求线程</li>
</ul>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列 #"></a>任务队列 <a href="#t634-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97">#</a></h3><ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>一旦执行栈中的所有 <strong>同步任务</strong>执行完毕，系统就会读取 <strong>任务队列</strong>，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop #"></a>Event Loop <a href="#t735-event-loop">#</a></h3><p>主线程从 <strong>任务队列</strong>中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop(事件循环)</p>
<p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/eventloop.png"></p>
<h3 id="Node-js-的-Event-Loop"><a href="#Node-js-的-Event-Loop" class="headerlink" title="Node.js 的 Event Loop #"></a>Node.js 的 Event Loop <a href="#t836-nodejs%E7%9A%84event-loop">#</a></h3><p><img src="/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/node/nodesystem.png"></p>
<h2 id="node-js-的主要依赖⼦模块有以下内容"><a href="#node-js-的主要依赖⼦模块有以下内容" class="headerlink" title="node.js 的主要依赖⼦模块有以下内容"></a>node.js 的主要依赖⼦模块有以下内容</h2><ul>
<li>V8 引擎：主要是 JS 语法的解析，有了它才能识别 JS语法</li>
<li>libuv: c 语⾔实现的⼀个⾼性能异步⾮阻塞 IO 库，⽤来实现 node.js 的事件循环</li>
<li>http-parser/llhttp: 底层处理 http 请求，处理报⽂，解析请求包等内容</li>
<li>openssl: 处理加密算法，各种框架运⽤⼴泛</li>
<li>zlib: 处理压缩等内容</li>
</ul>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步 #"></a>同步与异步 <a href="#t937-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5">#</a></h3><p>同步和异步关注的是消息通知机制</p>
<ul>
<li>同步就是发出调用后，没有得到结果之前，该调用不返回，一旦调用返回，就得到返回值了。 简而言之就是调用者主动等待这个调用的结果</li>
<li>而异步则相反，调用者在发出调用后这个调用就直接返回了，所以没有返回结果。换句话说当一个异步过程调用发出后，调用者不会立刻得到结果，而是调用发出后，被调用者通过状态、通知或回调函数处理这个调用。</li>
</ul>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞 #"></a>阻塞与非阻塞 <a href="#t1038-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E">#</a></h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
<ul>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合 #"></a>组合 <a href="#t1139-%E7%BB%84%E5%90%88">#</a></h3><p>同步异步取决于被调用者，阻塞非阻塞取决于调用者</p>
<ul>
<li>同步阻塞</li>
<li>异步阻塞</li>
<li>同步非阻塞</li>
<li>异步非阻塞</li>
</ul>
<h2 id="什么场合下应该考虑使用-Node-框架"><a href="#什么场合下应该考虑使用-Node-框架" class="headerlink" title="什么场合下应该考虑使用 Node 框架 #"></a>什么场合下应该考虑使用 Node 框架 <a href="#t124%E4%BB%80%E4%B9%88%E5%9C%BA%E5%90%88%E4%B8%8B%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8node%E6%A1%86%E6%9E%B6">#</a></h2><p>当应用程序需要处理大量并发的输入输出，而在向客户端响应之前，应用程序并不需要进行非常复杂的处理。</p>
<ul>
<li>聊天服务器</li>
<li>电子商务网站</li>
</ul>
<h2 id="node-部署"><a href="#node-部署" class="headerlink" title="node 部署"></a>node 部署</h2><h3 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h3><ul>
<li>forever则可以在cmd或ssh连接断开时,让项目一直运行,而且可以在项目崩溃时自动重启</li>
<li>安装 npm install -g forever</li>
<li>forever的帮助手册 forever –help</li>
<li>使用forever启动项目 forever start app.js</li>
<li>使用forever停止项目 forever stop app.js</li>
<li>列出所有通过forever管理的项目 forever list</li>
<li>监视项目中的文件,当文件有变动时重启项目 forever -w start app.js</li>
</ul>
<h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>PM2 是具有内置负载均衡器的 Node.js 应用程序的生产流程管理器。它允许您使应用程序永远保持活动状态，在不停机的情况下重新加载它们，并促进常见的系统管理任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 全局安装</span><br><span class="line">&gt; npm install pm2 -g</span><br><span class="line"># pm2启动项目</span><br><span class="line">&gt; pm2 start index.js</span><br><span class="line"># pm2停止项目</span><br><span class="line">&gt; pm2 stop index.js</span><br><span class="line"># 列出pm2管理的所有项目 </span><br><span class="line">&gt; pm2 list</span><br><span class="line"># 追踪资源运行情况</span><br><span class="line">&gt; pm2 monit</span><br><span class="line"># 查看日志</span><br><span class="line">&gt; pm2 logs</span><br><span class="line"># pm2重启项目</span><br><span class="line">&gt; pm2 restart id/name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端整理</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>nodeCore</title>
    <url>/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/nodeCore/</url>
    <content><![CDATA[<h2 id="控制台"><a href="#控制台" class="headerlink" title=". 控制台"></a>. 控制台</h2><p>在 Node.js 中，使用 <code>console</code>对象代表控制台(在操作系统中表现为一个操作系统指定的字符界面，比如 Window 中的命令提示窗口)。</p>
<ul>
<li>console.log</li>
<li>console.info</li>
<li>console.error 重定向到文件</li>
<li>console.warn</li>
<li>console.dir</li>
<li>console.time</li>
<li>console.timeEnd</li>
<li>console.trace</li>
<li>console.assert</li>
</ul>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title=". 全局作用域"></a>. 全局作用域</h2><ul>
<li>全局作用域(global)可以定义一些不需要通过任何模块的加载即可使用的变量、函数或类</li>
<li>定义全局变量时变量会成为 global 的属性。</li>
<li>永远不要不使用 var 关键字定义变量，以免污染全局作用域</li>
<li>setTimeout clearTimeout</li>
<li>setInterval clearInterval</li>
<li>unref 和 ref</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;callback&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(test, <span class="number">1000</span>);</span><br><span class="line">timer.unref();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  timer.ref();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title=". 函数"></a>. 函数</h2><ul>
<li>require</li>
<li>模块加载过程</li>
<li>require.resolve</li>
<li>模板缓存(require.cache)</li>
<li>require.main</li>
<li>模块导出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports, <span class="built_in">require</span>, <span class="built_in">module</span>, filename, dirname;</span><br></pre></td></tr></table></figure>

<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>在 node.js 里，process 对象代表 node.js 应用程序，可以获取应用程序的用户，运行环境等各种信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.argv.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(<span class="string">&quot;exit&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">&quot;uncaughtException&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line">process.chdir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">err</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&amp;#x62A5;&amp;#x9519;&amp;#x4E86;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">err();</span><br></pre></td></tr></table></figure>

<ul>
<li>process.nextTick()方法将 callback 添加到”next tick 队列”。 一旦当前事件轮询队列的任务全部完成，在 next tick 队列中的所有 callbacks 会被依次调用。</li>
<li>setImmediate 预定立即执行的 callback，它是在 I/O 事件的回调之后被触发</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;next&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title=". EventEmitter"></a>. EventEmitter</h2><p>在 Node.js 的用于实现各种事件处理的 event 模块中，定义了 EventEmitter 类，所以可能触发事件的对象都是一个继承自 EventEmitter 类的子类实例对象。</p>
<table>
<thead>
<tr>
<th>方法名和参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>addListener(event,listener)</td>
<td align="left">对指定事件绑定事件处理函数</td>
</tr>
<tr>
<td>on(event,listener)</td>
<td align="left">对指定事件绑定事件处理函数</td>
</tr>
<tr>
<td>once(event,listener)</td>
<td align="left">对指定事件指定只执行一次的事件处理函数</td>
</tr>
<tr>
<td>removeListener(event,listener)</td>
<td align="left">对指定事件解除事件处理函数</td>
</tr>
<tr>
<td>removeAllListeners([event])</td>
<td align="left">对指定事件解除所有的事件处理函数</td>
</tr>
<tr>
<td>setMaxListeners(n)</td>
<td align="left">指定事件处理函数的最大数量.n为整数值，代表最大的可指定事件处理函数的数量</td>
</tr>
<tr>
<td>listeners(event)</td>
<td align="left">获取指定事件的所有事件处理函数</td>
</tr>
<tr>
<td>emit(event,[arg1],[arg2],[…])</td>
<td align="left">手工触发指定事件</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;./events&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line">util.inherits(Bell,EventEmitter);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bell</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bell = <span class="keyword">new</span> Bell();</span><br><span class="line">bell.on(<span class="string">&#x27;newListener&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`对 <span class="subst">$&#123;type&#125;</span>  事件增加<span class="subst">$&#123;listener&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">bell.on(<span class="string">&#x27;removeListener&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`对<span class="subst">$&#123;type&#125;</span> 事件删除<span class="subst">$&#123;listener&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">teacherIn</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`老师带<span class="subst">$&#123;thing&#125;</span>进教室`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">studentIn</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`学生带<span class="subst">$&#123;thing&#125;</span>进教室`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">masterIn</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`校长带<span class="subst">$&#123;thing&#125;</span>进教室`</span>);</span><br><span class="line">&#125;</span><br><span class="line">bell.on(<span class="string">&#x27;响&#x27;</span>,teacherIn);</span><br><span class="line">bell.on(<span class="string">&#x27;响&#x27;</span>,studentIn);</span><br><span class="line">bell.once(<span class="string">&#x27;响&#x27;</span>,masterIn);</span><br><span class="line">bell.emit(<span class="string">&#x27;响&#x27;</span>,<span class="string">&#x27;书&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span>);</span><br><span class="line">bell.emit(<span class="string">&#x27;响&#x27;</span>,<span class="string">&#x27;书&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span>);</span><br><span class="line">bell.removeAllListeners(<span class="string">&#x27;响&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;==============&#x27;</span>);</span><br><span class="line">bell.emit(<span class="string">&#x27;响&#x27;</span>,<span class="string">&#x27;书&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.events = &#123;&#125;;<span class="comment">//会把所有的事件监听函数放在这个对象里保存</span></span><br><span class="line">  <span class="comment">//指定给一个事件类型增加的监听函数数量最多有多少个</span></span><br><span class="line">  <span class="built_in">this</span>._maxListeners = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span>(<span class="params">maxListeners</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._maxListeners = maxListeners;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.listeners = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.events[event];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给指定的事件绑定事件处理函数，1参数是事件类型 2参数是事件监听函数</span></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.events[type]</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type].push(listener);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>._maxListeners!=<span class="number">0</span>&amp;&amp;<span class="built_in">this</span>.events[type].length&gt;<span class="built_in">this</span>._maxListeners</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`MaxListenersExceededWarning: Possible EventEmitter memory leak detected. <span class="subst">$&#123;<span class="built_in">this</span>.events[type].length&#125;</span> <span class="subst">$&#123;type&#125;</span> listeners added. Use emitter.setMaxListeners() to increase limit`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果以前没有添加到此事件的监听函数，则赋一个数组</span></span><br><span class="line">    <span class="built_in">this</span>.events[type] = [listener];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//用完即焚</span></span><br><span class="line"> <span class="keyword">let</span>  wrapper = <span class="function">(<span class="params">...rest</span>)=&gt;</span>&#123;</span><br><span class="line">   listener.apply(<span class="built_in">this</span>);<span class="comment">//先让原始的监听函数执行</span></span><br><span class="line">   <span class="built_in">this</span>.removeListener(type,wrapper);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">this</span>.on(type,wrapper);</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params">type,listener</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.events[type]</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type] = <span class="built_in">this</span>.events[type].filter(<span class="function"><span class="params">l</span>=&gt;</span>l!=listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除某个事件的所有监听函数</span></span><br><span class="line">EventEmitter.prototype.removeAllListeners = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">this</span>.events[type];</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type,...rest</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.events[type]&amp;&amp;<span class="built_in">this</span>.events[type].forEach(<span class="function"><span class="params">listener</span>=&gt;</span>listener.apply(<span class="built_in">this</span>,rest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br></pre></td></tr></table></figure>

<h2 id="util"><a href="#util" class="headerlink" title="util"></a>util</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//util.inherit();</span></span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(&#123;<span class="attr">name</span>:<span class="string">&#x27;zfpx&#x27;</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(util.isArray([]));</span><br><span class="line"><span class="built_in">console</span>.log(util.isRegExp(<span class="regexp">/\d/</span>));</span><br><span class="line"><span class="built_in">console</span>.log(util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(util.isError(<span class="keyword">new</span> <span class="built_in">Error</span>));</span><br></pre></td></tr></table></figure>

<h2 id="node-断点调试"><a href="#node-断点调试" class="headerlink" title=". node 断点调试"></a>. node 断点调试</h2><p>V8 提供了一个强大的调试器，可以通过 TCP 协议从外部访问。Nodejs 提供了一个内建调试器来帮助开发者调试应用程序。想要开启调试器我们需要在代码中加入 debugger 标签，当 Nodejs 执行到 debugger 标签时会自动暂停（debugger 标签相当于在代码中开启一个断点）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> all = a + <span class="string">&#x27; &#x27;</span> + b;</span><br><span class="line"><span class="built_in">console</span>.log(all);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td align="left">继续执行到下一个断点处</td>
</tr>
<tr>
<td>next,n</td>
<td align="left">单步执行</td>
</tr>
<tr>
<td>step,s</td>
<td align="left">单步进入函数</td>
</tr>
<tr>
<td>out,o</td>
<td align="left">退出当前函数</td>
</tr>
<tr>
<td>setBreakpoint(10),sb(10)</td>
<td align="left">在第10行设置断点</td>
</tr>
<tr>
<td>repl</td>
<td align="left">打开求值环境，ctrl_c退回debug模式</td>
</tr>
<tr>
<td>watch(exp)</td>
<td align="left">把表达式添加监视列表</td>
</tr>
<tr>
<td>watchers</td>
<td align="left">显示所有表达式的值</td>
</tr>
</tbody></table>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端整理</category>
      </categories>
      <tags>
        <tag>nodeCore</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2022/07/09/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86/promise/</url>
    <content><![CDATA[<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，就是常说的回调地狱<br>如果几个异步操作之间并没有前后顺序之分,但需要等多个异步操作都完成后才能执行后续的任务，无法实现并行节约时间</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 本意是承诺，在程序中的意思就是承诺我 <strong>过一段时间后</strong>会给你一个结果。 什么时候会用到 <strong>过一段时间</strong>？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等</p>
<h2 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a>Promise 的三种状态</h2><ul>
<li>Pending Promise 对象实例创建时候的初始状态</li>
<li>Fulfilled 可以理解为成功的状态</li>
<li>Rejected 可以理解为失败的状态</li>
</ul>
<blockquote>
<p>then 方法就是用来指定 Promise 对象的状态改变时确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject 时执行第二个函数（onRejected）</p>
</blockquote>
<h2 id="构造一个-Promise"><a href="#构造一个-Promise" class="headerlink" title="构造一个 Promise"></a>构造一个 Promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) resolve(<span class="string">&quot;This is resolve!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> reject(<span class="string">&quot;This is reject!&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(Fulfilled, Rejected);</span><br></pre></td></tr></table></figure>

<ul>
<li>构造一个 Promise 实例需要给 Promise 构造函数传入一个函数。</li>
<li>传入的函数需要有两个形参，两个形参都是 function 类型的参数。<ul>
<li>第一个形参运行后会让 Promise 实例处于 resolve 状态，所以我们一般给第一个形参命名为 resolve,使 Promise 对象的状态改变成成功，同时传递一个参数用于后续成功后的操作</li>
<li>第一个形参运行后会让 Promise 实例处于 reject 状态，所以我们一般给第一个形参命名为 reject,将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(</span><br><span class="line">    (data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">this</span>.success(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="built_in">this</span>.error();</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.success(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.error(error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">success, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.success = success;</span><br><span class="line">  <span class="built_in">this</span>.error = error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    fn(</span><br><span class="line">      (data) =&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.success(data);</span><br><span class="line">      &#125;,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.error();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.success(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">reject</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">success, error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.success = success;</span><br><span class="line">    <span class="built_in">this</span>.error = error;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="promise-做为函数的返回值"><a href="#promise-做为函数的返回值" class="headerlink" title="promise 做为函数的返回值"></a>promise 做为函数的返回值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxPromise</span>(<span class="params">queryUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, queryUrl, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          resolve(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajaxPromise(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="promise-的链式调用"><a href="#promise-的链式调用" class="headerlink" title="promise 的链式调用"></a>promise 的链式调用</h2><ul>
<li>每次调用返回的都是一个新的 Promise 实例</li>
<li>链式调用的参数通过返回值传递</li>
</ul>
<p><code>then</code>可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 <code>Promise</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">&quot;1.txt&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> readFile(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="promise-API"><a href="#promise-API" class="headerlink" title="promise API"></a>promise API</h2><ul>
<li><strong>参数</strong>：接受一个数组，数组内都是 <code>Promise</code>实例</li>
<li><strong>返回值</strong>：返回一个 <code>Promise</code>实例，这个 <code>Promise</code>实例的状态转移取决于参数的 <code>Promise</code>实例的状态变化。当参数中所有的实例都处于 <code>resolve</code>状态时，返回的 <code>Promise</code>实例会变为 <code>resolve</code>状态。如果参数中任意一个实例处于 <code>reject</code>状态，返回的 <code>Promise</code>实例变为 <code>reject</code>状态。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不管两个 promise 谁先完成，Promise.all 方法会按照数组里面的顺序将结果返回</p>
</blockquote>
<ul>
<li><strong>参数</strong>：接受一个数组，数组内都是 <code>Promise</code>实例</li>
<li><strong>返回值</strong>：返回一个 <code>Promise</code>实例，这个 <code>Promise</code>实例的状态转移取决于参数的 <code>Promise</code>实例的状态变化。当参数中任何一个实例处于 <code>resolve</code>状态时，返回的 <code>Promise</code>实例会变为 <code>resolve</code>状态。如果参数中任意一个实例处于 <code>reject</code>状态，返回的 <code>Promise</code>实例变为 <code>reject</code>状态。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>7.3 Promise.resolve</strong>返回一个 <code>Promise</code>实例，这个实例处于 <code>resolve</code>状态。</p>
<p>根据传入的参数不同有不同的功能：</p>
<ul>
<li>值(对象、数组、字符串等)：作为 <code>resolve</code>传递出去的值</li>
<li><code>Promise</code>实例：原封不动返回</li>
</ul>
<p>返回一个 <code>Promise</code>实例，这个实例处于 <code>reject</code>状态。</p>
<ul>
<li>参数一般就是抛出的错误信息。</li>
</ul>
<h2 id="q"><a href="#q" class="headerlink" title="q"></a>q</h2><p>Q 是一个在 Javascript 中实现 promise 的模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&quot;q&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  fs.readFile(filename, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      deferred.reject(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deferred.resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">&quot;1.txt1&quot;</span>).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="function"><span class="title">defer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> _success, _error;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">resolve</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        _success(data);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">reject</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">        _error(err);</span><br><span class="line">      &#125;,</span><br><span class="line">      promise: &#123;</span><br><span class="line">        <span class="function"><span class="title">then</span>(<span class="params">success, error</span>)</span> &#123;</span><br><span class="line">          _success = success;</span><br><span class="line">          _error = error;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pending = [],</span><br><span class="line">    value;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    resolve: <span class="function"><span class="keyword">function</span> (<span class="params">_value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        value = _value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = pending.length; i &lt; ii; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> callback = pending[i];</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;</span><br><span class="line">        pending = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    promise: &#123;</span><br><span class="line">      then: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">          pending.push(callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="bluebird"><a href="#bluebird" class="headerlink" title="bluebird"></a>bluebird</h2><p>实现 promise 标准的库是功能最全，速度最快的一个库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">&quot;./bluebird&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">Promise</span>.promisify(<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).readFile);</span><br><span class="line">readFile(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">contents</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">Promise</span>.promisifyAll(<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>));</span><br><span class="line"></span><br><span class="line">fs.readFileAsync(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">contents</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="function"><span class="title">promisify</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fn.apply(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          args.concat(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              resolve(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">promisifyAll</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(attr) &amp;&amp; <span class="keyword">typeof</span> obj[attr] == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        obj[attr + <span class="string">&quot;Async&quot;</span>] = <span class="built_in">this</span>.promisify(obj[attr]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="co"><a href="#co" class="headerlink" title="co"></a>co</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> number = <span class="built_in">Math</span>.random();</span><br><span class="line">      <span class="keyword">if</span> (number &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        resolve(number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&quot;数字太小&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> getNumber();</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">let</span> c = <span class="keyword">yield</span> getNumber();</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> g = gen();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">lastValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; done, value &#125; = g.next(lastValue);</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        resolve(lastValue);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          value.then(next, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            reject(val);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">co(read).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="keyword">else</span> resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> readFile(<span class="string">&quot;./1.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> readFile(<span class="string">&quot;./2.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> g = gen();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; done, value &#125; = g.next(val);</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">      value.then(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-A-完整实现"><a href="#Promise-A-完整实现" class="headerlink" title="Promise/A+完整实现"></a>Promise/A+完整实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> item(value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> item(value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;循环引用&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> then, called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x == <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  onFulfilled =</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled == <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onFulfilled</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected == <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  <span class="keyword">if</span> (self.status == <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status == <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">          result[i] = data;</span><br><span class="line">          <span class="keyword">if</span> (++count == promises.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defer = &#123;&#125;;</span><br><span class="line">  defer.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    defer.resolve = resolve;</span><br><span class="line">    defer.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> defer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * npm i -g promises-aplus-tests</span></span><br><span class="line"><span class="comment"> * promises-aplus-tests Promise.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端整理</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>css面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>css面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>html面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/htm%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>html面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>http网落协议面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/http%E7%BD%91%E8%90%BD%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="请求在客户端报-413-是什么错误-怎么解决呢"><a href="#请求在客户端报-413-是什么错误-怎么解决呢" class="headerlink" title="请求在客户端报 413 是什么错误,怎么解决呢?"></a>请求在客户端报 413 是什么错误,怎么解决呢?</h2><ul>
<li>HTTP 413 错误(Request entity too large 请求实体太大)，就是客户端发送的实体主体部分比服务器能够或者希望处理的要大时，会出现这样的错误。一般上传文件时会出现这样的错误概率比较大。<br>解决方案可以修改服务器的配置文件。配置客户端请求大小和缓存大小</li>
</ul>
<h2 id="tcp-和-udp-的-区-别-和-使-用-场-景"><a href="#tcp-和-udp-的-区-别-和-使-用-场-景" class="headerlink" title="tcp 和 udp 的 区 别 和 使 用 场 景"></a>tcp 和 udp 的 区 别 和 使 用 场 景</h2><h2 id="quic-基-于-udp-怎-么-保-证-可-靠-性"><a href="#quic-基-于-udp-怎-么-保-证-可-靠-性" class="headerlink" title="quic 基 于 udp 怎 么 保 证 可 靠 性"></a>quic 基 于 udp 怎 么 保 证 可 靠 性</h2><h2 id="讲-一-下-同-源-策-略-和-跨-域-方-案-？-CORS-的-几-个-头-部-是-什-么-？"><a href="#讲-一-下-同-源-策-略-和-跨-域-方-案-？-CORS-的-几-个-头-部-是-什-么-？" class="headerlink" title="讲 一 下 同 源 策 略 和 跨 域 方 案 ？ CORS 的 几 个 头 部 是 什 么 ？"></a>讲 一 下 同 源 策 略 和 跨 域 方 案 ？ CORS 的 几 个 头 部 是 什 么 ？</h2><h2 id="grpc-相-比-http-的-优-势-？"><a href="#grpc-相-比-http-的-优-势-？" class="headerlink" title="grpc 相 比 http 的 优 势 ？"></a>grpc 相 比 http 的 优 势 ？</h2><h2 id="http-组成部分"><a href="#http-组成部分" class="headerlink" title="http 组成部分"></a>http 组成部分</h2><ul>
<li>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的 HTTP 版本.</li>
<li>第二部分：请求头部，用来说明服务器要使用的附加信息</li>
<li>第三部分：空行，请求头部后面的空行是必须的</li>
<li>第四部分：请求数据也叫主体，可以添加任意的其他数据。</li>
<li>HTTP 协议主要用于 Web 浏览器和 Web 服务器之间的数据交换。HTTP 是超文本协议，默认端口是 80，以明文方式传输。<br>特点：支持客户/服务器模式，由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快，HTTP 允许传输任意类型的数据对象</li>
</ul>
<h2 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手 四次挥手"></a>三次握手 四次挥手</h2><ul>
<li><p>第一次握手：建立连接时，客户端向服务器发送 SYN 包，并进入 SYN-send（发送中）状态，等待服务器确认。</p>
</li>
<li><p>第二次握手：服务器收到 SYN 包，必须确认后，同时也发送一个 SYN ＋ ACK 包给客户端，此时服务器进入 SYN_recv(收到)状态。</p>
</li>
<li><p>第三次握手：客户端收到服务器的 SYN ＋ ACK 包，向服务器发送 ACK 确认包，此包发送完毕，客户端和服务器进入 established 状态，完成三次握手。</p>
</li>
<li><p>完成三次握手，客户端与服务器开始传送数据。</p>
</li>
<li><p>客户端发送一个 FIN，用来关闭客户端到服务器的数据传送。</p>
</li>
<li><p>服务器收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1</p>
</li>
<li><p>服务器关闭与客户端的连接，发送一个 FIN 给客户端。</p>
</li>
<li><p>客户端发回 ACK 报文确认，并将确认序号设置为收到 序号加 1。完成四次挥手</p>
</li>
</ul>
<h2 id="HTTPS-和-HTTP-的区别主要如下"><a href="#HTTPS-和-HTTP-的区别主要如下" class="headerlink" title="HTTPS 和 HTTP 的区别主要如下"></a>HTTPS 和 HTTP 的区别主要如下</h2><ul>
<li>https 协议需要有 ca 申请证书</li>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</li>
</ul>
<h2 id="ht-tp2-的-相-关-特-性-？"><a href="#ht-tp2-的-相-关-特-性-？" class="headerlink" title="ht tp2 的 相 关 特 性 ？"></a>ht tp2 的 相 关 特 性 ？</h2><h2 id><a href="#" class="headerlink" title></a></h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>http网落协议面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>js面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="操作符的强制类型转换规则"><a href="#操作符的强制类型转换规则" class="headerlink" title="== 操作符的强制类型转换规则"></a>== 操作符的强制类型转换规则</h2><ul>
<li>字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较</li>
<li>其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较</li>
<li>null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</li>
<li>对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较</li>
<li>如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）</li>
<li>如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</li>
</ul>
<h2 id="、Object-is-、Set-去重的区别"><a href="#、Object-is-、Set-去重的区别" class="headerlink" title="===、Object.is()、Set 去重的区别"></a>===、Object.is()、Set 去重的区别</h2><ul>
<li>这几个的差异是在-0 与+0；NaN 上</li>
<li>=== -0 与+0 是相等的 NaN 与 NaN 是不相等的</li>
<li>Object.is() 与===相反，-0 与+0 是不相等的，NaN 与 NaN 是相等的</li>
<li>Set 认为两组都是相等的</li>
<li>includes 和 Set 相同</li>
</ul>
<h2 id="Array-indexOf-和-includes-的区别"><a href="#Array-indexOf-和-includes-的区别" class="headerlink" title="Array indexOf 和 includes 的区别"></a>Array indexOf 和 includes 的区别</h2><ul>
<li>返回值不同<ul>
<li>indexOf 返回数值类型，表示当前第一个匹配到的数组索引</li>
<li>includes 返回布尔类型，判断是否在数组中存在这个值</li>
</ul>
</li>
<li>比较算法的差异<ul>
<li>indexOf 使用严格相等(===)来比较是否相等</li>
<li>includes 使用 sameValueZero 算法来比较是否相同(SameValueZero，自 ES2016 开始，用于 ArrayBuffer 构造函数，以及 Map 和 Set 操作以及 includes 方法)</li>
</ul>
</li>
</ul>
<h2 id="this-指向-当前方法执行的主体-谁执行的这个方法-那么-THIS-就是谁-所以-THIS-和当前方法在哪创建的或者在哪执行的都没有必然的关系"><a href="#this-指向-当前方法执行的主体-谁执行的这个方法-那么-THIS-就是谁-所以-THIS-和当前方法在哪创建的或者在哪执行的都没有必然的关系" class="headerlink" title="this 指向 当前方法执行的主体(谁执行的这个方法,那么 THIS 就是谁,所以 THIS 和当前方法在哪创建的或者在哪执行的都没有必然的关系)"></a>this 指向 当前方法执行的主体(谁执行的这个方法,那么 THIS 就是谁,所以 THIS 和当前方法在哪创建的或者在哪执行的都没有必然的关系)</h2><ul>
<li>给元素的某个事件绑定方法，方法中的 THIS 都是当前操作的元素本身</li>
<li>函数执行，看函数前面是否有点，有的话，点前面是谁 THIS 就是谁，没有点，THIS 是 WINDOW（在 JS 的严格模式下，没有点 THIS 是 UNDEFINED）</li>
<li>构造函数执行，方法中的 this 一般都是当前类的实例</li>
<li>箭头函数中没有自己的 THIS,THIS 是上下文中的 THIS</li>
<li>在小括号表达式中，会影响 THIS 的指向</li>
<li>使用 call/apply/bind 可以改变 this 指向<a id="more"></a>

</li>
</ul>
<h2 id="case-语句是使用恒等（-）来判断的"><a href="#case-语句是使用恒等（-）来判断的" class="headerlink" title="case 语句是使用恒等（===）来判断的"></a>case 语句是使用恒等（===）来判断的</h2><h2 id="正则-test-方法的参数如果不是字符串，会经过抽象-ToString-操作强制转成字符串"><a href="#正则-test-方法的参数如果不是字符串，会经过抽象-ToString-操作强制转成字符串" class="headerlink" title="正则 test 方法的参数如果不是字符串，会经过抽象 ToString 操作强制转成字符串"></a>正则 test 方法的参数如果不是字符串，会经过抽象 ToString 操作强制转成字符串</h2><h2 id="JSON-stringify-拷贝时-obj-的缺陷"><a href="#JSON-stringify-拷贝时-obj-的缺陷" class="headerlink" title="JSON.stringify 拷贝时 obj 的缺陷"></a>JSON.stringify 拷贝时 obj 的缺陷</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/json.stringify.png" alt="JSON.stringify"></p>
<ul>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失</li>
<li>拷贝 Date 引用类型会变成字符串</li>
<li>无法拷贝不可枚举的属性</li>
<li>无法拷贝对象的原型链</li>
<li>拷贝正则会变成空对象</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null</li>
<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)</li>
</ul>
<h2 id="js-常见的-6-中继承方式"><a href="#js-常见的-6-中继承方式" class="headerlink" title="js 常见的 6 中继承方式"></a>js 常见的 6 中继承方式</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%A7%E6%89%BF.png" alt="JavaScript继承"></p>
<ul>
<li><p>原型链继承<br>介绍：子类的原型指向父类构造的实例<br>缺点： 原型属性共享问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;child2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child1.prototype = <span class="keyword">new</span> Parent1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1());</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2();</span><br><span class="line">s1.play.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.play, s2.play);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数继承<br>缺点：只能继承父类的实例属性和方法，不能继承原型属性或者方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent1.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;child1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="built_in">console</span>.log(child); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// Child1 &#123; name: &#x27;parent1&#x27;, type: &#x27;child1&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.getName()); <span class="comment">// 会报错 child.getName is not a function</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组合继承<br>缺点：父类函数会多次执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;parent3&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第二次调用 Parent3()</span></span><br><span class="line">  Parent3.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;child3&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次调用 Parent3()</span></span><br><span class="line"></span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br><span class="line"></span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> Child3();</span><br><span class="line"></span><br><span class="line">s3.play.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s3.play, s4.play); <span class="comment">// 不互相影响</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s3.getName()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s4.getName()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原型式继承<br>缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parent4 = &#123;</span><br><span class="line">  name: <span class="string">&quot;parent4&quot;</span>,</span><br><span class="line"></span><br><span class="line">  friends: [<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line"></span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person4 = <span class="built_in">Object</span>.create(parent4);</span><br><span class="line"></span><br><span class="line">person4.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">person4.friends.push(<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person5 = <span class="built_in">Object</span>.create(parent4);</span><br><span class="line"></span><br><span class="line">person5.friends.push(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person4.name);</span><br><span class="line"><span class="comment">// tom</span></span><br><span class="line"><span class="built_in">console</span>.log(person4.name === person4.getName());</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.name);</span><br><span class="line"><span class="comment">// parent4</span></span><br><span class="line"><span class="built_in">console</span>.log(person4.friends);</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.friends);</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生式继承</p>
</li>
<li><p>寄生组合继承<br>寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">    child.prototype = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;parent6&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent6.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent6.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.friends = <span class="string">&quot;child5&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line">Child6.prototype.getFriends = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.friends;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person6 = <span class="keyword">new</span> Child6();</span><br><span class="line"><span class="built_in">console</span>.log(person6);</span><br><span class="line"><span class="built_in">console</span>.log(person6.getName());</span><br><span class="line"><span class="built_in">console</span>.log(person6.getFriends());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="js-原型链"><a href="#js-原型链" class="headerlink" title="js 原型链"></a>js 原型链</h2><p><img src="/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="js原型链"></p>
<ul>
<li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code> 该属性指向原型。该属性的值是一个堆内存，堆内存中默认自带一个属性<code>constructor</code>,值是函数本身。</li>
<li>每个对象都有 <code>__proto__</code>属性，指向了创建该对象的构造函数的原型。</li>
<li>对象可以通过 <code>__proto__</code>来寻找不属于该对象的属性， <code>__proto__</code> 将对象连接起来组成了原型链。</li>
</ul>
<h2 id="定时器为什么不是精确的"><a href="#定时器为什么不是精确的" class="headerlink" title="定时器为什么不是精确的"></a>定时器为什么不是精确的</h2><h2 id="JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？"><a href="#JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？" class="headerlink" title="JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？"></a>JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</h2><ul>
<li>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条</li>
<li>offsetHeight：表示可视区域的高度，包含了 border 和滚动条</li>
<li>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分</li>
<li>clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</li>
<li>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</li>
</ul>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别?"></a>箭头函数和普通函数的区别?</h2><ul>
<li><p>箭头函数没有自己的 this，只能通过作用域链来向上查找离自己最近的那个函数的 this</p>
</li>
<li><p>箭头函数不能作为 constructor，因此不能通过 new 来调用，所以它并没用 new.target 这个属性</p>
</li>
<li><p>箭头函数没有 argument 属性，可以通过 rest 可以获取</p>
</li>
<li><p>箭头函数不能直接使用 call 和 apply，bind 来改变 this</p>
</li>
<li><p>箭头函数不能使用 yield，不能作为 generator 函数</p>
</li>
<li><p>箭头函数语法比普通函数更加简洁</p>
</li>
<li><p>ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数或构造方法。如果构造函数不是通过 new 命令或 Reflect.construct()调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数时怎样调用的。包括 super 也不存在以及原型 prototype —- 因为在执行 new 的时候需要将函数的原型赋值给实力对象的原型属性。</p>
</li>
</ul>
<h2 id="TypeScript-里面有哪些-JavaScript-没有的类型"><a href="#TypeScript-里面有哪些-JavaScript-没有的类型" class="headerlink" title="TypeScript 里面有哪些 JavaScript 没有的类型?"></a>TypeScript 里面有哪些 JavaScript 没有的类型?</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">相比较JavaScript，TypeScript独有的类型</span><br><span class="line">any</span><br><span class="line">声明为any的变量可以赋予任意类型的值</span><br><span class="line"></span><br><span class="line">tuple</span><br><span class="line">元组类型用来表示已知元素数量和类型的数组，个元素的类型不必相同，对应位置的类型需要一样</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line">x = [‘string’, <span class="number">0</span>]; <span class="comment">// 正常</span></span><br><span class="line">x = [<span class="number">0</span>, ‘string’]; <span class="comment">// 报错</span></span><br><span class="line">enum</span><br><span class="line">枚举类型用于定义值集合</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="built_in">console</span>.log©; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">void</span> 标识方法返回值的类型，表示方法没有返回值。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br><span class="line">never</span><br><span class="line">never是其它类型(包括<span class="literal">null</span>和<span class="literal">undefined</span>)的子类型，是不会发生的类型。例如，never总是抛出异常或永不返回的异常的函数表达式的返回类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 never 的函数终点不可达</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回类型是 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> error(‘Something failed’);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 never 的函数终点不可达</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">unknown 未知类型，一般在使用后再手动转具体的类型</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line"></span><br><span class="line">联合类型，多种类型之一</span><br><span class="line"></span><br><span class="line">string | number; <span class="comment">// string 或 number</span></span><br><span class="line">intersection</span><br><span class="line">交叉类型，多种类型合并</span><br><span class="line"></span><br><span class="line">&#123; <span class="attr">a</span>: string; &#125; &amp; &#123; <span class="attr">b</span>: number; &#125; <span class="comment">// =&gt; &#123; a: string; b: number &#125;</span></span><br><span class="line">Generics</span><br><span class="line">泛型</span><br><span class="line"></span><br><span class="line">interface Backpack &#123;</span><br><span class="line">add: <span class="function">(<span class="params">obj: T</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">get: <span class="function">() =&gt;</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对-URL-进行编码-解码的实现方式"><a href="#对-URL-进行编码-解码的实现方式" class="headerlink" title="对 URL 进行编码/解码的实现方式"></a>对 URL 进行编码/解码的实现方式</h2><ul>
<li>：escape 和 unescape:<br>escape()不能直接用于 URL 编码，它的真正作用是返回一个字符的 Unicode 编码值<br>除了 ASCII 字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码。在 u0000 到 u00ff 之间的符号被转成%xx 的形式，其余符号被转成%uxxxx 的形式。对应的解码函数是 unescape()。</li>
<li>：encodeURL 和 decodeURL：<br>encodeURI()是 Javascript 中真正用来对 URL 编码的函数。<br>它用于对 URL 的组成部分进行个别编码，除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的 utf-8 形式，并且在每个字节前加上%。<br>它对应的解码函数是 decodeURI()</li>
<li>：encodeURLComponent 和 decodeURLComponent:<br>与 encodeURI()的区别是，它用于对整个 URL 进行编码。”; / ? : @ &amp; = + $ , #”，这些在 encodeURI()中不被编码的符号，在 encodeURIComponent()中统统会被编码。<br>它对应的解码函数是 decodeURIComponent()</li>
</ul>
<h2 id="严格模式-与非严格模式区别"><a href="#严格模式-与非严格模式区别" class="headerlink" title="严格模式 与非严格模式区别"></a>严格模式 与非严格模式区别</h2><ul>
<li>禁用 with 语法，使用将报错</li>
<li>禁止用 delete 删除显示声明的标识符 变量和函数 eval arguments</li>
<li>给不允许扩展的 object 增加属性会报错</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line">obj.b = <span class="number">2</span>; <span class="comment">// 严格模式下会报错;非严格模式不会报错，但也不会生效 &#x27;b&#x27; in obj 为false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>给未申明的变量赋值会报错</li>
<li>函数形参重复时会报错</li>
<li>对象字面量不能存在相同的属性名</li>
<li>不能声明或重写 eval 和 arguments 这两个标识</li>
<li>禁止用 0 前缀声明的八进制字面量</li>
<li>在代码中使用一些扩展的保留字</li>
<li>禁用 caller 与 callee</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller, fn.caller); <span class="comment">// 严格模式下报错；非严格模式指向fn2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee); <span class="comment">// 严格模式报错；非严格模式指向fn</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>

<h2 id="ES6-super-指向问题"><a href="#ES6-super-指向问题" class="headerlink" title="ES6 super 指向问题"></a>ES6 super 指向问题</h2><ul>
<li>在类的构造方法中 super()，super 指向父类的构造器，this 指向 new 创建的实例</li>
<li>在普通的原型方法，和构造函数中作为对象使用 super.xxx, super 指向父类原型对象；this 指向新创建的实例</li>
<li>静态方法中 super.xxx，super 指向父类， this 指向当前类；</li>
</ul>
<h2 id="JSON-stringify-使用注意事项"><a href="#JSON-stringify-使用注意事项" class="headerlink" title="JSON.stringify 使用注意事项"></a>JSON.stringify 使用注意事项</h2><ul>
<li>转换属性值中有 toJSON 方法，慎用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toJSON</span></span><br><span class="line"><span class="keyword">let</span> toJsonMyIntro = &#123;</span><br><span class="line">  name: <span class="string">&quot;Gopal&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  like: <span class="string">&quot;FE&quot;</span>,</span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;前端&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(toJsonMyIntro)); <span class="comment">// &quot;前端&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>被转换值中有 undefined、任意的函数以及 symbol 值，慎用</p>
<p>1 一种是数组对象，undefined、任意的函数以及 symbol 值会被转换成 null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">undefined</span>, <span class="built_in">Object</span>, <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>)]);</span><br><span class="line"><span class="comment">// &#x27;[null,null,null]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2 一种是非数组对象，在序列化的过程中会被忽略</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="built_in">Object</span>, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>) &#125;);</span><br><span class="line"><span class="comment">// &#x27;&#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>包含循环引用的对象，慎用</p>
</li>
<li><p>以 symbol 为属性键的属性，慎用,所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。</p>
</li>
<li><p>值为 NaN 和 Infinity，慎用 数组的值，或者非数组对象属性值为 NaN 和 Infinity 的，会被转换成 null</p>
</li>
<li><p>具有不可枚举的属性值时，慎用 不可枚举的属性默认会被忽略：</p>
</li>
</ul>
<h2 id="Object-keys-的顺序问题及参数解析"><a href="#Object-keys-的顺序问题及参数解析" class="headerlink" title="Object.keys()的顺序问题及参数解析"></a>Object.keys()的顺序问题及参数解析</h2><ul>
<li>如果属性名的类型是 Number(整数) 或者是 String(整数)，那么 Object.keys 返回值是按照 key 从小到大排序</li>
<li>如果属性名的类型是 String，浮点数，那么 Object.keys 返回值是按照属性被创建的时间升序排序。</li>
<li>如果属性名的类型是 Symbol，那么逻辑同 String 相同</li>
</ul>
<h2 id="axios-与-fetch-的区别"><a href="#axios-与-fetch-的区别" class="headerlink" title="axios 与 fetch 的区别"></a>axios 与 fetch 的区别</h2><p>Axios:</p>
<ol>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>支持 Promise API</li>
<li>客户端支持防止 CSRF</li>
<li>提供了一些并发请求的接口（重要，方便了很多的操作）</li>
</ol>
<p>Fetch</p>
<ol>
<li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>
<li>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li>
<li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li>
<li>fetch 没有办法原生监测请求的进度，而 XHR 可以</li>
</ol>
<h2 id="函数提升和变量提升优先级哪个高"><a href="#函数提升和变量提升优先级哪个高" class="headerlink" title="函数提升和变量提升优先级哪个高"></a>函数提升和变量提升优先级哪个高</h2><ul>
<li>函数提升，函数提升优先级高于变量提升</li>
<li>变量提升，变量提升不会覆盖（同名）函数提升，只有变量再次赋值时，才会被覆盖</li>
</ul>
<h2 id="ES6-中共有五种针对对象遍历的方法"><a href="#ES6-中共有五种针对对象遍历的方法" class="headerlink" title="ES6 中共有五种针对对象遍历的方法"></a>ES6 中共有五种针对对象遍历的方法</h2><ul>
<li>for in<br>for in 循环遍历对象自身的和继承的可枚举的属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)<br>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）</li>
<li>Object.getOwnPropertyNames(obj)<br>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但包括不可枚举属性）</li>
<li>Object.getOwnPropertySymbols(obj)<br>返回一个数组，包含对象自身所有的 Symbol 属性</li>
<li>Reflect.ownKeys(obj)<br>返回一个数组，包含对象自身的所有属性，不论属性名是 Symbol 或字符串，也不管是否可枚举。</li>
</ul>
<h2 id="缓存的理解"><a href="#缓存的理解" class="headerlink" title="缓存的理解"></a>缓存的理解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">缓存分为强缓存和协商缓存。</span><br><span class="line">  强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。</span><br><span class="line">强缓存:</span><br><span class="line">Expires</span><br><span class="line">cache-control</span><br><span class="line">协商缓存:</span><br><span class="line">Last-Modified 和 If-Modified-Since    http1.0</span><br><span class="line">Etag 和 If-None-Match    http1.1</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>js面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>node面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/node%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="npm-run-xxx-的过程"><a href="#npm-run-xxx-的过程" class="headerlink" title="npm run xxx 的过程"></a>npm run xxx 的过程</h2><ul>
<li>运行 npm run XXX</li>
<li>npm 先在当前目录 的 node_modules/.bin 查找要执行的程序，如果找到则运行；没有找到 则从全局的 node_modules/.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li>
<li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li>
<li><a href="https://blog.csdn.net/qq_31967985/article/details/124367380?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1-124367380-blog-125222803.pc_relevant_multi_platform_whitelistv2_exp180w&spm=1001.2101.3001.4242.2&utm_relevant_index=4">npm install 到npm run xxx深度解读</a></li>
</ul>
<a id="more"></a>
<h2 id="bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？"><a href="#bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？" class="headerlink" title=".bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？"></a>.bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？</h2><ul>
<li>它存在项目最外层的package-lock.json文件中<br>从 package-lock.json 中可知，当我们npm i 整个新建的vue项目的时候，npm 将 bin/vue-cli-service.js 作为 bin 声明了。<br>所以在 npm install 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了</li>
</ul>
<h2 id="package-json-与-package-lock-json-的关系"><a href="#package-json-与-package-lock-json-的关系" class="headerlink" title="package.json 与 package-lock.json 的关系"></a>package.json 与 package-lock.json 的关系</h2><p> <a href="https://www.cnblogs.com/yalong/p/15013880.html">package.json 与 package-lock.json 的关系</a></p>
<h2 id="master挂了了的话pm2怎么处理理"><a href="#master挂了了的话pm2怎么处理理" class="headerlink" title="master挂了了的话pm2怎么处理理"></a>master挂了了的话pm2怎么处理理</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>node面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>react面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/react%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="state-如何注入组件，从-redux-到组件经历的过程"><a href="#state-如何注入组件，从-redux-到组件经历的过程" class="headerlink" title="state 如何注入组件，从 redux 到组件经历的过程"></a>state 如何注入组件，从 redux 到组件经历的过程</h2><h2 id="react-最新的生命周期"><a href="#react-最新的生命周期" class="headerlink" title="react 最新的生命周期"></a>react 最新的生命周期</h2><p>React 16 之后有三个⽣命周期被废弃(但并未删除)</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate<br>计划在 17 版本完全删除这三个函数，只保留 UNSAVE_前缀的三个函数，⽬的是为了向下兼容，但是对于开发者⽽⾔应该尽量避免使⽤他们，⽽是使⽤新增的⽣命周期函数替代它们</li>
</ul>
<p>最新的⽣命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p>
<ul>
<li>挂载阶段<ul>
<li>constructor: 构造函数，最先被执⾏,我们通常在构造函数⾥初始化 state 对象或者给⾃定义⽅法绑定 this</li>
<li>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState) ,这是个静态⽅法,当我们接收到新的属性想去修改我们 state，可以使⽤ getDerivedStateFromProps</li>
<li>render: render 函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等内容</li>
<li>componentDidMount: 组件装载之后调⽤，此时我们可以获取到 DOM 节点并操作，⽐如对 canvas，svg 的操作，服务器请求，订阅都可以写在这个⾥⾯，但是记得在 componentWillUnmount 中取消订阅</li>
</ul>
</li>
<li>更新阶段<ul>
<li>getDerivedStateFromProps: 此⽅法在更新个挂载阶段都可能会调⽤</li>
<li>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState) ,有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回⼀个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利⽤此⽣命周期来优化 React 程序性能</li>
<li>render: 更新阶段也会触发此⽣命周期</li>
<li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState) , 这 个 ⽅ 法 在 render 之 后 ，componentDidUpdate 之前调⽤，有两个参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有⼀个返回值，会作为第三个参数传给 componentDidUpdate，如果你不想要返回值，可以返回 null，此⽣命周期必须与 componentDidUpdate 搭配使⽤</li>
<li>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot) ,该⽅法在 getSnapshotBeforeUpdate ⽅法之后被调⽤，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的,如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统⼀触发回调或更新状态。</li>
</ul>
</li>
<li>卸载阶段</li>
</ul>
<h2 id="setState-是同步还是异步"><a href="#setState-是同步还是异步" class="headerlink" title="setState 是同步还是异步"></a>setState 是同步还是异步</h2><h2 id="react-组件的通信"><a href="#react-组件的通信" class="headerlink" title="react 组件的通信"></a>react 组件的通信</h2><h2 id="react-优化手段"><a href="#react-优化手段" class="headerlink" title="react 优化手段"></a>react 优化手段</h2><h2 id="讲-一-下-react-fiber？"><a href="#讲-一-下-react-fiber？" class="headerlink" title="讲 一 下 react fiber？"></a>讲 一 下 react fiber？</h2><h2 id="redux-和-mobx-的-区-别-和-使-用-场-景"><a href="#redux-和-mobx-的-区-别-和-使-用-场-景" class="headerlink" title="redux 和 mobx 的 区 别 和 使 用 场 景"></a>redux 和 mobx 的 区 别 和 使 用 场 景</h2><h2 id="常-用-的-react-hooks-方-法"><a href="#常-用-的-react-hooks-方-法" class="headerlink" title="常 用 的 react hooks 方 法"></a>常 用 的 react hooks 方 法</h2><h2 id="useState-怎-么-做-缓-存-的"><a href="#useState-怎-么-做-缓-存-的" class="headerlink" title="useState 怎 么 做 缓 存 的"></a>useState 怎 么 做 缓 存 的</h2><h2 id="reac-t-s-s-r-是-在-什-么-场-景-下-做-的-？"><a href="#reac-t-s-s-r-是-在-什-么-场-景-下-做-的-？" class="headerlink" title="reac t s s r 是 在 什 么 场 景 下 做 的 ？"></a>reac t s s r 是 在 什 么 场 景 下 做 的 ？</h2><h2 id="reac-t-s-s-r-双-端-怎-么-做-构-建-的-？-区-别-在-哪-里-？"><a href="#reac-t-s-s-r-双-端-怎-么-做-构-建-的-？-区-别-在-哪-里-？" class="headerlink" title="reac t s s r 双 端 怎 么 做 构 建 的 ？ 区 别 在 哪 里 ？"></a>reac t s s r 双 端 怎 么 做 构 建 的 ？ 区 别 在 哪 里 ？</h2><h2 id="rende-r-和-rende-rToSt-r-ing-的-底-层-实-现-上-的-区-别-？"><a href="#rende-r-和-rende-rToSt-r-ing-的-底-层-实-现-上-的-区-别-？" class="headerlink" title="rende r 和 rende rToSt r ing 的 底 层 实 现 上 的 区 别 ？"></a>rende r 和 rende rToSt r ing 的 底 层 实 现 上 的 区 别 ？</h2><h2 id="reac-t-s-s-r-和-ej-s-性-能-的-差-异-？"><a href="#reac-t-s-s-r-和-ej-s-性-能-的-差-异-？" class="headerlink" title="reac t s s r 和 ej s 性 能 的 差 异 ？"></a>reac t s s r 和 ej s 性 能 的 差 异 ？</h2><h2 id><a href="#" class="headerlink" title></a></h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>react面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="vue-mixin"><a href="#vue-mixin" class="headerlink" title="vue mixin"></a>vue mixin</h2><ul>
<li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li>
<li>数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先</li>
<li>值为对象的选项，例如 methods、components，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对</li>
</ul>
<h2 id="路由钩子函数有三种："><a href="#路由钩子函数有三种：" class="headerlink" title="路由钩子函数有三种："></a>路由钩子函数有三种：</h2><ul>
<li>全局钩子： beforeEach、 afterEach</li>
<li>单个路由里面的钩子： beforeEnter、 beforeLeave</li>
<li>组件钩子：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave</li>
</ul>
<h2 id="react-vue-中的-key-的作用-内部原理是什么"><a href="#react-vue-中的-key-的作用-内部原理是什么" class="headerlink" title="react/vue 中的 key 的作用/内部原理是什么"></a>react/vue 中的 key 的作用/内部原理是什么</h2><ol>
<li>虚拟 DOM 的 key 的作用?<ol>
<li>简单说: key 是虚拟 DOM 对象的标识, 在更新显示时 key 起着极其重要的作用</li>
<li>详细说: 当列表数组中的数据发生变化生成新的虚拟 DOM 后, React 进行新旧虚拟 DOM 的 diff 比较<ul>
<li>key 没有变<br>item 数据没变, 直接使用原来的真实 DOM<br>item 数据变了, 对原来的真实 DOM 进行数据更新</li>
<li>key 变了<br>销毁原来的真实 DOM, 根据 item 数据创建新的真实 DOM 显示(即使 item 数据没有变)</li>
</ul>
</li>
</ol>
</li>
<li>key 为 index 的问题<ol>
<li>添加/删除/排序 =&gt; 产生没有必要的真实 DOM 更新 ==&gt; 界面效果没问题, 但效率低</li>
<li>如果 item 界面还有输入框 =&gt; 产生错误的真实 DOM 更新 ==&gt; 界面有问题<br>注意: 如果不存在添加/删除/排序操作, 用 index 没有问题</li>
</ol>
</li>
<li>解决:<br>使用 item 数据的标识数据作为 key, 比如 id 属性值</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>vue面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="有-没-有-做-过-优-化-相-关-的-？-webpack-做-了-哪-些-优-化"><a href="#有-没-有-做-过-优-化-相-关-的-？-webpack-做-了-哪-些-优-化" class="headerlink" title="有 没 有 做 过 优 化 相 关 的 ？ webpack 做 了 哪 些 优 化"></a>有 没 有 做 过 优 化 相 关 的 ？ webpack 做 了 哪 些 优 化</h2><h2 id="cache-loader-和-hard-source-webpack-plugin-的-区-别是-什-么-？"><a href="#cache-loader-和-hard-source-webpack-plugin-的-区-别是-什-么-？" class="headerlink" title="cache-loader 和 hard-source-webpack-plugin 的 区 别是 什 么 ？"></a>cache-loader 和 hard-source-webpack-plugin 的 区 别是 什 么 ？</h2><h2 id="Babel-profill：怎么把-es6-转化为-es5，兼容-ie"><a href="#Babel-profill：怎么把-es6-转化为-es5，兼容-ie" class="headerlink" title="Babel-profill：怎么把 es6 转化为 es5，兼容 ie"></a>Babel-profill：怎么把 es6 转化为 es5，兼容 ie</h2><ul>
<li><p>Parser 解析<br>第一步主要是将 ES6 语法解析为 AST 抽象语法树。</p>
</li>
<li><p>Transformer 转换<br>第二步是将打散的 AST 语法通过配置好的 plugins 和 presets 转换成新的 AST 语法。这一步主要是由 babel-transform 插件完成。plugins 和 presets 通常在 .babelrc 文件中配置。</p>
</li>
<li><p>Generator 生成<br>第三步是将新的 AST 语法树对象再生成浏览器都可以识别的 ES5 语法。这一步主要是由 babel-generator 插件完成</p>
<p>我们写的原始代码、<br>1.–&gt;parse(解析)阶段，通过–&gt;babylon 工具做代码的解析转换为–&gt;AST(抽象语法树)<br>2.–&gt;transform(改变)阶段，<br>通过—&gt;babel-traverse 工具，把代码转为 es5 或 es3，如果 babel 没有达到我们的预期 babel 还提供了很多插件可以继续转换到–&gt;AST 阶段<br>3.AST(抽象语法树)阶段–&gt;<br>通过 plugin 工具处理过滤代码(删除代码、增加代码)，在 AST 语法树上改，改完之后到—&gt;AST 这个树上，到—&gt;generator 阶段，<br>4.—&gt;generator(生成、生产)阶段<br>通过—&gt;babel-generator 工具处理还原代码，变成浏览器所识别的文本到—&gt;code,我们看到的最后编译后的代码</p>
</li>
</ul>
<h2 id="webpack-plugin-的-原-理-是-什-么-？"><a href="#webpack-plugin-的-原-理-是-什-么-？" class="headerlink" title="webpack plugin 的 原 理 是 什 么 ？"></a>webpack plugin 的 原 理 是 什 么 ？</h2><h2 id="plugin-中-有-异-步-请-求-会-阻-塞-后-面-的-plugin-吗-？"><a href="#plugin-中-有-异-步-请-求-会-阻-塞-后-面-的-plugin-吗-？" class="headerlink" title="plugin 中 有 异 步 请 求 会 阻 塞 后 面 的 plugin 吗 ？"></a>plugin 中 有 异 步 请 求 会 阻 塞 后 面 的 plugin 吗 ？</h2><h2 id="webpack-的-性-能-优-化-？"><a href="#webpack-的-性-能-优-化-？" class="headerlink" title="webpack 的 性 能 优 化 ？"></a>webpack 的 性 能 优 化 ？</h2><h2 id="hard-sour-c-e-webpack-plugin-是-怎-么-做-缓-存-的-？-修-改-文-件-后-会怎-么-样-？"><a href="#hard-sour-c-e-webpack-plugin-是-怎-么-做-缓-存-的-？-修-改-文-件-后-会怎-么-样-？" class="headerlink" title="hard-sour c e-webpack-plugin 是 怎 么 做 缓 存 的 ？ 修 改 文 件 后 会怎 么 样 ？"></a>hard-sour c e-webpack-plugin 是 怎 么 做 缓 存 的 ？ 修 改 文 件 后 会怎 么 样 ？</h2><h2 id="parallel-的-原-理-是-什-么-？-多-个-子-进-程-怎-么-通-信-？"><a href="#parallel-的-原-理-是-什-么-？-多-个-子-进-程-怎-么-通-信-？" class="headerlink" title="parallel 的 原 理 是 什 么 ？ 多 个 子 进 程 怎 么 通 信 ？"></a>parallel 的 原 理 是 什 么 ？ 多 个 子 进 程 怎 么 通 信 ？</h2><h2 id="webpack-与-gulp-grunt"><a href="#webpack-与-gulp-grunt" class="headerlink" title="webpack 与 gulp/grunt"></a>webpack 与 gulp/grunt</h2><ul>
<li>webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案。</li>
<li>Grunt/Gulp 是非模块化打包工具, 是工具链，可以配合各种插件做 js 压缩，css 压缩，less 编译 替代手工实现自动化工作</li>
</ul>
<h2 id="webpack-的核心概念"><a href="#webpack-的核心概念" class="headerlink" title="webpack 的核心概念"></a>webpack 的核心概念</h2><ul>
<li>Entry：入口，Webpack 进行打包的起始点(文件)</li>
<li>Output：出口，webpack 编译打包生成的 bundle(文件)</li>
<li>Loader：模块加载(转换)器，将非 js 模块包装成 webpack 能理解的 js 模块</li>
<li>Plugin：插件，在 Webpack 构建流程中的特定时机插入具有特定功能的代码</li>
<li>Module：模块，在 Webpack 眼里一切皆模块，默认只识别 js 文件, 如果是其它类型文件利用对应的 loader 转换为 js 模块</li>
<li>Chunk/bundle：代码块/束，一个 Chunk 由多个模块组合而成, 最终浏览器执行的是 webpack 打包生成的 chunk 文件</li>
</ul>
<h2 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h2><ul>
<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li>
<li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li>
<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li>
<li>image-loader：加载并且压缩图片文件</li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
</ul>
<h2 id="4-有哪些常见的Plugin？他们是解决什么问题的？"><a href="#4-有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="4.有哪些常见的Plugin？他们是解决什么问题的？"></a>4.有哪些常见的Plugin？他们是解决什么问题的？</h2><p>html-webpack-plugin：可以复制一个有结构的html文件，并自动引入打包输出的所有资源（JS/CSS）<br>clean-webpack-plugin：重新打包自动清空 dist 目录<br>mini-css-extract-plugin：提取 js 中的 css 成单独文件<br>optimize-css-assets-webpack-plugin：压缩css<br>uglifyjs-webpack-plugin：压缩js<br>commons-chunk-plugin：提取公共代码</p>
<h2 id="7-webpack-模块化打包的基本流程"><a href="#7-webpack-模块化打包的基本流程" class="headerlink" title="7) webpack 模块化打包的基本流程"></a>7) webpack 模块化打包的基本流程</h2><ul>
<li>连接: webpack 从入口 JS 开始, 递归查找出所有相关联的模块, 并<code>连接</code>起来形成一个图(网)的结构</li>
<li>编译: 将 JS 模块中的模块化语法<code>编译</code>为浏览器可以直接运行的模块语法(当然其它类型资源也会处理)</li>
<li>合并: 将图中所有编译过的模块<code>合并</code>成一个或少量几个 bundle 文件, 而浏览器运行是打包生成的 bundle 文件</li>
</ul>
<h2 id="比较-loader-与-plugin"><a href="#比较-loader-与-plugin" class="headerlink" title="比较 loader 与 plugin"></a>比较 loader 与 plugin</h2><p><strong>不同的作用</strong></p>
<ul>
<li><strong>Loader</strong>直译为”加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。</li>
<li><strong>Plugin</strong>直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li>
</ul>
<p><strong>不同的用法</strong></p>
<ul>
<li><strong>Loader</strong>在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li>
<li><strong>Plugin</strong>在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li>
</ul>
<h2 id="webpack-打包后文件体积过大怎么办"><a href="#webpack-打包后文件体积过大怎么办" class="headerlink" title="webpack 打包后文件体积过大怎么办"></a>webpack 打包后文件体积过大怎么办</h2><ul>
<li>异步加载模块（代码分割）；提取第三方库（使用 cdn 或者 vender）；代码压缩；去除不必要的插件；去除 devtool 选项等等</li>
</ul>
<h2 id="webpack-的-Tree-shaking-是什么"><a href="#webpack-的-Tree-shaking-是什么" class="headerlink" title="webpack 的 Tree-shaking 是什么?"></a>webpack 的 Tree-shaking 是什么?</h2><ul>
<li>Webpack 在打包 js 模块时, 会将模块中向外暴露但没有被使用的功能从打包文件中移除<br>2 个前提:<br>必须是使用 ES6 的 export 向外暴露的<br>必须进行 JS 的压缩处理</li>
</ul>
<h2 id="live-reload-与-hot-realod-HMR"><a href="#live-reload-与-hot-realod-HMR" class="headerlink" title="live-reload 与 hot-realod/HMR"></a>live-reload 与 hot-realod/HMR</h2><ul>
<li>相同点: 代码修改后都会自动重新编译打包</li>
<li>不同点:<ul>
<li>live-reload: 刷新整体页面, 从而查看到最新代码的效果, 页面状态全部都是新的</li>
<li>Hot-reload: 没有刷新整个页面, 只是加载了修改模块的打包文件并运行,从而更新页面的局部界面, 整个界面的其它部分的状态还在</li>
</ul>
</li>
</ul>
<p><img src="https://juejin.cn/post/7011765691812413476" alt="webpack"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>webpack面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全和工程化面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>前端安全和工程化面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>前端性能优化面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>计算机基础面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法面试题</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>数据结构和算法面试题</tag>
      </tags>
  </entry>
</search>
